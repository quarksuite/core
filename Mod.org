#+TITLE: Quarks System Core (v.1.0.0) Annotated Source
#+AUTHOR: Chatman R. Jr
#+PROPERTY: header-args :mkdirp yes

* Table of Contents :TOC@3:
- [[#introduction][Introduction]]
- [[#overview-of-system-design][Overview of System Design]]
- [[#formatters][Formatters]]
  - [[#css-formats][CSS Formats]]
    - [[#custom-properties][Custom Properties]]
    - [[#sass-scsslessstylus][Sass (SCSS)/Less/Stylus]]
  - [[#data-exports][Data Exports]]
  - [[#desktop-support][Desktop Support]]
  - [[#helpers][Helpers]]
    - [[#css-format-structure][CSS Format Structure]]
    - [[#undefined-project-metadata-error][Undefined Project Metadata Error]]
    - [[#metadata-emitter][Metadata Emitter]]
    - [[#token-string-constructor][Token String Constructor]]
    - [[#css-token-emitter][CSS Token Emitter]]
    - [[#css-token-assembler][CSS Token Assembler]]
    - [[#token-string-identifier][Token String Identifier]]
    - [[#automatic-versioning][Automatic Versioning]]
    - [[#timestamp-emitter][Timestamp Emitter]]
    - [[#yaml-assemblers][YAML Assemblers]]
- [[#utilities][Utilities]]
- [[#internals][Internals]]
  - [[#functional-programming][Functional Programming]]
    - [[#currying][Currying]]
    - [[#composition][Composition]]
    - [[#pipelining][Pipelining]]
  - [[#color][Color]]
    - [[#converter][Converter]]
    - [[#validator][Validator]]
    - [[#extractor][Extractor]]
    - [[#parser][Parser]]
  - [[#error-handling][Error Handling]]
- [[#data][Data]]
    - [[#named-color-keywords][Named Color Keywords]]
    - [[#colors-project-web-defaults][Colors Project Web Defaults]]
    - [[#system-font-stacks][System Font Stacks]]

* Introduction

Quarks System Core is written as a literate program in a top-down structure. Following this document
requires you understand the core concepts of the library, so I'll introduce those first.

You can access the test suite from =index.html=.

* Overview of System Design

From output to the  lowest level math, the system design is as follows:

+ Formatters: format a custom or bootstrapped Quarks System Dictionary as a file-ready set of design
  tokens for the web or other environments
+ Bootstrappers: outputs a complete dictionary from a configuration object
+ Transformers: convert entire Quarks System Dictionaries to other data formats (especially for interop)
+ Quarks System Dictionary: standard data schema consumed by transformers, returned by
  bootstrappers, and formatted by emitters
+ Formulas: features that represent data boilerplates for a bootstrapped or custom Quarks System Dictionary
+ Configurations: generic abstractions intended to streamline the assembly of formulas
+ Utilities: the functional toolbox used to create the higher abstractions
+ Internals: lower level utilities and helpers inaccessible to the user
+ Data: Hardcoded objects needed by some utilities

My hope is that this explicit outlining of the design will aid you in advanced use and extension of
Quarks System Core. Now, let's dive in.

* Formatters
:PROPERTIES:
:header-args:js: :tangle "./formatters.js" :comments link
:END:

At the top layer sit the formatters. Their only purpose is to format Quarks System Dictionaries into
file-ready design tokens. The available targets are named by their file extensions and include:

=css=: CSS custom properties
=scss/less/styl=: Variables for the respective preprocessor
=raw/yaml=: exports the raw dictionary (as JSON or YAML)
=gpl=: extracts the color dictionary for use in GIMP/Inkscape
=sketchpalette=: extracts the color dictionary as a Sketch palette

All of the formatters will /refuse/ to process a QSD that doesn't include =project= metadata. *This is by
design* as formatters are endpoints. The project metadata indicates that a dictionary needs no
additional processing and is ready for output.

The console will helpfully yell an error at you if you forget.

Crucial to note: Quarks System Core *assumes no read/write access* to your filesystem. The formatters
merely prepare your tokens for passalong to the filesystem library of your choice or your
environment's native filesystem API.

** CSS Formats

*** Custom Properties

Quarks System Core provides the most complete support for its CSS formats by virtue of being a
web-driven, web-focused kit. The first formatter preps your design tokens as CSS custom
properties wrapped in a root selector.

#+BEGIN_SRC js
export function css(dict) {
  return cssFormatStructure({}, dict);
}
#+END_SRC

*** Sass (SCSS)/Less/Stylus

The preprocessor formats require some minor adjustments.

#+BEGIN_SRC js
export function scss(dict) {
  return cssFormatStructure(
    {
      doc: ["\n/*!", " */\n"],
      metadata: ["", "// ", "\n\n"],
      wrapper: ["", "\n"],
      opts: { padding: "", prefix: "$" },
    },
    dict,
  );
}
#+END_SRC

#+BEGIN_SRC js
export function less(dict) {
  return cssFormatStructure(
    {
      doc: ["\n/*", " */\n"],
      metadata: ["", "// ", "\n\n"],
      wrapper: ["", "\n"],
      opts: { padding: "", prefix: "@" },
    },
    dict,
  );
}
#+END_SRC

#+BEGIN_SRC js
export function styl(dict) {
  return cssFormatStructure(
    {
      doc: ["\n/*!", " */\n"],
      metadata: ["", "// ", "\n\n"],
      wrapper: ["", "\n"],
      opts: { padding: "", prefix: "", assignment: " = ", suffix: "" },
    },
    dict,
  );
}
#+END_SRC

** Data Exports

Quarks System Core also allows direct data export to JSON and YAML for maximum portability.

#+BEGIN_SRC js
export function raw(dict) {
  const { project, ...tokens } = dict;
  const { bump = "manual" } = project || MissingProjectMetadataError();

  // Check if bump matches an automation keyword
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );

  // Then bump the version
  autobump && bumpVersion(project);

  return JSON.stringify({ project, tokens }, null, 2);
}
#+END_SRC

#+BEGIN_SRC js
export function yaml(dict) {
  const { project, ...tokens } = dict;
  const { bump = "manual" } = project || MissingProjectMetadataError();

  // Check if bump matches an automation keyword
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );

  // Then bump the version
  autobump && bumpVersion(project);

  const assemble = (level, tree) =>
    Object.entries(tree).reduce((str, [key, data]) => {
      if (typeof data === "string") return yamlDictValue(level, str, key, data);
      if (Array.isArray(data)) return yamlDictScale(level, str, key, data);
      if (key === "base") return yamlDictSubcategory(level, data);
      return str.concat(
        "".padStart(level),
        key,
        ":\n",
        assemble(level + 2, data),
      );
    }, "");

  return `
# ${timestampEmitter()}
${
    Object.entries({ project, tokens })
      .reduce((str, [key, data]) => {
        if (typeof data === "string") return yamlDictValue(0, str, key, data);
        if (Array.isArray(data)) return yamlDictScale(0, str, key, data);
        if (key === "base") return yamlDictSubcategory(0, data);
        return str.concat("\n", key, ":\n", assemble(2, data));
      }, "")
      .trimEnd()
  }
`;
}
#+END_SRC

** Desktop Support

Quarks System Core supports GIMP/Inkscape and Sketch palette formatting as of v1. The Inkscape
support was added because I occasionally create logos for stuff, and Sketch was added because it's
a popular app and I didn't realize the Sketch palette plugin schema was so light.

There are several reasons I won't support Adobe apps, but this isn't the place for that.

** Helpers

*** CSS Format Structure

The differences between the CSS formatters are trivial, so I abstracted the similarities into the
below helper function.

#+BEGIN_SRC js
function cssFormatStructure(
  {
    doc: [DOC_OPEN, DOC_CLOSE] = ["\n/**", " **/\n"],
    metadata: [OPEN, DELIM, CLOSE] = ["\n  /**", "   * ", "\n   **/\n\n"],
    wrapper: [TOKENS_OPEN, TOKENS_CLOSE] = ["\n:root {", "\n}\n"],
    opts = { padding: "  " },
  } = {},
  { project, ...tokens },
) {
  let {
    name,
    author,
    version,
    license,
    bump = "manual",
    metadata: { description = "N/A", comments = "N/A" } = {},
  } = project || MissingProjectMetadataError(project);

  // Attach a dynamic property initializing the autorelease version
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );

  return "".concat(
    DOC_OPEN,
    `
 * Project: ${name} (v${autobump ? bumpVersion(project) : version})
 * Owned by: ${author}
 * License: ${license}
 * ${"=".repeat(64)}
${
      metadataEmitter(
        { commentDelim: [" *", " * ", ""] },
        {
          description,
          comments,
        },
      )
    }
 * ${"-".repeat(64)}
 * ${timestampEmitter()}
`,
    DOC_CLOSE,
    TOKENS_OPEN,
    tokenStringConstructor(
      { ...opts, commentDelim: [OPEN, DELIM, CLOSE] },
      tokens,
    ),
    TOKENS_CLOSE,
  );
}
#+END_SRC

*** Undefined Project Metadata Error

A handy error to throw when the Quarks System Dictionary passed in to the formatters is
/incomplete/. As I stated further up, the formatters will not process any dictionary that's missing
project metadata.

#+BEGIN_SRC js
function MissingProjectMetadataError() {
  throw new QSCError({
    name: "Missing Project Metadata",
    reason: `
Formatters will not process a Quarks System Dictionary that's missing project
metadata. Its absence indicates that the current dictionary is still open
for modification.
`,
    suggestion: `
Be sure to include project metadata when you're ready to export your tokens.
Here's an example of the proper schema.

const finishedDict = {
  project: {
    name: "My Project",
    author: "Anonymous",
    version: "0.0.0",
    license: "Unlicense",
    // OPTIONAL can also be one of "major", "minor", "patch", "pre", "build" for automatic versioning
    bump: "manual",
    // OPTIONAL
    metadata: {
      description: "N/A",
      comments: "N/A"
    }
  },
  ...tokens
};

The first four properties are all required. Up to you if you want to include
a description or comments with your project.
`,
  });
}
#+END_SRC

*** Metadata Emitter

This helper provides a convenient way to assemble metadata as a comment block or line depending on
the format. It's used for both dictionary metadata and project metadata.

#+BEGIN_SRC js
function metadataEmitter(
  {
    commentDelim: [OPEN, DELIM, CLOSE] = ["\n  /**", "   * ", "\n   **/\n\n"],
    str = "",
  },
  meta,
) {
  return str.concat(
    [
      OPEN,
      Object.entries(meta).reduce((str, [key, value]) => {
        const lines = value.split("\n");

        if (lines.length > 1) {
          return str
            .concat(
              "\n",
              DELIM,
              key.toUpperCase(),
              ":",
              "\n",
              DELIM.trimEnd(),
              lines.join(`\n${DELIM}`),
            )
            .trimEnd();
        }

        return str.concat("\n", DELIM, key.toUpperCase(), ": ", lines);
      }, ""),
      CLOSE,
    ].join(""),
  );
}
#+END_SRC

*** Token String Constructor

The following construction helper is shared by all formatters in which the token identifier must be
created by traversing the dictionary. It uses recursion to walk branch by branch, combining keys with
a given delimiter until it reaches the end of the chain.

If it finds internal metadata, it will use a special function to process it

#+BEGIN_SRC js
function tokenStringConstructor(opts, dict) {
  return "".concat("\n", cssTokenEmitter(opts, "", dict));
}
#+END_SRC

*** CSS Token Emitter

This helper is responsible for actually walking the tree and emitting a complete collection of
tokens; formatting metadata as it finds it.

#+BEGIN_SRC js
function cssTokenEmitter(opts, head, node) {
  function assemble(head, node) {
    const { metadata, ...tokens } = node;
    return "".concat(
      (metadata && metadataEmitter(opts, metadata)) || "", // prepend metadata if defined
      Object.entries(tokens).reduce((str, [key, value]) => {
        const format = cssTokenAssembler(opts);
        if (typeof value === "object") {
          return str.concat(
            assemble(tokenStringIdentifier(head, key, "-"), value),
          );
        }

        return format(str, tokenStringIdentifier(head, key, "-"), value, "\n");
      }, ""),
    );
  }

  return assemble(head, node);
}
#+END_SRC

*** CSS Token Assembler

This helper is responsible for creating a string that the target format will actually recognize as a
variable or identifier.

#+BEGIN_SRC js
function cssTokenAssembler({
  padding = "",
  prefix = "--",
  assignment = ": ",
  suffix = ";",
  terminator = "\n",
}) {
  return function (str, key, value) {
    return str.concat(
      padding,
      prefix,
      key,
      assignment,
      value,
      suffix,
      terminator,
    );
  };
}
#+END_SRC

*** Token String Identifier

This helper is used when =*TokenEmitter= functions walk through the dictionary. It collects the
keys and joins them with a delimiter. However, it also /ignores/ any keys named base. Simply passing
through what it's already collected.

So =color.main.base= becomes =--color-main= in CSS for example.

#+BEGIN_SRC js
function tokenStringIdentifier(collected, current, delimiter) {
  return current === "base"
    ? collected
    : collected
    ? [collected, current].join(delimiter)
    : current;
}
#+END_SRC

*** Automatic Versioning

The following helper handles automatic versioning whenever project metadata defines =bump= as a
keyword other than ="manual"=.

#+BEGIN_SRC js
function bumpVersion(project) {
  let [major, minor, patch, pre] = Array.from(
    project.version.split(/[.-]/g),
  ).map((n) => parseFloat(n));

  function next(keyword) {
    const bumped = new Map([
      ["major", [major + 1, 0, 0]],
      ["minor", [major, minor + 1, 0]],
      ["patch", [major, minor, patch + 1]],
      ["pre", [major, minor, patch, pre + 1 || 0]],
      ["build", [major, minor, patch, pre, Date.now()]],
    ]).get(keyword);

    return bumped;
  }

  const releaseConditions = (release) =>
    Array.from(
      new Map([
        [release.length === 3, release.join(".")],
        [
          release.length === 4,
          [release.slice(0, 3).join("."), release[3]].join("-"),
        ],
        [
          release.length === 5,
          [
            release.slice(0, 3).join("."),
            [release[3] ?? 0, release[4]].join("+"),
          ].join("-"),
        ],
      ]),
    )
      .filter(([condition]) => condition)
      .flatMap(([, release]) => release)
      .toString();

  project["version"] = releaseConditions(next(project.bump));

  return project.version;
}
#+END_SRC

*** Timestamp Emitter

#+BEGIN_SRC js
function timestampEmitter() {
  const TIMESTAMP = new Date(Date.now());
  return `Updated on ${TIMESTAMP.toLocaleDateString()} at ${TIMESTAMP.toLocaleTimeString()}`;
}
#+END_SRC

*** YAML Assemblers

The following helpers format YAML by the three main structures of the Quarks System Dictionary
schema: values, scales, and subcategories. The value function helpfully handles the multiline
metadata strings as well.

#+BEGIN_SRC js
function yamlDictSubcategory(level, data) {
  return Object.entries(data).reduce((str, [key, v]) => {
    if (Array.isArray(v)) return yamlDictScale(level, str, key, v);
    return yamlDictValue(level, str, key, v);
  }, "");
}

function yamlDictValue(level, str, key, value) {
  const isMultiline = value.split("\n").length > 1;
  if (isMultiline) {
    return str.concat(
      "".padStart(level),
      `${key}: |\n`,
      value
        .split("\n")
        .reduce((s, line) => s.concat("".padStart(level + 2), line, "\n"), ""),
    );
  }
  return str.concat("".padStart(level), key, ": ", value, "\n");
}

function yamlDictScale(level, str, key, value) {
  return str.concat(
    "".padStart(level),
    key,
    ":\n",
    value.reduce((s, v) => s.concat("".padStart(level + 2), "- ", v, "\n"), ""),
  );
}
#+END_SRC

* Utilities
:PROPERTIES:
:header-args:js: :tangle "./utilities.js" :comments link
:END:
* Internals
** Functional Programming
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/fp.js" :comments link
:END:
My first set of internals are used throughout the codebase and contribute to its
composable and expressive design.

*** Currying

Currying is a powerful higher-order transformation where a function of =n= arguments is morphed into
a sequence of calls with one argument. So this: =fn(z, y, x)= becomes =fn(z)(y)(x)=.

This utility really shines in a data-last architectures like this project. Since the final argument
is /always/ data, currying allows you to preload its modifiers and leave the data operation =fn(x)=
for composition and pipelining.

The implementation is an advanced curry that allows partial application and uncurried functionality.

#+BEGIN_SRC js
export function curry(fn) {
  return (...initial) =>
    initial.length >= fn.length
      ? fn.apply(this, initial)
      : (...remaining) => fn.apply(this, initial.concat(remaining));
}
#+END_SRC

*** Composition

Functional composition is a higher-order operation that combines functions in sequence into a brand
new function queued for data. It's an excellent way to reuse tiny utilities for more complex
behavior.

Currying and composition are the chocolate and caramel of Quarks System Core.

#+BEGIN_SRC js
export function compose(...fns) {
  return (x) => fns.reduce((g, f) => f(g), x);
}
#+END_SRC

*** Pipelining

Pipelining is a powerful pattern that drives this project, because its main purpose is to generate
and manipulate data. Excepting the error handlers and formatters, data is *both the input and output*
of every function.

As the name implies, pipelining is a higher-order function where data is transformed by being piped
through a series of data operations. These operations can themselves include compositions and
pipelines.

Another way to think of it: composition combines data /operations/, pipelining applies data
/transformations/.

#+BEGIN_SRC js
export function pipe(x, ...fns) {
  return compose(...fns)(x);
}
#+END_SRC

** Color

The beefiest slab of code in Quarks System Core is by far the internal color library. This is
because color science is hard, I'm a little obsessive, and I wanted to get it as correct as I
possibly could.

*** Converter
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/index.js" :comments link
:END:

#+BEGIN_SRC js
import { compose, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import {
  cielabToRgb,
  cmykToRgb,
  hexToRgb,
  hslToRgb,
  hwbToRgb,
  oklabToRgb,
} from "./color_to_rgb.js";
import {
  cielabFromRgb,
  cmykFromRgb,
  hexFromRgb,
  hslFromRgb,
  hwbFromRgb,
  oklabFromRgb,
} from "./color_from_rgb.js";
import {
  cielabFromCielch,
  cielabToCielch,
  hexFromNamedColor,
} from "./linkers.js";
#+END_SRC

#+BEGIN_SRC js
const INPUT_TO_RGB = {
  named: compose(hexFromNamedColor, passthrough, hexToRgb),
  hex: hexToRgb,
  rgb: compose(hexFromRgb, passthrough, hexToRgb), // identity
  hsl: hslToRgb,
  cmyk: cmykToRgb,
  hwb: hwbToRgb,
  cielab: cielabToRgb,
  cielch: compose(cielabFromCielch, passthrough, cielabToRgb),
  oklab: oklabToRgb,
};

const OUTPUT_FROM_RGB = {
  hex: hexFromRgb,
  rgb: compose(hexFromRgb, passthrough, hexToRgb),
  hsl: hslFromRgb,
  cmyk: cmykFromRgb,
  hwb: hwbFromRgb,
  cielab: cielabFromRgb,
  cielch: compose(cielabFromRgb, passthrough, cielabToCielch),
  oklab: oklabFromRgb,
};

function passthrough([, color]) {
  return color;
}

export function convert(output, color) {
  const [input, value] = validator(color);
  return pipe(
    validator(color),
    ([input, color]) => INPUT_TO_RGB[input](color),
    ([, color]) => OUTPUT_FROM_RGB[output](color),
  );
}
#+END_SRC

**** Color to RGB
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/color_to_rgb.js" :comments link
:END:

#+BEGIN_SRC js
import { curry, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { output, parser } from "../parser/index.js";
import { normalize, numberToRgb } from "./math.js";
#+END_SRC

***** Hex to RGB

#+BEGIN_SRC js
export function hexToRgb(color) {
  const [, components] = parser(color);
  return pipe(output(["rgb", components]), validator);
}
#+END_SRC

***** HSL to RGB

#+BEGIN_SRC js
export function hslToRgb(color) {
  const [, [H, S, L, A]] = parser(color);

  // Calculate chroma
  const C = (1 - Math.abs(2 * L - 1)) * S;
  const X = C * (1 - Math.abs(((H / 60) % 2) - 1));
  const m = L - C / 2;

  const [R, G, B] = Array.from(calculateRGB(C, X, H))
    .filter(([, condition]) => condition)
    .flatMap(([evaluation]) => evaluation)
    .map((V) => pipe(V + m, numberToRgb, Math.round, curry(normalize)(255, 0)));

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}

function calculateRGB(C, X, H) {
  return new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);
}
#+END_SRC

***** CMYK to RGB

#+BEGIN_SRC js
export function cmykToRgb(color) {
  const [, [C, M, Y, K, A]] = parser(color);

  const [R, G, B] = [C, M, Y].map((V) =>
    pipe((1 - V) * (1 - K), numberToRgb, Math.round, curry(normalize)(255, 0))
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}
#+END_SRC

***** HWB to RGB

#+BEGIN_SRC js
export function hwbToRgb(color) {
  const [, [H, W, BLK, A]] = parser(color);

  // Achromacity
  if (W + BLK >= 1) {
    const GRAY = pipe(
      W / (W + BLK),
      numberToRgb,
      Math.round,
      curry(normalize)(255, 0),
    );

    return pipe(output(["rgb", [Array(3).fill(GRAY), A]]), validator);
  }

  const [R, G, B] = pipe(
    `hsl(${H}, 100%, 50%)`,
    hslToRgb,
    ([, color]) => parser(color),
    ([, color]) => color,
  ).map((V) =>
    pipe(
      V * (1 - W - BLK) + W,
      numberToRgb,
      Math.round,
      curry(normalize)(255, 0),
    )
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}
#+END_SRC

***** CIELAB to RGB

#+BEGIN_SRC js
export function cielabToRgb(color) {
  const [, [L, a, b, A]] = parser(color);
  const [X, Y, Z] = cielabToCiexyz([L, a, b]);
  const [LR, LG, LB] = ciexyzToLrgb([X, Y, Z]);
  const [R, G, B] = lrgbToRgb([LR, LG, LB]).map((V) =>
    pipe(V, numberToRgb, Math.round, curry(normalize)(255, 0))
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}

function cielabToCiexyz([L, a, b]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const WHITE = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const FY = (L + 16) / 116;
  const FX = a / 500 + FY;
  const FZ = FY - b / 200;

  // Calculate xyz
  const [X, Y, Z] = [
    FX ** 3 > ε ? FX ** 3 : (116 * FX - 16) / κ,
    L > κ * ε ? FY ** 3 : L / κ,
    FZ ** 3 > ε ? FZ ** 3 : (116 * FZ - 16) / κ,
  ].map((V, i) => V * WHITE[i]);

  return [X, Y, Z];
}

const D65_CHROMATIC_ADAPTATION = [
  [0.9555766, -0.0230393, 0.0631636],
  [-0.0282895, 1.0099416, 0.0210077],
  [0.0122982, -0.020483, 1.3299098],
];

const LINEAR_RGB_TRANSFORMATION_MATRIX = [
  [3.2404542, -1.5371385, -0.4985314],
  [-0.969266, 1.8760108, 0.041556],
  [0.0556434, -0.2040259, 1.0572252],
];

function ciexyzToLrgb([X, Y, Z]) {
  const [CX, CY, CZ] = D65_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => X * V1 + Y * V2 + Z * V3,
  );

  const [LR, LG, LB] = LINEAR_RGB_TRANSFORMATION_MATRIX.map(
    ([V1, V2, V3]) => CX * V1 + CY * V2 + CZ * V3,
  );

  return [LR, LG, LB];
}

function lrgbToRgb([LR, LG, LB]) {
  return [LR, LG, LB].map((V) =>
    V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055
  );
}
#+END_SRC

***** Oklab to RGB

#+BEGIN_SRC js
export function oklabToRgb(color) {
  const [, [L, a, b, A]] = parser(color);
  const [LR, LG, LB] = oklabToLrgb([L, a, b]);

  const [R, G, B] = lrgbToRgb([LR, LG, LB]).map((V) =>
    pipe(V, numberToRgb, Math.round, curry(normalize)(255, 0))
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}

const LINEAR_LMS_CONE_ACTIVATIONS = [
  [0.3963377774, 0.2158037573],
  [0.1055613458, 0.0638541728],
  [0.0894841775, 1.291485548],
];

const LINEAR_RGB_OKLAB_MATRIX = [
  [4.076416621, 3.3077115913, 0.2309699292],
  [-1.2684380046, 2.6097574011, 0.3413193965],
  [-0.0041960863, 0.7034186147, 1.707614701],
];

function oklabToLrgb([L, a, b]) {
  const [LONG, M, S] = LINEAR_LMS_CONE_ACTIVATIONS.map(([V1, V2], pos) => {
    if (pos === 0) return L + a * V1 + b * V2;
    if (pos === 1) return L - a * V1 - b * V2;
    return L - a * V1 - b * V2;
  }).map((V) => V ** 3);

  const [LR, LG, LB] = LINEAR_RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return LONG * V1 - M * V2 + S * V3;
    if (pos === 1) return LONG * V1 + M * V2 - S * V3;
    return LONG * V1 - M * V2 + S * V3;
  });

  return [LR, LG, LB];
}
#+END_SRC

**** Color from RGB
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/color_from_rgb.js" :comments link
:END:

#+BEGIN_SRC js
import { curry, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { output, parser } from "../parser/index.js";
import {
  hexFragmentFromRgb,
  hueCorrection,
  normalize,
  numberToPercent,
  numberToRgb,
  precision,
  radToDegrees,
} from "./math.js";
#+END_SRC

***** Hex from RGB

#+BEGIN_SRC js
export function hexFromRgb(color) {
  const [, components] = parser(color);
  return pipe(
    output([
      "hex",
      components.map((V) =>
        pipe(
          V,
          numberToRgb,
          Math.round,
          curry(normalize)(255, 0),
          hexFragmentFromRgb,
        )
      ),
    ]),
    validator,
  );
}
#+END_SRC

***** HSL from RGB

#+BEGIN_SRC js
export function hslFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);

  const MIN = Math.min(R, G, B);
  const MAX = Math.max(R, G, B);
  const DELTA = MAX - MIN;

  const L = calculateLightness(MIN, MAX);
  const [[H], S] = [
    Array.from(calculateHue(R, G, B, MAX, DELTA))
      .filter(([, condition]) => condition)
      .flatMap(([result]) => result),
    calculateSaturation(DELTA, L),
  ];

  const limitPercent = curry(normalize)(100, 0);

  return pipe(
    output([
      "hsl",
      [
        hueCorrection(H),
        ...[S, L].map((V) =>
          pipe(V, numberToPercent, limitPercent, (value) => value.toString())
            .concat("%")
        ),
        A,
      ],
    ]),
    validator,
  );
}

function calculateLightness(cmin, cmax) {
  return (cmax + cmin) / 2;
}

function calculateHue(R, G, B, cmax, delta) {
  return new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);
}

function calculateSaturation(delta, L) {
  return delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));
}
#+END_SRC

***** CMYK from RGB

#+BEGIN_SRC js
export function cmykFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);

  const K = 1 - Math.max(R, G, B);
  const [C, M, Y] = [R, G, B].map((V) => (1 - V - K) / (1 - K));

  const limitPercent = curry(normalize)(100, 0);

  return pipe(
    output([
      "cmyk",
      [
        ...[C, M, Y, K]
          .map((V) => (isNaN(V) ? 0 : pipe(V, numberToPercent, limitPercent)))
          .map((V) => V.toString().concat("%")),
        A,
      ],
    ]),
    validator,
  );
}
#+END_SRC

***** HWB from RGB

#+BEGIN_SRC js
export function hwbFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);

  const MAX = Math.max(R, G, B);
  const MIN = Math.min(R, G, B);
  const DELTA = MAX - MIN;

  const [H] = Array.from(calculateHue(R, G, B, MAX, DELTA))
    .filter(([, condition]) => condition)
    .flatMap(([result]) => result);

  const [W, BLK] = [MIN, 1 - MAX];

  const limitPercent = curry(normalize)(100, 0);

  return pipe(
    output([
      "hwb",
      [
        hueCorrection(H),
        ...[W, BLK].map((V) =>
          pipe(V, numberToPercent, limitPercent).toString().concat("%")
        ),
        A,
      ],
    ]),
    validator,
  );
}
#+END_SRC

***** CIELAB from RGB

#+BEGIN_SRC js
export function cielabFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);
  const [X, Y, Z] = rgbToCieXYZ([R, G, B]);
  const [L, a, b] = ciexyzToCielab([X, Y, Z]);

  return pipe(
    output(["cielab", [L.toString().concat("%"), a, b, A]]),
    validator,
  );
}

function ciexyzToCielab([X, Y, Z]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const D50_WHITE = [0.96422, 1.0, 0.82521];

  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z]
    .map((V, i) => V / D50_WHITE[i])
    .map((V) => (V > ε ? Math.cbrt(V) : (κ * V + 16) / 116));

  const [L, a, b] = [116 * FY - 16, 500 * (FX - FY), 200 * (FY - FZ)]
    .map((V) => precision(V))
    .map((V, pos) =>
      pos === 0 ? normalize(256, 0, V) : +normalize(128, -127, V).toFixed(4)
    );

  return [L, a, b];
}

const D65_REFERENCE_WHITE = [
  [0.4124564, 0.3575761, 0.1804375],
  [0.2126729, 0.7151522, 0.072175],
  [0.0193339, 0.119192, 0.9503041],
];

const D50_CHROMATIC_ADAPTATION = [
  [1.0478112, 0.0228866, -0.050127],
  [0.0295424, 0.9904844, -0.0170491],
  [-0.0092345, 0.0150436, 0.7521316],
];

function rgbToCieXYZ([R, G, B]) {
  const [LR, LG, LB] = rgbToLinearRGB([R, G, B]);

  const [x, y, z] = D65_REFERENCE_WHITE.map(
    ([V1, V2, V3]) => LR * V1 + LG * V2 + LB * V3,
  );

  const [X, Y, Z] = D50_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => x * V1 + y * V2 + z * V3,
  );

  return [X, Y, Z];
}

function rgbToLinearRGB([R, G, B]) {
  return [R, G, B].map((V) =>
    V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4
  );
}
#+END_SRC

***** Oklab from RGB

#+BEGIN_SRC js
export function oklabFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);
  const [l, a, b] = linearRGBToOklab([R, G, B]);

  const L = numberToPercent(l).toString().concat("%");
  const c = normalize(0.5, 0, +Math.sqrt(a ** 2 + b ** 2).toFixed(4)); // toPrecision isn't strict enough
  const C = Math.sign(Math.round(c)) === -1 ? 0 : c;
  const H = pipe(Math.atan2(b, a), radToDegrees, hueCorrection);

  return pipe(output(["oklab", [L, C, H, A]]), validator);
}

const NONLINEAR_LMS_CONE_ACTIVATIONS = [
  [0.4122214708, 0.5363325363, 0.0514459929],
  [0.2119034982, 0.6806995451, 0.1073969566],
  [0.0883024619, 0.2817188376, 0.6299787005],
];

const RGB_OKLAB_MATRIX = [
  [0.2104542553, 0.793617785, 0.0040720468],
  [1.9779984951, 2.428592205, 0.4505937099],
  [0.0259040371, 0.7827717662, 0.808675766],
];

function linearRGBToOklab([R, G, B]) {
  const [LR, LG, LB] = rgbToLinearRGB([R, G, B]);

  const [L, M, S] = NONLINEAR_LMS_CONE_ACTIVATIONS.map(
    ([L, M, S]) => L * LR + M * LG + S * LB,
  ).map((V) => Math.cbrt(V));

  return RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return V1 * L + V2 * M - V3 * S;
    if (pos === 1) return V1 * L - V2 * M + V3 * S;
    return V1 * L + V2 * M - V3 * S;
  });
}
#+END_SRC

**** Linkers
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/linkers.js" :comments link
:END:

#+BEGIN_SRC js
import { NAMED_COLOR_KEYWORDS } from "../../../data.js";
import { pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { output, parser } from "../parser/index.js";
import {
  hueCorrection,
  normalize,
  radFromDegrees,
  radToDegrees,
} from "./math.js";
#+END_SRC

***** Named Color to Hex

#+BEGIN_SRC js
export function hexFromNamedColor(color) {
  return validator(NAMED_COLOR_KEYWORDS[color]);
}
#+END_SRC

***** CIELAB to CIELCh(ab)

#+BEGIN_SRC js
export function cielabToCielch(color) {
  const [, [L, a, b, A]] = parser(color);

  const C = normalize(132, 0, Math.sqrt(a ** 2 + b ** 2));
  const H = pipe(Math.atan2(b, a), radToDegrees, hueCorrection);

  return pipe(
    output(["cielch", [L.toString().concat("%"), C, H, A]]),
    validator,
  );
}
#+END_SRC

***** CIELCh(ab) to CIELAB

#+BEGIN_SRC js
export function cielabFromCielch(color) {
  const [, [L, C, H, A]] = parser(color);

  const [a, b] = [
    C * Math.cos(radFromDegrees(H)),
    C * Math.sin(radFromDegrees(H)),
  ].map((V) => normalize(128, -127, V));

  return pipe(
    output(["cielab", [L.toString().concat("%"), a, b, A]]),
    validator,
  );
}
#+END_SRC

**** Math
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/math.js" :comments link
:END:

#+BEGIN_SRC js
import { compose } from "../../fp.js";
#+END_SRC

***** Arithmetic

#+BEGIN_SRC js
const add = (y, x) => x + y;
const multiply = (y, x) => x * y;
const divide = (y, x) => x / y;
const remainder = (y, x) => x % y;
#+END_SRC

***** Limiters

#+BEGIN_SRC js
export const precision = (value) => +value.toPrecision(5);
export const normalize = (b, a, x) => (x < a ? a : x > b ? b : precision(x));
#+END_SRC

***** Hexadecimal

#+BEGIN_SRC js
export const hexFragmentToRgb = (fragment) => parseInt(fragment, 16);
export const hexFragmentFromRgb = (channel) =>
  channel.toString(16).padStart(2, "0");
#+END_SRC

***** Percent Calculations

#+BEGIN_SRC js
export const numberToPercent = (n) => multiply(100, n);
export const numberFromPercent = (percentage) => divide(100, percentage);
#+END_SRC

***** RGB Component Calculations

#+BEGIN_SRC js
export const numberToRgb = (n) => multiply(255, n);
export const numberFromRgb = (channel) => divide(255, channel);
export const rgbFromPercent = compose(
  numberFromPercent,
  numberToRgb,
  Math.round,
);
export const hexFragmentFromNumber = compose(
  numberToRgb,
  Math.round,
  hexFragmentFromRgb,
);
#+END_SRC

***** Hue Calculations

#+BEGIN_SRC js
export const radToDegrees = (radians) =>
  compose(
    () => divide(Math.PI, 180),
    (result) => multiply(result, radians),
    (degrees) => precision(degrees),
  )();
export const radFromDegrees = (degrees) =>
  compose(
    () => divide(180, Math.PI),
    (result) => multiply(result, degrees),
    (radians) => precision(radians),
  )();
export const gradToDegrees = (gradians) =>
  compose(
    () => divide(200, 180),
    (result) => multiply(result, gradians),
    (degrees) => precision(degrees),
  )();
export const numberToDegrees = (n) => multiply(360, n);
export const hueCorrection = (hue) =>
  normalize(
    360,
    -360,
    Math.sign(hue) === -1 ? Math.abs(add(360, hue)) : hue > 360
      ? remainder(360, hue)
      : hue,
  );
#+END_SRC

*** Validator
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/validator/index.js" :comments link
:END:

#+BEGIN_SRC js
import { QSCError } from "../../../error.js";
#+END_SRC

Before a color can be converted, we must be sure it's in fact a color.

#+BEGIN_SRC js
const SUPPORTED_FORMATS = {
  named: namedValidator,
  hex: hexValidator,
  rgb: rgbValidator,
  hsl: hslValidator,
  cmyk: cmykValidator,
  hwb: hwbValidator,
  cielab: cielabValidator,
  cielch: cielchValidator,
  oklab: oklabValidator,
};

export function validator(color) {
  return (
    Object.entries(SUPPORTED_FORMATS)
      .map(([format, fn]) => [format, fn(color) && color])
      .find(([, color]) => color) || InvalidOrUnsupportedColorError()
  );
}

function InvalidOrUnsupportedColorError() {
  throw new QSCError({
    name: "Invalid or Unsupported Color",
    reason: `
The input matches none of Quarks System Core's supported color formats. It's
also possible you have a syntax error.
`,
    suggestion: `
Check your input color against these supported CSS color formats:

Named Colors
------------
coral
springgreen
dodgerblue
rebeccapurple

RGB Hex
-------
#f0f
#ca5e
#933cca
#99eefff7

Functional RGB
--------------
rgb(30, 110, 0)
rgb(19%, 38.9%, 70%)
rgba(255, 255, 255, 0.8)
rgb(129 22 108)
rgb(20% 2% 100% / 0.25)

Functional HSL
--------------
hsl(240, 39%, 81%)
hsla(120, 78%, 45%, 0.93)
hsl(2.5rad 29% 40%)
hsl(216.44grad 20% 90% / 0.75)

Device CMYK
-----------
device-cmyk(0 0.2 0.399 0)
device-cmyk(90% 0% 0% 37.5%)
device-cmyk(0% 39% 0% 0 / 0.88)

HWB
---
hwb(60 83% 0%)
hwb(90 0% 37%)
hwb(0.75turn 30% 25%)
hwb(300 29% 5% / 0.99)

CIELAB
------
lab(48% 101 -39)
lab(87% -33 0)
lab(59% -88 -2 / 0.5)

CIELCh(ab)
----------
lch(25% 49 180)
lch(75% 0 0)
lch(56.551 77.38 2rad / 0.6892)

Oklab (LCh)
-----------
NOTE: This format is non-standard. If you use it, be sure to
convert to a standard CSS format. Example: hex("oklab(0% 0 0)")

oklab(59.4% 0.33 150)
oklab(33% 64% 0.2turn)
oklab(68.332% 0.16 1.778rad)
`,
  });
}
#+END_SRC

**** Syntax Tokens

***** Primitives

#+BEGIN_SRC js
const NUMBER_TOKEN = /(?:-?(?!0\d)\d+(?:\.\d+)?)/;
const PERCENT_TOKEN = new RegExp(["(?:", NUMBER_TOKEN.source, "%)"].join(""));
#+END_SRC

***** Delimiters

#+BEGIN_SRC js
const DELIMITER = /(?:[\s,]+)/;
const ALPHA_DELIMITER = new RegExp(DELIMITER.source.replace(",", ",/"));
const CSS4_DELIMITER = new RegExp(DELIMITER.source.replace(",", ""));
const CSS4_ALPHA_DELIMITER = new RegExp(
  ALPHA_DELIMITER.source.replace(",", ""),
);
#+END_SRC

***** Components

#+BEGIN_SRC js
const COMPONENT_TOKEN = new RegExp(
  ["(?:", PERCENT_TOKEN.source, "|", NUMBER_TOKEN.source, ")"].join(""),
);
const HUE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "(?:deg|g?rad|turn)?)"].join(""),
);
#+END_SRC

**** Named Color Validator

#+BEGIN_SRC js
function namedValidator(color) {
  return !!NAMED_COLORS[color];
}
#+END_SRC

**** Hex Validator

#+BEGIN_SRC js
function hexValidator(color) {
  return /^#([\da-f]{3,4}){1,2}$/i.test(color);
}
#+END_SRC

**** RGB Validator

#+BEGIN_SRC js
function rgbValidator(color) {
  return matchFunctionalFormat(
    { prefix: "rgba?" },
    Array(3).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

**** HSL Validator

#+BEGIN_SRC js
function hslValidator(color) {
  return matchFunctionalFormat({ prefix: "hsla?" }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENT_TOKEN),
  ]).test(color);
}
#+END_SRC

**** CMYK Validator

#+BEGIN_SRC js
function cmykValidator(color) {
  return matchFunctionalFormat(
    { prefix: "device-cmyk", legacy: false },
    Array(4).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

**** HWB Validator

#+BEGIN_SRC js
function hwbValidator(color) {
  return matchFunctionalFormat({ prefix: "hwb", legacy: false }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENT_TOKEN),
  ]).test(color);
}
#+END_SRC

**** CIELAB Validator

#+BEGIN_SRC js
function cielabValidator(color) {
  return matchFunctionalFormat({ prefix: "lab", legacy: false }, [
    PERCENT_TOKEN,
    ...Array(2).fill(NUMBER_TOKEN),
  ]).test(color);
}
#+END_SRC

**** CIELCh(ab) Validator

#+BEGIN_SRC js
function cielchValidator(color) {
  return matchFunctionalFormat({ prefix: "lch", legacy: false }, [
    PERCENT_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

**** Oklab Validator

#+BEGIN_SRC js
function oklabValidator(color) {
  return matchFunctionalFormat({ prefix: "oklab", legacy: false }, [
    PERCENT_TOKEN,
    COMPONENT_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

**** Functional Formats

#+BEGIN_SRC js
function matchFunctionalFormat({ prefix, legacy = true }, tokens) {
  const VALUES = tokens.map((token) => token.source);

  const SEPARATOR = legacy ? DELIMITER.source : CSS4_DELIMITER.source;
  const ALPHA_SEPARATOR = legacy
    ? ALPHA_DELIMITER.source
    : CSS4_ALPHA_DELIMITER.source;

  return new RegExp(
    `(?:^${prefix}\\(`.concat(
      VALUES.join(SEPARATOR),
      `(?:${[ALPHA_SEPARATOR, COMPONENT_TOKEN.source].join("")})?\\))`,
    ),
  );
}
#+END_SRC

*** Extractor
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/extractor/index.js" :comments link
:END:

#+BEGIN_SRC js
import { compose } from "../../fp.js";
import { validator } from "../validator/index.js";
#+END_SRC

Once we're sure have a valid color, we need to extract its components.

#+BEGIN_SRC js
export const extractor = compose(validator, ([format, color]) => [
  format,
  format === "hex" ? hexExtractor(color) : componentExtractor(color),
]);
#+END_SRC

**** Hex Extractor

#+BEGIN_SRC js
function hexExtractor(color) {
  return expandHex(color).match(/[\da-f]{2}/gi);
}

function expandHex(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

**** Component Extractor

#+BEGIN_SRC js
function componentExtractor(color) {
  return color.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
}
#+END_SRC

*** Parser
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/parser/index.js" :comments link
:END:

#+BEGIN_SRC js
import { compose, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { extractor } from "../extractor/index.js";
import {
  gradToDegrees,
  hexFragmentToRgb,
  hueCorrection,
  numberFromPercent,
  numberFromRgb,
  numberToDegrees,
  precision,
  radFromDegrees,
  radToDegrees,
} from "../converter/math.js";
#+END_SRC

Finally, before the conversion math, we need to parse the extracted components to raw values as
determined by the color conversion formulas below.

#+BEGIN_SRC js
const FORMAT_PARSERS = {
  hex: parseHex,
  rgb: parseRGB,
  hsl: parseHSL,
  cmyk: parseCMYK,
  hwb: parseHSL, // identical to HSL
  cielab: parseCielab,
  cielch: parseCielch,
  oklab: parseOklab,
};

export const parser = compose(
  validator,
  ([format, color]) => FORMAT_PARSERS[format](color),
);
#+END_SRC

**** Format Parsers

***** Hex Parser

#+BEGIN_SRC js
function parseHex(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "ff"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 3
          ? pipe(c, hexFragmentToRgb, numberFromRgb)
          : hexFragmentToRgb(c)
      ),
    ],
  );
}
#+END_SRC

***** RGB Parser

#+BEGIN_SRC js
function parseRGB(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        c.endsWith("%")
          ? parsePercent(c)
          : pos === 3
          ? parseNumber(c)
          : parseChannel(c)
      ),
    ],
  );
}
#+END_SRC

***** HSL Parser

#+BEGIN_SRC js
function parseHSL(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 0
          ? parseHue(c)
          : pos === 3
          ? c.endsWith("%") ? parsePercent(c) : parseNumber(c)
          : parsePercent(c)
      ),
    ],
  );
}
#+END_SRC

***** CMYK Parser

#+BEGIN_SRC js
function parseCMYK(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 5 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c) => c.endsWith("%") ? parsePercent(c) : parseNumber(c)),
    ],
  );
}
#+END_SRC

***** CIELAB Parser

#+BEGIN_SRC js
function parseCielab(color) {
  return parseCie((ab) => parseNumber(ab), color);
}
#+END_SRC

***** CIELCh(ab) Parser

#+BEGIN_SRC js
function parseCielch(color) {
  return parseCie(
    (c, pos) => (pos === 2 ? parseHue(c) : parseNumber(c)),
    color,
  );
}
#+END_SRC

***** Oklab Parser

#+BEGIN_SRC js
function parseOklab(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 0
          ? parsePercent(c)
          : pos === 1 || pos === 3
          ? c.endsWith("%") ? parsePercent(c) : parseNumber(c)
          : parseHueAsRadians(c)
      ),
    ],
    ([format, [L, C, H, A]]) => [
      format,
      [L, C * Math.cos(H), C * Math.sin(H), A],
    ],
  );
}
#+END_SRC

**** Token Parsers

***** Number Parser

#+BEGIN_SRC js
function parseNumber(n) {
  return pipe(n, parseFloat, precision);
}
#+END_SRC

***** Percent Parser

#+BEGIN_SRC js
function parsePercent(percentage) {
  return pipe(percentage, parseFloat, numberFromPercent);
}
#+END_SRC

***** RGB Channel Parser

#+BEGIN_SRC js
function parseChannel(channel) {
  return pipe(channel, parseFloat, numberFromRgb);
}
#+END_SRC

***** Hue Parsers

#+BEGIN_SRC js
function parseHue(hue) {
  return hueCorrection(
    hue.endsWith("grad")
      ? gradToDegrees(parseFloat(hue))
      : hue.endsWith("rad")
      ? radToDegrees(parseFloat(hue))
      : hue.endsWith("turn")
      ? numberToDegrees(parseFloat(hue))
      : parseFloat(hue),
  );
}

function parseHueAsRadians(hue) {
  return hue.endsWith("rad") && !hue.endsWith("grad")
    ? parseNumber(hue)
    : pipe(hue, parseHue, radFromDegrees);
}
#+END_SRC

***** CIE* Parser

#+BEGIN_SRC js
function parseCie(unique, color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 0
          ? parseNumber(c)
          : pos === 3
          ? c.endsWith("%") ? parsePercent(c) : parseNumber(c)
          : unique(c, pos)
      ),
    ],
  );
}
#+END_SRC

**** Output

#+BEGIN_SRC js
export function output(data) {
  return pipe(
    data,
    ([format, components]) => COLOR_ASSEMBLER(components)[format],
  );
}
#+END_SRC

#+BEGIN_SRC js
function COLOR_ASSEMBLER(components) {
  return {
    hex: hexOutput(components),
    rgb: legacyOutput("rgb", components),
    hsl: legacyOutput("hsl", components),
    cmyk: modernOutput("device-cmyk", components),
    hwb: modernOutput("hwb", components),
    cielab: modernOutput("lab", components),
    cielch: modernOutput("lch", components),
    oklab: modernOutput("oklab", components),
  };
}

function hexOutput([R, G, B, A]) {
  return "#".concat(R, G, B, A === "ff" ? "" : A);
}

function legacyOutput(prefix, [C1, C2, C3, A]) {
  return `${A === 1 ? prefix : prefix.concat("a")}(`.concat(
    (A === 1 ? [C1, C2, C3] : [C1, C2, C3, A]).join(", "),
    ")",
  );
}

function modernOutput(prefix, components) {
  return `${prefix}(`.concat(
    components.slice(0, components.length - 1).join(" "),
    components[components.length - 1] === 1 ? "" : ` / ${components.slice(-1)}`,
    ")",
  );
}
#+END_SRC

** Error Handling
:PROPERTIES:
:header-args:js: :tangle "./lib/error.js" :comments link
:END:

For v1, I wanted to create better custom errors. So I decided to directly extend the =Error= class
with my own general =QSCError= class. This will allow me to throw any number of errors I need
/within/ the context they're triggered and gives me a free stack trace back to what broke.

#+BEGIN_SRC js
export class QSCError extends Error {
  constructor({
    name = "Unknown Error",
    reason = "here's why",
    suggestion = "try this",
  } = {}) {
    super();
    this.name = name;
    this.message = `
${reason}
${suggestion}
${"=".repeat(80)}
`;
  }
}
#+END_SRC

* Data
:PROPERTIES:
:header-args:js: :tangle "./lib/data.js" :comments link
:END:

At the bottom rung sits collections of hardcoded data required for processing named color keywords,
Colors project defined web defaults, and system font stacks.

*** Named Color Keywords

#+BEGIN_SRC js
export const NAMED_COLOR_KEYWORDS = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
#+END_SRC

*** Colors Project Web Defaults

#+BEGIN_SRC js
export const A11Y_PALETTE = {
  navy: "#001f3f",
  blue: "#0074d9",
  aqua: "#7fdbff",
  teal: "#39cccc",
  olive: "#3d9970",
  green: "#2ecc40",
  lime: "#01ff70",
  yellow: "#ffdc00",
  orange: "#ff851b",
  red: "#ff4136",
  maroon: "#85144b",
  fuchsia: "#f012be",
  purple: "#b10dc9",
  black: "#111111",
  gray: "#aaaaaa",
  grey: "#aaaaaa",
  silver: "#dddddd",
  white: "#ffffff",
};
#+END_SRC

*** System Font Stacks

#+BEGIN_SRC js
export const SYSTEM_FONT_STACKS = {
  sans:
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  serif:
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  monospace:
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
};
#+END_SRC
