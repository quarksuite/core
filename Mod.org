#+TITLE: Quarks System Core (v.1.0.0) Annotated Source
#+AUTHOR: Chatman R. Jr
#+PROPERTY: header-args :mkdirp yes

* Table of Contents :TOC@3:
- [[#introduction][Introduction]]
- [[#entry-point][Entry Point]]
- [[#overview-of-system-design][Overview of System Design]]
- [[#schema][Schema]]
- [[#formatters][Formatters]]
  - [[#css-formats][CSS Formats]]
    - [[#custom-properties][Custom Properties]]
    - [[#preprocessors][Preprocessors]]
  - [[#data-exports][Data Exports]]
  - [[#desktop-support][Desktop Support]]
    - [[#gimpinkscape][GIMP/Inkscape]]
    - [[#sketch][Sketch]]
  - [[#interopintegration][Interop/Integration]]
- [[#bootstrapper][Bootstrapper]]
  - [[#quarks-system-standard][Quarks System Standard]]
- [[#formulas][Formulas]]
  - [[#palette-formulas][Palette Formulas]]
  - [[#typography-formulas][Typography Formulas]]
  - [[#layout-formulas][Layout Formulas]]
  - [[#animation-formulas][Animation Formulas]]
- [[#configurations][Configurations]]
  - [[#numeric-color-scale][Numeric Color Scale]]
  - [[#modular-scale-types][Modular Scale Types]]
- [[#utilities][Utilities]]
  - [[#functional-programming][Functional Programming]]
  - [[#color][Color]]
    - [[#color-conversion][Color Conversion]]
    - [[#color-format-comparison][Color Format Comparison]]
    - [[#color-property-adjustment][Color Property Adjustment]]
    - [[#color-mixture][Color Mixture]]
  - [[#color-scales-palettes][Color Scales (Palettes)]]
    - [[#interpolation][Interpolation]]
    - [[#blending][Blending]]
    - [[#material][Material]]
    - [[#color-schemes][Color Schemes]]
    - [[#variants][Variants]]
  - [[#color-scale-adjustments][Color Scale Adjustments]]
    - [[#palette-shifting][Palette Shifting]]
    - [[#palette-sorting][Palette Sorting]]
    - [[#palette-filtering][Palette Filtering]]
  - [[#color-accessibility-a11y][Color Accessibility (A11y)]]
    - [[#colors-project-web-defaults][Colors Project Web Defaults]]
    - [[#color-contrast-ratio][Color Contrast Ratio]]
  - [[#typography][Typography]]
    - [[#system-font-stacks][System Font Stacks]]
  - [[#modular-scales][Modular Scales]]
    - [[#scale-creation][Scale Creation]]
    - [[#scale-modification][Scale Modification]]
    - [[#attaching-units][Attaching Units]]
- [[#library][Library]]
  - [[#formatter-helpers][Formatter Helpers]]
    - [[#css-format-structure][CSS Format Structure]]
    - [[#undefined-project-metadata-error][Undefined Project Metadata Error]]
    - [[#metadata-emitter][Metadata Emitter]]
    - [[#token-string-constructor][Token String Constructor]]
    - [[#css-token-emitter][CSS Token Emitter]]
    - [[#css-token-assembler][CSS Token Assembler]]
    - [[#token-string-identifier][Token String Identifier]]
    - [[#automatic-versioning][Automatic Versioning]]
    - [[#timestamp-emitter][Timestamp Emitter]]
    - [[#yaml-assemblers][YAML Assemblers]]
  - [[#utilities-1][Utilities]]
    - [[#functional-programming-1][Functional Programming]]
    - [[#color-1][Color]]
  - [[#error-handling][Error Handling]]
  - [[#data][Data]]

* Introduction

* Entry Point
:PROPERTIES:
:header-args:js: :tangle "./mod.js" :comments link
:END:

#+BEGIN_SRC js
export * from "./formatters.js";
export * from "./bootstrapper.js";
export * from "./formulas.js";
export * from "./configurations.js";
export * from "./utilities.js";
#+END_SRC

* Overview of System Design

* Schema

* Formatters
:PROPERTIES:
:header-args:js: :tangle "./formatters.js" :comments link
:END:

#+BEGIN_SRC js
import {
  bumpVersion,
  cssFormatStructure,
  metadataEmitter,
  MissingProjectMetadataError,
  timestampEmitter,
  tokenStringIdentifier,
  yamlDictScale,
  yamlDictSubcategory,
  yamlDictValue,
} from "./lib/formatters/index.js";
import { extractor } from "./lib/utilities/color/extractor/index.js";
import { parser } from "./lib/utilities/color/parser/index.js";
import { color_to_hex, color_to_rgb, utility_pipe } from "./utilities.js";
#+END_SRC

** CSS Formats

*** Custom Properties

#+BEGIN_SRC js
export function output_css(dict) {
  return cssFormatStructure({}, dict);
}
#+END_SRC

*** Preprocessors

#+BEGIN_SRC js
export function output_scss(dict) {
  return cssFormatStructure(
    {
      doc: ["\n/*!", " */\n"],
      metadata: ["", "// ", "\n\n"],
      wrapper: ["", "\n"],
      opts: { padding: "", prefix: "$" },
    },
    dict,
  );
}
#+END_SRC

#+BEGIN_SRC js
export function output_less(dict) {
  return cssFormatStructure(
    {
      doc: ["\n/*", " */\n"],
      metadata: ["", "// ", "\n\n"],
      wrapper: ["", "\n"],
      opts: { padding: "", prefix: "@" },
    },
    dict,
  );
}
#+END_SRC

#+BEGIN_SRC js
export function output_styl(dict) {
  return cssFormatStructure(
    {
      doc: ["\n/*!", " */\n"],
      metadata: ["", "// ", "\n\n"],
      wrapper: ["", "\n"],
      opts: { padding: "", prefix: "", assignment: " = ", suffix: "" },
    },
    dict,
  );
}
#+END_SRC

** Data Exports

#+BEGIN_SRC js
export function output_raw(dict) {
  const { project, ...tokens } = dict;
  const { bump = "manual" } = project || MissingProjectMetadataError();

  // Check if bump matches an automation keyword
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );

  // Then bump the version
  autobump && bumpVersion(project);

  return JSON.stringify({ project, tokens }, null, 2);
}
#+END_SRC

#+BEGIN_SRC js
export function output_yaml(dict) {
  const { project, ...tokens } = dict;
  const { bump = "manual" } = project || MissingProjectMetadataError();

  // Check if bump matches an automation keyword
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );

  // Then bump the version
  autobump && bumpVersion(project);

  const assemble = (level, tree) =>
    Object.entries(tree).reduce((str, [key, data]) => {
      if (typeof data === "string") return yamlDictValue(level, str, key, data);
      if (Array.isArray(data)) return yamlDictScale(level, str, key, data);
      if (key === "base") return yamlDictSubcategory(level, data);
      return str.concat(
        "".padStart(level),
        key,
        ":\n",
        assemble(level + 2, data),
      );
    }, "");

  return `
# ${timestampEmitter()}
${
    Object.entries({ project, tokens })
      .reduce((str, [key, data]) => {
        if (typeof data === "string") return yamlDictValue(0, str, key, data);
        if (Array.isArray(data)) return yamlDictScale(0, str, key, data);
        if (key === "base") return yamlDictSubcategory(0, data);
        return str.concat("\n", key, ":\n", assemble(2, data));
      }, "")
      .trimEnd()
  }
`;
}
#+END_SRC

** Desktop Support

*** GIMP/Inkscape

#+BEGIN_SRC js
export function output_gpl(dict) {
  const {
    project,
    color: { metadata, ...palette },
  } = dict;
  let {
    name,
    author,
    version,
    license,
    bump = "manual",
    metadata: { description = "N/A", comments = "N/A" } = {},
  } = project || MissingProjectMetadataError();

  // Check if bump matches an automation keyword
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );
  // Then bump the version
  autobump && bumpVersion(project);

  const assemble = (head, node) =>
    Object.entries(node).reduce((str, [key, value]) => {
      const KEY = key.toUpperCase();

      if (typeof value === "object") {
        return str.concat(
          assemble(tokenStringIdentifier(head, KEY, " "), value),
        );
      }

      return str.concat(
        GIMPPaletteSwatch(value),
        "\t",
        tokenStringIdentifier(head, KEY, " "),
        ` (${color_to_hex(value)})`,
        "\n",
      );
    }, "");

  return `
GIMP Palette
Name: ${name} (v${version})
# Generator: Quarks System Core
# Owned by ${author}
# License: ${license}
${
    metadataEmitter(
      { commentDelim: ["#", "# ", "\n#"] },
      {
        description,
        comments,
      },
    )
  }
# ${timestampEmitter()}

Columns: 6
${assemble("", palette)}
`.trimStart();
}

function GIMPPaletteSwatch(color) {
  return utility_pipe(
    color,
    color_to_rgb,
    extractor,
    ([, components]) =>
      components
        .map((C) => C.padStart(3, " "))
        .slice(0, 3)
        .join("\t"),
  );
}
#+END_SRC

*** Sketch

#+BEGIN_SRC js
export function output_sketchpalette(dict) {
  const {
    project,
    color: { metadata, ...palette },
  } = dict;

  let {
    name,
    author,
    version,
    license,
    bump = "manual",
    metadata: { description = "N/A", comments = "N/A" } = {},
  } = project || MissingProjectMetadataError();

  const assemble = (tree) =>
    Object.values(tree)
      .map((data) => {
        if (Array.isArray(data)) {
          return data.map((color) => sketchSwatch(color)).flat();
        }

        if (typeof data === "object") {
          return assemble(data);
        }

        return sketchSwatch(data);
      })
      .flat();

  return JSON.stringify({
    colors: assemble(palette),
    pluginVersion: "1.4",
    compatibleVersion: "1.4",
  });
}

function sketchSwatch(color) {
  return utility_pipe(
    color,
    color_to_rgb,
    parser,
    ([, [red, green, blue, alpha]]) => ({
      red,
      green,
      blue,
      alpha,
    }),
  );
}
#+END_SRC

** Interop/Integration

#+BEGIN_SRC js
export function output_tailwindcss(dict) {
  const { project, ...tokens } = dict;

  const assemble = (node) =>
    Object.entries(node).reduce((acc, [key, data]) => {
      if (key === "base") return { ...acc, DEFAULT: data };

      // Skip past any metadata
      if (key === "metadata") return { ...acc };

      if (typeof data === "object") {
        return { ...acc, [key]: assemble(data) };
      }

      return { ...acc, [key]: data };
    }, {});

  return (project && assemble(tokens)) || MissingProjectMetadataError();
}

export function output_style_dictionary(dict) {
  const { project, ...tokens } = dict;

  const assemble = (node) =>
    Object.entries(node).reduce((acc, [key, data]) => {
      if (key === "metadata") return { ...acc };

      if (typeof data === "object") {
        return { ...acc, [key]: assemble(data) };
      }

      return { ...acc, [key]: { value: String(data) } };
    }, {});

  return (project && assemble(tokens)) || MissingProjectMetadataError();
}
#+END_SRC

* Bootstrapper
:PROPERTIES:
:header-args:js: :tangle "./bootstrapper.js" :comments link
:END:

#+BEGIN_SRC js
import {
  AnimationCubicBezier,
  AnimationDuration,
  FigureCalculations,
  GridDimensions,
  GridFractions,
  MaterialPalette,
  TextLeading,
  TextMeasure,
  TextSize,
  TextStack,
  TextStyle,
  TextUnits,
  Viewport,
} from "./formulas.js";
import { ms_create } from "./utilities.js";
#+END_SRC

** Quarks System Standard

#+BEGIN_SRC js
export function Quarks({
  color = "gray",
  scale: { initial = 1, ratio = 1.5, limit = 6 } = {},
  tokens: {
    color: { formula = MaterialPalette, modifiers = {} } = {},
    text: {
      family: {
        body: BODY_FAMILY = null,
        headings: HEADING_FAMILY = null,
        code: CODE_FAMILY = null,
      } = {},
      fallback: {
        body: BODY_FALLBACK = "sans",
        headings: HEADING_FALLBACK = "serif",
        code: CODE_FALLBACK = "monospace",
      } = {},
      weights: {
        body: BODY_WEIGHTS = [400, 700],
        headings: HEADING_WEIGHTS = [700],
        code: CODE_WEIGHTS = BODY_WEIGHTS,
      } = {},
      measure: { min = 45, max = 75 } = {},
      leading: { normal = 1.5, tight = 1.125 } = {},
      values: TEXT_VALUES = limit,
    } = {},
    grid: { columns: GRID_COLUMNS = limit, ratio: GRID_RATIO = ratio } = {},
    viewport: {
      threshold = 5,
      full = 100,
      context = ["w", "h"],
      values: VIEWPORT_VALUES = limit,
    } = {},
    animation: {
      duration: { fastest = 250, slowest = 1000 } = {},
      easing: { floor = 0, ceiling = 1 } = {},
      values: ANIMATION_VALUES = limit,
    } = {},
  } = {},
} = {}) {
  const SCALE = ms_create({ ratio, values: limit }, initial);
  const [TEXT, GRID, VIEWPORT, ANIMATION] = [
    TEXT_VALUES,
    GRID_COLUMNS,
    VIEWPORT_VALUES,
    ANIMATION_VALUES,
  ].map((values) => ms_create({ ratio, values }, initial));

  const GRID_ROWS = Math.round(GRID_COLUMNS / GRID_RATIO);

  return {
    color: formula(modifiers, color),
    text: {
      family: {
        body: TextStack(BODY_FALLBACK, BODY_FAMILY),
        headings: TextStack(HEADING_FALLBACK, HEADING_FAMILY),
        code: TextStack(CODE_FALLBACK, CODE_FAMILY),
      },
      weight: {
        body: TextStyle(BODY_WEIGHTS),
        headings: TextStyle(HEADING_WEIGHTS),
        code: TextStyle(CODE_WEIGHTS),
      },
      size: TextSize(TEXT),
      measure: TextMeasure({ min, max }, TEXT),
      leading: TextLeading({ normal, tight }, TEXT),
      unit: TextUnits(TEXT),
    },
    grid: {
      columns: GRID_COLUMNS,
      rows: GRID_ROWS,
      fr: GridFractions(GRID),
      ...GridDimensions(GRID_COLUMNS, GRID_ROWS),
    },
    viewport: Viewport({ threshold, full, context }, VIEWPORT),
    animation: {
      duration: AnimationDuration({ fastest, slowest }, ANIMATION),
      easing: AnimationCubicBezier({ floor, ceiling }, ANIMATION),
    },
    ms: FigureCalculations(SCALE),
  };
}
#+END_SRC

* Formulas
:PROPERTIES:
:header-args:js: :tangle "./formulas.js" :comments link
:END:

#+BEGIN_SRC js
import { precision } from "./lib/utilities/color/index.js";
import {
  BidirectionalScale,
  NumericColorScale,
  RangedScale,
  UnidirectionalScale,
} from "./configurations.js";
import {
  color_blend,
  color_interpolation,
  color_material,
  color_shades,
  color_tints,
  color_to_hex,
  color_tones,
  ms_create,
  ms_modify,
  ms_units,
  output_systemfonts,
  utility_curry,
  utility_pipe,
} from "./utilities.js";
#+END_SRC

** Palette Formulas

#+BEGIN_SRC js
export function MaterialPalette(
  { light = 95, dark = 75, scheme = undefined, format = undefined },
  color,
) {
  return utility_pipe(
    color,
    utility_curry(paletteSettings)({ format, scheme }),
    utility_curry(generateMaterialPalette)({ light, dark }),
  );
}

function paletteSettings({ scheme, format }, color) {
  return utility_pipe(
    color,
    (color) => (format ? format(color) : color_to_hex(color)),
    (color) => (scheme ? scheme(color) : [color]),
  );
}

function generateMaterialPalette({ light, dark }, palette) {
  return utility_pipe(
    palette,
    (palette) => palette.map((color) => color_material({ light, dark }, color)),
    (palette) =>
      palette.reduce((acc, value, index) => {
        return {
          ...acc,
          [alphabeticalCategories(index)]: {
            ...value.reduce(
              (a, v, i) => ({
                ...a,
                ...(i === 0 ? { 50: v } : { [`${i}`.padEnd(3, "0")]: v }),
              }),
              {},
            ),
          },
        };
      }, {}),
  );
}

export function StandardPalette(
  {
    format = undefined,
    scheme = undefined,
    contrast = 95,
    tints = 3,
    tones = 3,
    shades = 3,
  },
  color,
) {
  return utility_pipe(
    color,
    utility_curry(paletteSettings)({ format, scheme }),
    utility_curry(structurePalette)({
      contrast,
      values: { tints, tones, shades },
    }),
  );
}

export function InterpolatedPalette(
  {
    lightness = 0,
    chroma = 0,
    hue = 0,
    values = 1,
    contrast = 95,
    tints = 3,
    tones = 3,
    shades = 3,
    format = undefined,
  },
  color,
) {
  return utility_pipe(
    format ? format(color) : color_to_hex(color),
    (color) => [
      color,
      ...(values === 1 ? [] : color_interpolation(
        { lightness, chroma, hue, values: values - 1 },
        color,
      )),
    ],
    utility_curry(structurePalette)({
      contrast,
      values: { tints, tones, shades },
    }),
  );
}

export function BlendedPalette(
  {
    values = 1,
    amount = 50,
    target = "black",
    contrast = 95,
    tints = 3,
    tones = 3,
    shades = 3,
    format = undefined,
  },
  color,
) {
  return utility_pipe(
    format ? format(color) : color_to_hex(color),
    (color) => [
      color,
      ...(values === 1
        ? []
        : color_blend({ target, amount, values: values - 1 }, color)),
    ],
    utility_curry(structurePalette)({
      contrast,
      values: { tints, tones, shades },
    }),
  );
}

function structurePalette({ contrast, values }, palette) {
  return utility_pipe(
    palette,
    (palette) =>
      palette.map((color, index) => {
        const category = alphabeticalCategories(index);
        const light = color_tints(
          {
            values: values.tints,
            amount: contrast,
          },
          color,
        );
        const muted = color_tones(
          {
            values: values.tones,
            amount: contrast / 1.27,
          },
          color,
        );
        const dark = color_shades(
          { values: values.shades, amount: contrast / 1.27 },
          color,
        );

        return [category, [color, light, muted, dark]];
      }),
    (palette) =>
      palette.reduce((acc, [key, [base, light, muted, dark]]) => {
        const variants = {
          ...(light.length ? { light: NumericColorScale(light) } : {}),
          ...(muted.length ? { muted: NumericColorScale(muted) } : {}),
          ...(dark.length ? { dark: NumericColorScale(dark) } : {}),
        };
        return {
          ...acc,
          [key]: {
            base,
            ...variants,
          },
        };
      }, {}),
  );
}

function alphabeticalCategories(index) {
  return new Map([
    ...Array(26)
      .fill(65)
      .map((v, i) => {
        const category = String.fromCharCode(v + i).toLowerCase(); // starting from "a"
        return [i, category];
      }),
  ]).get(index);
}
#+END_SRC

** Typography Formulas

#+BEGIN_SRC js
export function TextStack(fallback, font = null) {
  return font === null
    ? "".concat(output_systemfonts([fallback]))
    : [font, ...output_systemfonts([fallback])].join(", ");
}

export function TextStyle(weights) {
  return weights.reduce((acc, weight) => {
    const key = fontWeights(weight);

    return { ...acc, [key]: weight };
  }, {});
}

function fontWeights(weight) {
  return new Map([
    [100, "thin"],
    [200, "extralight"],
    [300, "light"],
    [400, "regular"],
    [500, "medium"],
    [600, "semibold"],
    [700, "bold"],
    [800, "extrabold"],
    [900, "black"],
  ]).get(weight);
}

export function TextSize(scale) {
  return Content(["rem", "em"], scale);
}

function Content([unit, inversionUnit], scale) {
  const [base] = Array.from(scale);
  const values = Array.from(scale);

  return {
    base: utility_pipe([base], utility_curry(ms_units)(unit)).toString(),
    ...BidirectionalScale(
      ["x", "d"],
      [
        ms_units(unit, values),
        utility_pipe(
          values,
          utility_curry(ms_modify)((n) => base / n),
          utility_curry(ms_units)(inversionUnit ? inversionUnit : unit),
        ),
      ],
    ),
  };
}

export function TextLeading({ normal = 1.5, tight = 1.25 }, scale) {
  const [base, ratio] = Array.from(scale);

  return Object.entries(
    ContentRange(
      {
        min: tight,
        max: normal,
        unit: "",
        keys: ["narrow", "tight"],
        calc: (n) => tight + (normal - tight) / (base * ratio ** n),
      },
      scale,
    ),
  ).reduce((acc, [key, value]) => {
    if (Array.isArray(value)) {
      return { ...acc, [key]: value.map((n) => parseFloat(n)) };
    }
    return { ...acc, [key]: parseFloat(value) };
  }, {});
}

export function TextMeasure({ min = 45, max = 75 }, scale) {
  const [base, ratio] = Array.from(scale);
  return ContentRange(
    {
      min,
      max,
      unit: "ch",
      keys: ["segment", "minimum"],
      calc: (n) => Math.trunc(min + (max - min) / (base * ratio ** n)),
    },
    scale,
  );
}

export function TextUnits(scale) {
  return Content(["ex"], scale);
}

function ContentRange({ min, max, unit, keys, calc }, scale) {
  const output = utility_curry(ms_units)(unit);

  return RangedScale(keys, [
    output([max]).toString(),
    utility_pipe(
      new Set(ms_modify(calc, scale)),
      (scale) => Array.from(scale),
      (scale) => scale.filter((n) => n > min && n < max),
      output,
    ),
    output([min]).toString(),
  ]);
}
#+END_SRC

** Layout Formulas

#+BEGIN_SRC js
export function GridFractions(scale) {
  return Content(["fr"], scale);
}

export function GridDimensions(columns, rows = columns) {
  const xs = spanCalculation(columns);
  const ys = spanCalculation(rows);

  return {
    x: xs[0],
    ...UnidirectionalScale("x", xs),
    y: xs[0],
    ...UnidirectionalScale("y", ys),
  };
}

function spanCalculation(xs) {
  return Array(xs)
    .fill(1)
    .map((x, pos) => x + pos);
}

export function FigureCalculations(scale) {
  const [base] = Array.from(scale);
  const values = Array.from(scale);

  return {
    base,
    ...UnidirectionalScale(
      "x",
      values.map((n) => precision(n)),
    ),
  };
}

export function Viewport(
  { threshold = 5, full = 100, context = ["w", "h", "min", "max"] },
  scale,
) {
  const [base, ratio] = Array.from(scale);

  return context.reduce((acc, target) => {
    const [key, unit] = viewportTargets(target);

    return {
      ...acc,
      [key]: ContentRange(
        {
          min: threshold,
          max: full,
          keys: ["segment", "threshold"],
          unit,
          calc: (n) =>
            Math.trunc(threshold + (full - threshold) / (base * ratio ** n)),
        },
        scale,
      ),
    };
  }, {});
}

function viewportTargets(target) {
  return new Map([
    ["width", ["width", "vw"]],
    ["w", ["width", "vw"]],
    ["height", ["height", "vh"]],
    ["h", ["height", "vh"]],
    ["minimum", ["min", "vmin"]],
    ["min", ["min", "vmin"]],
    ["maximum", ["max", "vmax"]],
    ["max", ["max", "vmax"]],
  ]).get(target);
}
#+END_SRC

** Animation Formulas

#+BEGIN_SRC js
export function AnimationDuration({ fastest = 250, slowest = 1000 }, scale) {
  const [base, ratio] = Array.from(scale);
  return ContentRange(
    {
      min: fastest,
      max: slowest,
      unit: "ms",
      keys: ["interval", "fastest"],
      calc: (n) => fastest + (slowest - fastest) / (base * ratio ** n),
    },
    scale,
  );
}

export function AnimationCubicBezier({ floor = 0, ceiling = 1 }, scale) {
  const [base, ratio] = Array.from(scale);
  const [maximum] = scale.slice(-1);

  const ABSCISSAS = new Set(
    ms_modify((n) => precision(n / maximum), scale).filter(
      (n) => n > 0 && n < 1,
    ),
  );

  const ORDINATES = new Set(
    ms_modify(
      (n) => precision(floor + (ceiling - floor) / (base * ratio ** n)),
      scale,
    ).filter((n) => n > floor && n < ceiling),
  );

  return {
    x: Array.from([0, ...ABSCISSAS, 1]),
    y: Array.from([floor, ...Array.from(ORDINATES).reverse(), ceiling]),
  };
}
#+END_SRC

* Configurations
:PROPERTIES:
:header-args:js: :tangle "./configurations.js" :comments link
:END:

** Numeric Color Scale

#+BEGIN_SRC js
export function NumericColorScale(data) {
  return data.reduce(
    (acc, value, index) => ({ ...acc, [`${++index}`.padEnd(3, "0")]: value }),
    {},
  );
}
#+END_SRC

** Modular Scale Types

#+BEGIN_SRC js
export function BidirectionalScale(keys, data) {
  const [x, d] = keys;
  const [multiply, divide] = Array.from(data);
  return {
    ...VariantScale(x, multiply),
    ...VariantScale(d, divide),
  };
}

export function UnidirectionalScale(key, data) {
  return VariantScale(key, data);
}

export function RangedScale(
  [rangeKey, floorKey] = ["fragment", "min"],
  [base, range, min],
) {
  return {
    base,
    [rangeKey]: range,
    [floorKey]: min,
  };
}

function VariantScale(key, [, ...values]) {
  return values.reduce(
    (acc, value, index) => ({
      ...acc,
      [[key, index + 2].join("")]: value,
    }),
    {},
  );
}
#+END_SRC

* Utilities
:PROPERTIES:
:header-args:js: :tangle "./utilities.js" :comments link
:END:

#+BEGIN_SRC js
import { compose, curry, pipe } from "./lib/utilities/fp.js";
import {
  convert,
  extractor,
  hueCorrection,
  normalize,
  numberFromPercent,
  numberToPercent,
  output,
  parser,
  passthrough,
  precision,
  radToDegrees,
  rgbToLrgb,
  validator,
} from "./lib/utilities/color/index.js";
import { QSCError } from "./lib/error.js";
import { A11Y_PALETTE, SYSTEM_FONT_STACKS } from "./lib/data.js";
#+END_SRC

** Functional Programming

#+BEGIN_SRC js
export {
  compose as utility_compose,
  curry as utility_curry,
  pipe as utility_pipe,
} from "./lib/utilities/fp.js";
#+END_SRC

** Color

*** Color Conversion

#+BEGIN_SRC js
export function color_to_hex(color) {
  return compose(curry(convert)("hex"), passthrough)(color);
}

export function color_to_rgb(color) {
  return compose(curry(convert)("rgb"), passthrough)(color);
}

export function color_to_hsl(color) {
  return compose(curry(convert)("hsl"), passthrough)(color);
}

export function color_to_cmyk(color) {
  return compose(curry(convert)("cmyk"), passthrough)(color);
}

export function color_to_hwb(color) {
  return compose(curry(convert)("hwb"), passthrough)(color);
}

export function color_to_cielab(color) {
  return compose(curry(convert)("cielab"), passthrough)(color);
}

export function color_to_cielch(color) {
  return compose(curry(convert)("cielch"), passthrough)(color);
}

export function color_to_oklab(color) {
  return compose(curry(convert)("oklab"), passthrough)(color);
}
#+END_SRC

*** Color Format Comparison

#+BEGIN_SRC js
export function color_format_compare(formats, color) {
  return formats.reduce(
    (acc, format) => ({
      ...acc,
      original: color,
      [format.name.split("_")[2]]: format(color),
    }),
    {},
  );
}
#+END_SRC

*** Color Property Adjustment

#+BEGIN_SRC js
export function color_adjust(
  { lightness = 0, chroma = 0, hue = 0, alpha = 0 },
  color,
) {
  return pipe(
    color_to_oklab(color),
    extractor,
    ([, [L, C, H, A]]) => [
      normalize(200, 0, parseFloat(L) + lightness),
      normalize(1, 0, parseFloat(C) + numberFromPercent(chroma)),
      hueCorrection(parseFloat(H) + hue),
      parseFloat(A ?? 1) + numberFromPercent(alpha),
    ],
    ([L, C, H, A]) => output(["oklab", [String(L).concat("%"), C, H, A]]),
    curry(revert)(color),
  );
}

function revert(color, output) {
  return pipe(
    output,
    validator,
    ([, output]) => [output, color],
    ([output, color]) =>
      pipe(
        color,
        validator,
        ([format]) =>
          format === "named"
            ? color_to_hex(output)
            : convert(format, output)[1],
      ),
    (output) => validator(output)[1],
  );
}
#+END_SRC

*** Color Mixture

#+BEGIN_SRC js
export function color_mix({ amount = 50, target = "black" }, color) {
  return pipe(
    calculateMix(color, target, numberFromPercent(amount)),
    ([L, a, b, A]) => [
      numberToPercent(L).toString().concat("%"),
      Math.sqrt(a ** 2 + b ** 2).toFixed(4),
      hueCorrection(radToDegrees(Math.atan2(b, a))),
      A,
    ],
    (components) => output(["oklab", components]),
    curry(revert)(color),
  );
}

function calculateMix(original, target, amount) {
  const [OL, Oa, Ob, OA] = pipe(
    original,
    color_to_oklab,
    parser,
    ([, components]) => components,
  );
  const [TL, Ta, Tb, TA] = pipe(
    target,
    color_to_oklab,
    parser,
    ([, components]) => components,
  );

  return [
    [OL, TL],
    [Oa, Ta],
    [Ob, Tb],
    [OA, TA],
  ].map(([X, Y]) => X + (Y - X) * amount);
}
#+END_SRC

** Color Scales (Palettes)

*** Interpolation

#+BEGIN_SRC js
export function color_interpolation(
  { lightness = 0, chroma = 0, hue = 0, alpha = 0, values = 10 },
  color,
) {
  const calculateProperty = (property, pos) =>
    property - (property / values) * pos;

  return [
    ...new Set(
      Array.from({ length: values }, (_, pos) =>
        color_adjust(
          {
            lightness: calculateProperty(lightness, pos),
            chroma: calculateProperty(chroma, pos),
            hue: calculateProperty(hue, pos),
            alpha: calculateProperty(alpha, pos),
          },
          color,
        )).reverse(),
    ),
  ];
}
#+END_SRC

*** Blending

#+BEGIN_SRC js
export function color_blend(
  { amount = 100, target = "black", values = 10 },
  color,
) {
  return [
    ...new Set(
      Array.from(
        { length: values },
        (_, pos) =>
          color_mix(
            { amount: amount - (amount / values) * pos, target },
            color,
          ),
      ).reverse(),
    ),
  ];
}
#+END_SRC

*** Material

#+BEGIN_SRC js
export function color_material({ light = 95, dark = 80 }, color) {
  return [
    ...color_tints({ amount: light, values: 5 }, color).reverse(),
    color_mix(
      {
        amount: dark,
        target: color_mix(
          { amount: light / 10 - dark / 10, target: "black" },
          color,
        ),
      },
      color,
    ),
    ...color_shades({ amount: dark, values: 4 }, color),
  ];
}
#+END_SRC

*** Color Schemes

#+BEGIN_SRC js
export function scheme_dyadic(color) {
  return generateUniformScheme({ count: 2, arc: 90 }, color);
}

export function scheme_complementary(color) {
  return generateUniformScheme({ count: 2, arc: 180 }, color);
}

export function scheme_analogous(color) {
  return generateUniformScheme({ count: 3, arc: 45 }, color);
}

export function scheme_split_complementary(color) {
  const [origin, complement] = Array.from(scheme_complementary(color));
  return [
    origin,
    color_adjust({ hue: -30 }, complement),
    color_adjust({ hue: 30 }, complement),
  ];
}

export function scheme_triadic(color) {
  return generateUniformScheme({ count: 3, arc: 120 }, color);
}

export function scheme_clash(color) {
  const [origin, right, , left] = Array.from(scheme_square(color));
  return [origin, right, left];
}

export function scheme_tetradic(color) {
  const [origin, opposite] = Array.from(scheme_complementary(color));
  return [
    origin,
    color_adjust({ hue: 45 }, origin),
    opposite,
    color_adjust({ hue: 45 }, opposite),
  ];
}

export function scheme_square(color) {
  return generateUniformScheme({ count: 4, arc: 90 }, color);
}

export function scheme_star(color) {
  return generateUniformScheme({ count: 5, arc: 72 }, color);
}

export function scheme_hexagon(color) {
  return generateUniformScheme({ count: 6, arc: 60 }, color);
}

function generateUniformScheme({ count, arc }, color) {
  return Array.from(
    { length: count },
    (_, pos) => color_adjust({ hue: arc * pos }, color),
  );
}
#+END_SRC

*** Variants

#+BEGIN_SRC js
export function color_tints({ amount = 95, values = 3 }, color) {
  return color_blend({ amount, values, target: "white" }, color);
}

export function color_tones({ amount = 90, values = 3 }, color) {
  return color_blend({ amount, values, target: "gray" }, color);
}

export function color_shades({ amount = 80, values = 3 }, color) {
  return color_blend({ amount, values, target: "black" }, color);
}
#+END_SRC

** Color Scale Adjustments

*** Palette Shifting

#+BEGIN_SRC js
export function palette_shift(
  { lightness = 0, chroma = 0, hue = 0, alpha = 0 },
  palette,
) {
  return Array.from(
    new Set(
      palette.map((color) =>
        color_adjust({ lightness, chroma, hue, alpha }, color)
      ),
    ),
  );
}
#+END_SRC

*** Palette Sorting

#+BEGIN_SRC js
export function palette_sort({ by, order = "asc" }, palette) {
  const [, color] = validator(palette[0]);
  return pipe(
    palette,
    paletteToOklabValues,
    curry(sortPalette)({ by, order }),
    curry(paletteFromOklab)(color),
  );
}

function paletteToOklabValues(palette) {
  return pipe(
    Array.from(palette),
    (palette) => palette.map((color) => color_to_oklab(color)),
    (palette) => palette.map((color) => extractor(color)),
    (palette) => palette.map(([, color]) => color),
    (palette) => palette.map((color) => color.map((C) => parseFloat(C))),
  );
}

function sortPalette({ by, order }, palette) {
  const evalCondition = (a, b) => (order === "desc" ? b - a : a - b);
  const sortingConditions = (property, order) =>
    new Map([
      ["lightness", ([A], [B]) => evalCondition(A, B)],
      ["chroma", ([, A], [, B]) => evalCondition(A, B)],
      ["hue", ([, , A], [, , B]) => evalCondition(A, B)],
      ["alpha", ([, , , A], [, , , B]) => evalCondition(A, B)],
    ]).get(property);

  return palette.sort(sortingConditions(by, order));
}

function paletteFromOklab(input, palette) {
  return pipe(
    palette,
    (palette) =>
      palette.map(([L, C, H, A]) =>
        output(["oklab", [L.toString().concat("%"), C, H, A ?? 1]])
      ),
    (palette) => new Set(palette.map((color) => revert(input, color))),
    Array.from,
  );
}
#+END_SRC

*** Palette Filtering

#+BEGIN_SRC js
export function palette_filter({ by, min, max }, palette) {
  const [, color] = validator(palette[0]);
  return pipe(
    palette,
    paletteToOklabValues,
    curry(flushPalette)({ by, min, max }),
    curry(paletteFromOklab)(color),
  );
}

function flushPalette({ by, min, max }, palette) {
  return palette.filter(parseFlushCondition({ by, min, max }));
}

function parseFlushCondition({ by, min, max }) {
  const filterCondition = (v) => (max ? v > min && v < max : v > min);
  const filterConditionAsNumber = (v) =>
    max
      ? v > numberFromPercent(min) && v < numberFromPercent(max)
      : v > numberFromPercent(min);
  const matchProperty = (property) =>
    new Map([
      ["lightness", ([V]) => filterCondition(V)],
      ["chroma", ([, V]) => filterConditionAsNumber(V)],
      ["hue", ([, , V]) => filterCondition(V)],
      ["alpha", ([, , , V]) => filterConditionAsNumber(V)],
    ]).get(property);

  return matchProperty(by);
}
#+END_SRC

** Color Accessibility (A11y)

*** Colors Project Web Defaults

#+BEGIN_SRC js
export function data_clrs(color) {
  return A11Y_PALETTE[color] || UndefinedInA11yPaletteError();
}

function UndefinedInA11yPaletteError() {
  throw new QSCError({
    name: "No Matching Keyword in A11y Palette",
    reason: `
This error throws when the input doesn't match any defined
colors in the Colors project.
`,
    suggestion: `
Valid colors in the Colors (https://clrs.cc) project:

+--------------------------------------+
| navy   | blue      | aqua   | teal   |
+--------------------------------------+
| olive  | green     | lime   | yellow |
+--------------------------------------+
| maroon | fuschia   | purple | black  |
+--------------------------------------+
| black  | gray/grey | silver | white  |
+--------------------------------------+
`,
  });
}
#+END_SRC

*** Color Contrast Ratio

#+BEGIN_SRC js
export function palette_contrast(
  { rating = "AA", enhanced = false, background = "white" },
  palette,
) {
  return palette.filter((foreground) => {
    const CONTRAST_RATIO = calculateWCAGContrastRatio(background, foreground);
    return contrastCriteria(CONTRAST_RATIO, enhanced).get(rating);
  });
}

function calculateWCAGContrastRatio(a, b) {
  return [a, b]
    .map((color) => calculateRelativeLuminance(color))
    .sort((a, b) => b - a)
    .map((L) => L + 0.05)
    .reduce((L1, L2) => precision(L1 / L2));
}

function contrastCriteria(ratio, enhanced) {
  return new Map([
    ["AA", enhanced ? ratio >= 4.5 : ratio >= 3.1],
    ["AAA", enhanced ? ratio >= 7 : ratio >= 4.5],
  ]);
}

function calculateRelativeLuminance(color) {
  return pipe(
    color,
    color_to_rgb,
    parser,
    ([, [R, G, B]]) => [R, G, B],
    rgbToLrgb,
    ([R, G, B]) => 0.2126 * R + 0.7152 * G + 0.0722 * B,
  );
}
#+END_SRC

** Typography

*** System Font Stacks

#+BEGIN_SRC js
export function data_systemfonts(family) {
  return SYSTEM_FONT_STACKS[family] || NotASystemFontFamilyError();
}

function NotASystemFontFamilyError() {
  throw new QSCError({
    name: "Not a System Font Stack",
    reason: `
The value entered is not a valid system font family.
`,
    suggestion: `
The available values matching system font families are:

sans
serif
monospace
`,
  });
}
#+END_SRC

** Modular Scales

*** Scale Creation

#+BEGIN_SRC js
export function ms_create({ values = 6, ratio = 1.5 }, base) {
  return Array.isArray(ratio)
    ? Array.from(
      new Set(
        Array(values)
          .fill(base)
          .reduce(
            (acc, base, index) => [
              ...acc,
              ...ratio.map((r) => base * r ** index),
            ],
            [],
          ),
      ),
    )
      .slice(0, values)
      .sort((a, b) => a - b)
    : Array(values)
      .fill(base)
      .map((base, index) => base * ratio ** index);
}
#+END_SRC

*** Scale Modification

#+BEGIN_SRC js
export function ms_modify(calc, ms) {
  return unlessMS(
    ms.map((n) => calc(n)),
    ms,
  );
}

export function ms_split(partitions, ms) {
  return unlessMS(
    Array.from(ms).reduceRight(
      (acc, _n, _index, array) => [...acc, array.splice(0, partitions)],
      [],
    ),
    ms,
  );
}

function unlessMS(body, data) {
  return Array.isArray(data) && data.every((n) => typeof n === "number")
    ? body
    : NotARawMSError(data);
}

function NotARawMSError() {
  throw new QSCError({
    name: "Input Must Be Raw Modular Scale",
    reason: `
You've called a modular scale function with something other than a modular
scale. So the function cannot work.
`,
    suggestion: `
Remember that scale modification functions only work on a scale of raw values.
Do all of your value transformations before you invoke ms_units().

Also, remember to create a raw scale with ms_create(). Such as the following:

ms_create({ values: 8, ratio: 1.618 }, 1);
`,
  });
}
#+END_SRC

*** Attaching Units

#+BEGIN_SRC js
export function ms_units(unit, ms) {
  return unlessMS(
    ms.map((n) => `${precision(n)}${unit}`, ms),
    ms,
  );
}
#+END_SRC

* Library
** Formatter Helpers
:PROPERTIES:
:header-args:js: :tangle "./lib/formatters/index.js" :comments link
:END:

#+BEGIN_SRC js
import { QSCError } from "../error.js";
#+END_SRC

*** CSS Format Structure

#+BEGIN_SRC js
export function cssFormatStructure(
  {
    doc: [DOC_OPEN, DOC_CLOSE] = ["\n/**", " **/\n"],
    metadata: [OPEN, DELIM, CLOSE] = ["\n  /**", "   * ", "\n   **/\n\n"],
    wrapper: [TOKENS_OPEN, TOKENS_CLOSE] = ["\n:root {", "\n}\n"],
    opts = { padding: "  " },
  } = {},
  { project, ...tokens },
) {
  let {
    name,
    author,
    version,
    license,
    bump = "manual",
    metadata: { description = "N/A", comments = "N/A" } = {},
  } = project || MissingProjectMetadataError(project);

  // Attach a dynamic property initializing the autorelease version
  const autobump = ["major", "minor", "patch", "pre", "build"].some(
    (keyword) => keyword === bump,
  );

  return "".concat(
    DOC_OPEN,
    `
 * Project: ${name} (v${autobump ? bumpVersion(project) : version})
 * Owned by: ${author}
 * License: ${license}
 * ${"=".repeat(64)}
${
      metadataEmitter(
        { commentDelim: [" *", " * ", ""] },
        {
          description,
          comments,
        },
      )
    }
 * ${"-".repeat(64)}
 * ${timestampEmitter()}
`,
    DOC_CLOSE,
    TOKENS_OPEN,
    tokenStringConstructor(
      { ...opts, commentDelim: [OPEN, DELIM, CLOSE] },
      tokens,
    ),
    TOKENS_CLOSE,
  );
}
#+END_SRC

*** Undefined Project Metadata Error

#+BEGIN_SRC js
export function MissingProjectMetadataError() {
  throw new QSCError({
    name: "Missing Project Metadata",
    reason: `
Formatters will not process a Quarks System Dictionary that's missing project
metadata. Its absence indicates that the current dictionary is still open
for modification.
`,
    suggestion: `
Be sure to include project metadata when you're ready to export your tokens.
Here's an example of the proper schema.

const finishedDict = {
  project: {
    name: "My Project",
    author: "Anonymous",
    version: "0.0.0",
    license: "Unlicense",
    // OPTIONAL can also be one of "major", "minor", "patch", "pre", "build" for automatic versioning
    bump: "manual",
    // OPTIONAL
    metadata: {
      description: "N/A",
      comments: "N/A"
    }
  },
  ...tokens
};

The first four properties are all required. Up to you if you want to include
a description or comments with your project.
`,
  });
}
#+END_SRC

*** Metadata Emitter

#+BEGIN_SRC js
export function metadataEmitter(
  {
    commentDelim: [OPEN, DELIM, CLOSE] = ["\n  /**", "   * ", "\n   **/\n\n"],
    str = "",
  },
  meta,
) {
  return str.concat(
    [
      OPEN,
      Object.entries(meta).reduce((str, [key, value]) => {
        const lines = value.split("\n");

        if (lines.length > 1) {
          return str
            .concat(
              "\n",
              DELIM,
              key.toUpperCase(),
              ":",
              "\n",
              DELIM.trimEnd(),
              lines.join(`\n${DELIM}`),
            )
            .trimEnd();
        }

        return str.concat("\n", DELIM, key.toUpperCase(), ": ", lines);
      }, ""),
      CLOSE,
    ].join(""),
  );
}
#+END_SRC

*** Token String Constructor

#+BEGIN_SRC js
function tokenStringConstructor(opts, dict) {
  return "".concat("\n", cssTokenEmitter(opts, "", dict));
}
#+END_SRC

*** CSS Token Emitter

#+BEGIN_SRC js
function cssTokenEmitter(opts, head, node) {
  function assemble(head, node) {
    const { metadata, ...tokens } = node;
    return "".concat(
      (metadata && metadataEmitter(opts, metadata)) || "", // prepend metadata if defined
      Object.entries(tokens).reduce((str, [key, value]) => {
        const format = cssTokenAssembler(opts);
        if (typeof value === "object") {
          return str.concat(
            assemble(tokenStringIdentifier(head, key, "-"), value),
          );
        }

        return format(str, tokenStringIdentifier(head, key, "-"), value, "\n");
      }, ""),
    );
  }

  return assemble(head, node);
}
#+END_SRC

*** CSS Token Assembler

#+BEGIN_SRC js
function cssTokenAssembler({
  padding = "",
  prefix = "--",
  assignment = ": ",
  suffix = ";",
  terminator = "\n",
}) {
  return function (str, key, value) {
    return str.concat(
      padding,
      prefix,
      key,
      assignment,
      value,
      suffix,
      terminator,
    );
  };
}
#+END_SRC

*** Token String Identifier

#+BEGIN_SRC js
export function tokenStringIdentifier(collected, current, delimiter) {
  return current === "base"
    ? collected
    : collected
    ? [collected, current].join(delimiter)
    : current;
}
#+END_SRC

*** Automatic Versioning

#+BEGIN_SRC js
export function bumpVersion(project) {
  let [major, minor, patch, pre] = Array.from(
    project.version.split(/[.-]/g),
  ).map((n) => parseFloat(n));

  function next(keyword) {
    const bumped = new Map([
      ["major", [major + 1, 0, 0]],
      ["minor", [major, minor + 1, 0]],
      ["patch", [major, minor, patch + 1]],
      ["pre", [major, minor, patch, pre + 1 || 0]],
      ["build", [major, minor, patch, pre, Date.now()]],
    ]).get(keyword);

    return bumped;
  }

  const releaseConditions = (release) =>
    Array.from(
      new Map([
        [release.length === 3, release.join(".")],
        [
          release.length === 4,
          [release.slice(0, 3).join("."), release[3]].join("-"),
        ],
        [
          release.length === 5,
          [
            release.slice(0, 3).join("."),
            [release[3] ?? 0, release[4]].join("+"),
          ].join("-"),
        ],
      ]),
    )
      .filter(([condition]) => condition)
      .flatMap(([, release]) => release)
      .toString();

  project["version"] = releaseConditions(next(project.bump));

  return project.version;
}
#+END_SRC

*** Timestamp Emitter

#+BEGIN_SRC js
export function timestampEmitter() {
  const TIMESTAMP = new Date(Date.now());
  return `Updated on ${TIMESTAMP.toLocaleDateString()} at ${TIMESTAMP.toLocaleTimeString()}`;
}
#+END_SRC

*** YAML Assemblers

#+BEGIN_SRC js
export function yamlDictSubcategory(level, data) {
  return Object.entries(data).reduce((str, [key, v]) => {
    if (Array.isArray(v)) return yamlDictScale(level, str, key, v);
    return yamlDictValue(level, str, key, v);
  }, "");
}

export function yamlDictValue(level, str, key, value) {
  const isMultiline = value.split("\n").length > 1;
  if (isMultiline) {
    return str.concat(
      "".padStart(level),
      `${key}: |\n`,
      value
        .split("\n")
        .reduce((s, line) => s.concat("".padStart(level + 2), line, "\n"), ""),
    );
  }
  return str.concat("".padStart(level), key, ": ", value, "\n");
}

export function yamlDictScale(level, str, key, value) {
  return str.concat(
    "".padStart(level),
    key,
    ":\n",
    value.reduce((s, v) => s.concat("".padStart(level + 2), "- ", v, "\n"), ""),
  );
}
#+END_SRC

** Utilities
*** Functional Programming
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/fp.js" :comments link
:END:

**** Currying

#+BEGIN_SRC js
export function curry(fn) {
  return (...initial) =>
    initial.length >= fn.length
      ? fn.apply(this, initial)
      : (...remaining) => fn.apply(this, initial.concat(remaining));
}
#+END_SRC

**** Composition

#+BEGIN_SRC js
export function compose(...fns) {
  return (x) => fns.reduce((g, f) => f(g), x);
}
#+END_SRC

**** Pipelining

#+BEGIN_SRC js
export function pipe(x, ...fns) {
  return compose(...fns)(x);
}
#+END_SRC

*** Color
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/index.js" :comments link
:END:

#+BEGIN_SRC js
export { convert, passthrough } from "./converter/index.js";
export { rgbToLrgb } from "./converter/color_from_rgb.js";
export * from "./converter/math.js";
export { validator } from "./validator/index.js";
export { extractor } from "./extractor/index.js";
export { output, parser } from "./parser/index.js";
#+END_SRC

**** Converter
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/index.js" :comments link
:END:

#+BEGIN_SRC js
import { compose, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import {
  cielabToRgb,
  cmykToRgb,
  hexToRgb,
  hslToRgb,
  hwbToRgb,
  oklabToRgb,
} from "./color_to_rgb.js";
import {
  cielabFromRgb,
  cmykFromRgb,
  hexFromRgb,
  hslFromRgb,
  hwbFromRgb,
  oklabFromRgb,
} from "./color_from_rgb.js";
import {
  cielabFromCielch,
  cielabToCielch,
  hexFromNamedColor,
} from "./linkers.js";
#+END_SRC

#+BEGIN_SRC js
const INPUT_TO_RGB = {
  named: compose(hexFromNamedColor, passthrough, hexToRgb),
  hex: hexToRgb,
  rgb: compose(hexFromRgb, passthrough, hexToRgb), // identity
  hsl: hslToRgb,
  cmyk: cmykToRgb,
  hwb: hwbToRgb,
  cielab: cielabToRgb,
  cielch: compose(cielabFromCielch, passthrough, cielabToRgb),
  oklab: oklabToRgb,
};

const OUTPUT_FROM_RGB = {
  hex: hexFromRgb,
  rgb: compose(hexFromRgb, passthrough, hexToRgb),
  hsl: hslFromRgb,
  cmyk: cmykFromRgb,
  hwb: hwbFromRgb,
  cielab: cielabFromRgb,
  cielch: compose(cielabFromRgb, passthrough, cielabToCielch),
  oklab: oklabFromRgb,
};

export function passthrough([, color]) {
  return color;
}

export function convert(output, color) {
  const [input, value] = validator(color);
  return pipe(
    validator(color),
    ([input, color]) => INPUT_TO_RGB[input](color),
    ([, color]) => OUTPUT_FROM_RGB[output](color),
  );
}
#+END_SRC

***** Color to RGB
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/color_to_rgb.js" :comments link
:END:

#+BEGIN_SRC js
import { curry, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { output, parser } from "../parser/index.js";
import { normalize, numberToRgb } from "./math.js";
#+END_SRC

****** Hex to RGB

#+BEGIN_SRC js
export function hexToRgb(color) {
  const [, components] = parser(color);
  return pipe(output(["rgb", components]), validator);
}
#+END_SRC

****** HSL to RGB

#+BEGIN_SRC js
export function hslToRgb(color) {
  const [, [H, S, L, A]] = parser(color);

  // Calculate chroma
  const C = (1 - Math.abs(2 * L - 1)) * S;
  const X = C * (1 - Math.abs(((H / 60) % 2) - 1));
  const m = L - C / 2;

  const [R, G, B] = Array.from(calculateRGB(C, X, H))
    .filter(([, condition]) => condition)
    .flatMap(([evaluation]) => evaluation)
    .map((V) => pipe(V + m, numberToRgb, Math.round, curry(normalize)(255, 0)));

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}

function calculateRGB(C, X, H) {
  return new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);
}
#+END_SRC

****** CMYK to RGB

#+BEGIN_SRC js
export function cmykToRgb(color) {
  const [, [C, M, Y, K, A]] = parser(color);

  const [R, G, B] = [C, M, Y].map((V) =>
    pipe((1 - V) * (1 - K), numberToRgb, Math.round, curry(normalize)(255, 0))
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}
#+END_SRC

****** HWB to RGB

#+BEGIN_SRC js
export function hwbToRgb(color) {
  const [, [H, W, BLK, A]] = parser(color);

  // Achromacity
  if (W + BLK >= 1) {
    const GRAY = pipe(
      W / (W + BLK),
      numberToRgb,
      Math.round,
      curry(normalize)(255, 0),
    );

    return pipe(output(["rgb", [Array(3).fill(GRAY), A]]), validator);
  }

  const [R, G, B] = pipe(
    `hsl(${H}, 100%, 50%)`,
    hslToRgb,
    ([, color]) => parser(color),
    ([, color]) => color,
  ).map((V) =>
    pipe(
      V * (1 - W - BLK) + W,
      numberToRgb,
      Math.round,
      curry(normalize)(255, 0),
    )
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}
#+END_SRC

****** CIELAB to RGB

#+BEGIN_SRC js
export function cielabToRgb(color) {
  const [, [L, a, b, A]] = parser(color);
  const [X, Y, Z] = cielabToCiexyz([L, a, b]);
  const [LR, LG, LB] = ciexyzToLrgb([X, Y, Z]);
  const [R, G, B] = lrgbToRgb([LR, LG, LB]).map((V) =>
    pipe(V, numberToRgb, Math.round, curry(normalize)(255, 0))
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}

function cielabToCiexyz([L, a, b]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const WHITE = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const FY = (L + 16) / 116;
  const FX = a / 500 + FY;
  const FZ = FY - b / 200;

  // Calculate xyz
  const [X, Y, Z] = [
    FX ** 3 > ε ? FX ** 3 : (116 * FX - 16) / κ,
    L > κ * ε ? FY ** 3 : L / κ,
    FZ ** 3 > ε ? FZ ** 3 : (116 * FZ - 16) / κ,
  ].map((V, i) => V * WHITE[i]);

  return [X, Y, Z];
}

const D65_CHROMATIC_ADAPTATION = [
  [0.9555766, -0.0230393, 0.0631636],
  [-0.0282895, 1.0099416, 0.0210077],
  [0.0122982, -0.020483, 1.3299098],
];

const LINEAR_RGB_TRANSFORMATION_MATRIX = [
  [3.2404542, -1.5371385, -0.4985314],
  [-0.969266, 1.8760108, 0.041556],
  [0.0556434, -0.2040259, 1.0572252],
];

function ciexyzToLrgb([X, Y, Z]) {
  const [CX, CY, CZ] = D65_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => X * V1 + Y * V2 + Z * V3,
  );

  const [LR, LG, LB] = LINEAR_RGB_TRANSFORMATION_MATRIX.map(
    ([V1, V2, V3]) => CX * V1 + CY * V2 + CZ * V3,
  );

  return [LR, LG, LB];
}

function lrgbToRgb([LR, LG, LB]) {
  return [LR, LG, LB].map((V) =>
    V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055
  );
}
#+END_SRC

****** Oklab to RGB

#+BEGIN_SRC js
export function oklabToRgb(color) {
  const [, [L, a, b, A]] = parser(color);
  const [LR, LG, LB] = oklabToLrgb([L, a, b]);

  const [R, G, B] = lrgbToRgb([LR, LG, LB]).map((V) =>
    pipe(V, numberToRgb, Math.round, curry(normalize)(255, 0))
  );

  return pipe(output(["rgb", [R, G, B, A]]), validator);
}

const LINEAR_LMS_CONE_ACTIVATIONS = [
  [0.3963377774, 0.2158037573],
  [0.1055613458, 0.0638541728],
  [0.0894841775, 1.291485548],
];

const LINEAR_RGB_OKLAB_MATRIX = [
  [4.076416621, 3.3077115913, 0.2309699292],
  [-1.2684380046, 2.6097574011, 0.3413193965],
  [-0.0041960863, 0.7034186147, 1.707614701],
];

function oklabToLrgb([L, a, b]) {
  const [LONG, M, S] = LINEAR_LMS_CONE_ACTIVATIONS.map(([V1, V2], pos) => {
    if (pos === 0) return L + a * V1 + b * V2;
    if (pos === 1) return L - a * V1 - b * V2;
    return L - a * V1 - b * V2;
  }).map((V) => V ** 3);

  const [LR, LG, LB] = LINEAR_RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return LONG * V1 - M * V2 + S * V3;
    if (pos === 1) return LONG * V1 + M * V2 - S * V3;
    return LONG * V1 - M * V2 + S * V3;
  });

  return [LR, LG, LB];
}
#+END_SRC

***** Color from RGB
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/color_from_rgb.js" :comments link
:END:

#+BEGIN_SRC js
import { curry, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { output, parser } from "../parser/index.js";
import {
  hexFragmentFromRgb,
  hueCorrection,
  normalize,
  numberToPercent,
  numberToRgb,
  precision,
  radToDegrees,
} from "./math.js";
#+END_SRC

****** Hex from RGB

#+BEGIN_SRC js
export function hexFromRgb(color) {
  const [, components] = parser(color);
  return pipe(
    output([
      "hex",
      components.map((V) =>
        pipe(
          V,
          numberToRgb,
          Math.round,
          curry(normalize)(255, 0),
          hexFragmentFromRgb,
        )
      ),
    ]),
    validator,
  );
}
#+END_SRC

****** HSL from RGB

#+BEGIN_SRC js
export function hslFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);

  const MIN = Math.min(R, G, B);
  const MAX = Math.max(R, G, B);
  const DELTA = MAX - MIN;

  const L = calculateLightness(MIN, MAX);
  const [[H], S] = [
    Array.from(calculateHue(R, G, B, MAX, DELTA))
      .filter(([, condition]) => condition)
      .flatMap(([result]) => result),
    calculateSaturation(DELTA, L),
  ];

  const limitPercent = curry(normalize)(100, 0);

  return pipe(
    output([
      "hsl",
      [
        hueCorrection(H),
        ...[S, L].map((V) =>
          pipe(V, numberToPercent, limitPercent, (value) => value.toString())
            .concat("%")
        ),
        A,
      ],
    ]),
    validator,
  );
}

function calculateLightness(cmin, cmax) {
  return (cmax + cmin) / 2;
}

function calculateHue(R, G, B, cmax, delta) {
  return new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);
}

function calculateSaturation(delta, L) {
  return delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));
}
#+END_SRC

****** CMYK from RGB

#+BEGIN_SRC js
export function cmykFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);

  const K = 1 - Math.max(R, G, B);
  const [C, M, Y] = [R, G, B].map((V) => (1 - V - K) / (1 - K));

  const limitPercent = curry(normalize)(100, 0);

  return pipe(
    output([
      "cmyk",
      [
        ...[C, M, Y, K]
          .map((V) => (isNaN(V) ? 0 : pipe(V, numberToPercent, limitPercent)))
          .map((V) => V.toString().concat("%")),
        A,
      ],
    ]),
    validator,
  );
}
#+END_SRC

****** HWB from RGB

#+BEGIN_SRC js
export function hwbFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);

  const MAX = Math.max(R, G, B);
  const MIN = Math.min(R, G, B);
  const DELTA = MAX - MIN;

  const [H] = Array.from(calculateHue(R, G, B, MAX, DELTA))
    .filter(([, condition]) => condition)
    .flatMap(([result]) => result);

  const [W, BLK] = [MIN, 1 - MAX];

  const limitPercent = curry(normalize)(100, 0);

  return pipe(
    output([
      "hwb",
      [
        hueCorrection(H),
        ...[W, BLK].map((V) =>
          pipe(V, numberToPercent, limitPercent).toString().concat("%")
        ),
        A,
      ],
    ]),
    validator,
  );
}
#+END_SRC

****** CIELAB from RGB

#+BEGIN_SRC js
export function cielabFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);
  const [X, Y, Z] = rgbToCieXYZ([R, G, B]);
  const [L, a, b] = ciexyzToCielab([X, Y, Z]);

  return pipe(
    output(["cielab", [precision(L).toString().concat("%"), a, b, A]]),
    validator,
  );
}

function ciexyzToCielab([X, Y, Z]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const D50_WHITE = [0.96422, 1.0, 0.82521];

  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z]
    .map((V, i) => V / D50_WHITE[i])
    .map((V) => (V > ε ? Math.cbrt(V) : (κ * V + 16) / 116));

  const [L, a, b] = [116 * FY - 16, 500 * (FX - FY), 200 * (FY - FZ)]
    .map((V) => precision(V))
    .map((V, pos) =>
      pos === 0 ? normalize(256, 0, V) : +normalize(128, -127, V).toFixed(4)
    );

  return [L, a, b];
}

const D65_REFERENCE_WHITE = [
  [0.4124564, 0.3575761, 0.1804375],
  [0.2126729, 0.7151522, 0.072175],
  [0.0193339, 0.119192, 0.9503041],
];

const D50_CHROMATIC_ADAPTATION = [
  [1.0478112, 0.0228866, -0.050127],
  [0.0295424, 0.9904844, -0.0170491],
  [-0.0092345, 0.0150436, 0.7521316],
];

function rgbToCieXYZ([R, G, B]) {
  const [LR, LG, LB] = rgbToLrgb([R, G, B]);

  const [x, y, z] = D65_REFERENCE_WHITE.map(
    ([V1, V2, V3]) => LR * V1 + LG * V2 + LB * V3,
  );

  const [X, Y, Z] = D50_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => x * V1 + y * V2 + z * V3,
  );

  return [X, Y, Z];
}

export function rgbToLrgb([R, G, B]) {
  return [R, G, B].map((V) =>
    V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4
  );
}
#+END_SRC

****** Oklab from RGB

#+BEGIN_SRC js
export function oklabFromRgb(color) {
  const [, [R, G, B, A]] = parser(color);
  const [l, a, b] = lrgbToOklab([R, G, B]);

  const L = precision(numberToPercent(l)).toString().concat("%");
  const c = normalize(0.5, 0, +Math.sqrt(a ** 2 + b ** 2).toFixed(4)); // toPrecision isn't strict enough
  const C = Math.sign(Math.round(c)) === -1 ? 0 : c;
  const H = pipe(Math.atan2(b, a), radToDegrees, hueCorrection);

  return pipe(output(["oklab", [L, C, H, A]]), validator);
}

const NONLINEAR_LMS_CONE_ACTIVATIONS = [
  [0.4122214708, 0.5363325363, 0.0514459929],
  [0.2119034982, 0.6806995451, 0.1073969566],
  [0.0883024619, 0.2817188376, 0.6299787005],
];

const RGB_OKLAB_MATRIX = [
  [0.2104542553, 0.793617785, 0.0040720468],
  [1.9779984951, 2.428592205, 0.4505937099],
  [0.0259040371, 0.7827717662, 0.808675766],
];

function lrgbToOklab([R, G, B]) {
  const [LR, LG, LB] = rgbToLrgb([R, G, B]);

  const [L, M, S] = NONLINEAR_LMS_CONE_ACTIVATIONS.map(
    ([L, M, S]) => L * LR + M * LG + S * LB,
  ).map((V) => Math.cbrt(V));

  return RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return V1 * L + V2 * M - V3 * S;
    if (pos === 1) return V1 * L - V2 * M + V3 * S;
    return V1 * L + V2 * M - V3 * S;
  });
}
#+END_SRC

***** Linkers
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/linkers.js" :comments link
:END:

#+BEGIN_SRC js
import { NAMED_COLOR_KEYWORDS } from "../../../data.js";
import { pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { output, parser } from "../parser/index.js";
import {
  hueCorrection,
  normalize,
  radFromDegrees,
  radToDegrees,
} from "./math.js";
#+END_SRC

****** Named Color to Hex

#+BEGIN_SRC js
export function hexFromNamedColor(color) {
  return validator(NAMED_COLOR_KEYWORDS[color]);
}
#+END_SRC

****** CIELAB to CIELCh(ab)

#+BEGIN_SRC js
export function cielabToCielch(color) {
  const [, [L, a, b, A]] = parser(color);

  const C = normalize(132, 0, Math.sqrt(a ** 2 + b ** 2));
  const H = pipe(Math.atan2(b, a), radToDegrees, hueCorrection);

  return pipe(
    output(["cielch", [L.toString().concat("%"), C, H, A]]),
    validator,
  );
}
#+END_SRC

****** CIELCh(ab) to CIELAB

#+BEGIN_SRC js
export function cielabFromCielch(color) {
  const [, [L, C, H, A]] = parser(color);

  const [a, b] = [
    C * Math.cos(radFromDegrees(H)),
    C * Math.sin(radFromDegrees(H)),
  ].map((V) => normalize(128, -127, V));

  return pipe(
    output(["cielab", [L.toString().concat("%"), a, b, A]]),
    validator,
  );
}
#+END_SRC

***** Math
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/converter/math.js" :comments link
:END:

#+BEGIN_SRC js
import { compose } from "../../fp.js";
#+END_SRC

****** Arithmetic

#+BEGIN_SRC js
const add = (y, x) => x + y;
const multiply = (y, x) => x * y;
const divide = (y, x) => x / y;
const remainder = (y, x) => x % y;
#+END_SRC

****** Limiters

#+BEGIN_SRC js
export const precision = (value) => +value.toPrecision(5);
export const normalize = (b, a, x) => (x < a ? a : x > b ? b : precision(x));
#+END_SRC

****** Hexadecimal

#+BEGIN_SRC js
export const hexFragmentToRgb = (fragment) => parseInt(fragment, 16);
export const hexFragmentFromRgb = (channel) =>
  channel.toString(16).padStart(2, "0");
#+END_SRC

****** Percent Calculations

#+BEGIN_SRC js
export const numberToPercent = (n) => multiply(100, n);
export const numberFromPercent = (percentage) => divide(100, percentage);
#+END_SRC

****** RGB Component Calculations

#+BEGIN_SRC js
export const numberToRgb = (n) => multiply(255, n);
export const numberFromRgb = (channel) => divide(255, channel);
export const rgbFromPercent = compose(
  numberFromPercent,
  numberToRgb,
  Math.round,
);
export const hexFragmentFromNumber = compose(
  numberToRgb,
  Math.round,
  hexFragmentFromRgb,
);
#+END_SRC

****** Hue Calculations

#+BEGIN_SRC js
export const radToDegrees = (radians) =>
  compose(
    () => divide(Math.PI, 180),
    (result) => multiply(result, radians),
    (degrees) => precision(degrees),
  )();
export const radFromDegrees = (degrees) =>
  compose(
    () => divide(180, Math.PI),
    (result) => multiply(result, degrees),
    (radians) => precision(radians),
  )();
export const gradToDegrees = (gradians) =>
  compose(
    () => divide(200, 180),
    (result) => multiply(result, gradians),
    (degrees) => precision(degrees),
  )();
export const numberToDegrees = (n) => multiply(360, n);
export const hueCorrection = (hue) =>
  normalize(
    360,
    -360,
    Math.sign(hue) === -1 ? Math.abs(add(360, hue)) : hue > 360
      ? remainder(360, hue)
      : hue,
  );
#+END_SRC

**** Validator
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/validator/index.js" :comments link
:END:

#+BEGIN_SRC js
import { QSCError } from "../../../error.js";
import { NAMED_COLOR_KEYWORDS } from "../../../data.js";
#+END_SRC

Before a color can be converted, we must be sure it's in fact a color.

#+BEGIN_SRC js
const SUPPORTED_FORMATS = {
  named: namedValidator,
  hex: hexValidator,
  rgb: rgbValidator,
  hsl: hslValidator,
  cmyk: cmykValidator,
  hwb: hwbValidator,
  cielab: cielabValidator,
  cielch: cielchValidator,
  oklab: oklabValidator,
};

export function validator(color) {
  return (
    Object.entries(SUPPORTED_FORMATS)
      .map(([format, fn]) => [format, fn(color) && color])
      .find(([, color]) => color) || InvalidOrUnsupportedColorError()
  );
}

function InvalidOrUnsupportedColorError() {
  throw new QSCError({
    name: "Invalid or Unsupported Color",
    reason: `
The input matches none of Quarks System Core's supported color formats. It's
also possible you have a syntax error.
`,
    suggestion: `
Check your input color against these supported CSS color formats:

Named Colors
------------
coral
springgreen
dodgerblue
rebeccapurple

RGB Hex
-------
#f0f
#ca5e
#933cca
#99eefff7

Functional RGB
--------------
rgb(30, 110, 0)
rgb(19%, 38.9%, 70%)
rgba(255, 255, 255, 0.8)
rgb(129 22 108)
rgb(20% 2% 100% / 0.25)

Functional HSL
--------------
hsl(240, 39%, 81%)
hsla(120, 78%, 45%, 0.93)
hsl(2.5rad 29% 40%)
hsl(216.44grad 20% 90% / 0.75)

Device CMYK
-----------
device-cmyk(0 0.2 0.399 0)
device-cmyk(90% 0% 0% 37.5%)
device-cmyk(0% 39% 0% 0 / 0.88)

HWB
---
hwb(60 83% 0%)
hwb(90 0% 37%)
hwb(0.75turn 30% 25%)
hwb(300 29% 5% / 0.99)

CIELAB
------
lab(48% 101 -39)
lab(87% -33 0)
lab(59% -88 -2 / 0.5)

CIELCh(ab)
----------
lch(25% 49 180)
lch(75% 0 0)
lch(56.551 77.38 2rad / 0.6892)

Oklab (LCh)
-----------
NOTE: This format is non-standard. If you use it, be sure to
convert to a standard CSS format. Example: hex("oklab(0% 0 0)")

oklab(59.4% 0.33 150)
oklab(33% 64% 0.2turn)
oklab(68.332% 0.16 1.778rad)
`,
  });
}
#+END_SRC

***** Syntax Tokens

****** Primitives

#+BEGIN_SRC js
const NUMBER_TOKEN = /(?:-?(?!0\d)\d+(?:\.\d+)?)/;
const PERCENT_TOKEN = new RegExp(["(?:", NUMBER_TOKEN.source, "%)"].join(""));
#+END_SRC

****** Delimiters

#+BEGIN_SRC js
const DELIMITER = /(?:[\s,]+)/;
const ALPHA_DELIMITER = new RegExp(DELIMITER.source.replace(",", ",/"));
const CSS4_DELIMITER = new RegExp(DELIMITER.source.replace(",", ""));
const CSS4_ALPHA_DELIMITER = new RegExp(
  ALPHA_DELIMITER.source.replace(",", ""),
);
#+END_SRC

****** Components

#+BEGIN_SRC js
const COMPONENT_TOKEN = new RegExp(
  ["(?:", PERCENT_TOKEN.source, "|", NUMBER_TOKEN.source, ")"].join(""),
);
const HUE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "(?:deg|g?rad|turn)?)"].join(""),
);
#+END_SRC

***** Named Color Validator

#+BEGIN_SRC js
function namedValidator(color) {
  return !!NAMED_COLOR_KEYWORDS[color];
}
#+END_SRC

***** Hex Validator

#+BEGIN_SRC js
function hexValidator(color) {
  return /^#([\da-f]{3,4}){1,2}$/i.test(color);
}
#+END_SRC

***** RGB Validator

#+BEGIN_SRC js
function rgbValidator(color) {
  return matchFunctionalFormat(
    { prefix: "rgba?" },
    Array(3).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

***** HSL Validator

#+BEGIN_SRC js
function hslValidator(color) {
  return matchFunctionalFormat({ prefix: "hsla?" }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENT_TOKEN),
  ]).test(color);
}
#+END_SRC

***** CMYK Validator

#+BEGIN_SRC js
function cmykValidator(color) {
  return matchFunctionalFormat(
    { prefix: "device-cmyk", legacy: false },
    Array(4).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

***** HWB Validator

#+BEGIN_SRC js
function hwbValidator(color) {
  return matchFunctionalFormat({ prefix: "hwb", legacy: false }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENT_TOKEN),
  ]).test(color);
}
#+END_SRC

***** CIELAB Validator

#+BEGIN_SRC js
function cielabValidator(color) {
  return matchFunctionalFormat({ prefix: "lab", legacy: false }, [
    PERCENT_TOKEN,
    ...Array(2).fill(NUMBER_TOKEN),
  ]).test(color);
}
#+END_SRC

***** CIELCh(ab) Validator

#+BEGIN_SRC js
function cielchValidator(color) {
  return matchFunctionalFormat({ prefix: "lch", legacy: false }, [
    PERCENT_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

***** Oklab Validator

#+BEGIN_SRC js
function oklabValidator(color) {
  return matchFunctionalFormat({ prefix: "oklab", legacy: false }, [
    PERCENT_TOKEN,
    COMPONENT_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

***** Functional Formats

#+BEGIN_SRC js
function matchFunctionalFormat({ prefix, legacy = true }, tokens) {
  const VALUES = tokens.map((token) => token.source);

  const SEPARATOR = legacy ? DELIMITER.source : CSS4_DELIMITER.source;
  const ALPHA_SEPARATOR = legacy
    ? ALPHA_DELIMITER.source
    : CSS4_ALPHA_DELIMITER.source;

  return new RegExp(
    `(?:^${prefix}\\(`.concat(
      VALUES.join(SEPARATOR),
      `(?:${[ALPHA_SEPARATOR, COMPONENT_TOKEN.source].join("")})?\\))`,
    ),
  );
}
#+END_SRC

**** Extractor
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/extractor/index.js" :comments link
:END:

#+BEGIN_SRC js
import { compose } from "../../fp.js";
import { validator } from "../validator/index.js";
#+END_SRC

Once we're sure have a valid color, we need to extract its components.

#+BEGIN_SRC js
export const extractor = compose(validator, ([format, color]) => [
  format,
  format === "hex" ? hexExtractor(color) : componentExtractor(color),
]);
#+END_SRC

***** Hex Extractor

#+BEGIN_SRC js
function hexExtractor(color) {
  return expandHex(color).match(/[\da-f]{2}/gi);
}

function expandHex(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

***** Component Extractor

#+BEGIN_SRC js
function componentExtractor(color) {
  return color.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
}
#+END_SRC

**** Parser
:PROPERTIES:
:header-args:js: :tangle "./lib/utilities/color/parser/index.js" :comments link
:END:

#+BEGIN_SRC js
import { compose, pipe } from "../../fp.js";
import { validator } from "../validator/index.js";
import { extractor } from "../extractor/index.js";
import {
  gradToDegrees,
  hexFragmentToRgb,
  hueCorrection,
  numberFromPercent,
  numberFromRgb,
  numberToDegrees,
  precision,
  radFromDegrees,
  radToDegrees,
} from "../converter/math.js";
#+END_SRC

#+BEGIN_SRC js
const FORMAT_PARSERS = {
  hex: parseHex,
  rgb: parseRGB,
  hsl: parseHSL,
  cmyk: parseCMYK,
  hwb: parseHSL, // identical to HSL
  cielab: parseCielab,
  cielch: parseCielch,
  oklab: parseOklab,
};

export const parser = compose(
  validator,
  ([format, color]) => FORMAT_PARSERS[format](color),
);
#+END_SRC

***** Format Parsers

****** Hex Parser

#+BEGIN_SRC js
function parseHex(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "ff"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 3
          ? pipe(c, hexFragmentToRgb, numberFromRgb)
          : hexFragmentToRgb(c)
      ),
    ],
  );
}
#+END_SRC

****** RGB Parser

#+BEGIN_SRC js
function parseRGB(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        c.endsWith("%")
          ? parsePercent(c)
          : pos === 3
          ? parseNumber(c)
          : parseChannel(c)
      ),
    ],
  );
}
#+END_SRC

****** HSL Parser

#+BEGIN_SRC js
function parseHSL(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 0
          ? parseHue(c)
          : pos === 3
          ? c.endsWith("%") ? parsePercent(c) : parseNumber(c)
          : parsePercent(c)
      ),
    ],
  );
}
#+END_SRC

****** CMYK Parser

#+BEGIN_SRC js
function parseCMYK(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 5 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c) => c.endsWith("%") ? parsePercent(c) : parseNumber(c)),
    ],
  );
}
#+END_SRC

****** CIELAB Parser

#+BEGIN_SRC js
function parseCielab(color) {
  return parseCie((ab) => parseNumber(ab), color);
}
#+END_SRC

****** CIELCh(ab) Parser

#+BEGIN_SRC js
function parseCielch(color) {
  return parseCie(
    (c, pos) => (pos === 2 ? parseHue(c) : parseNumber(c)),
    color,
  );
}
#+END_SRC

****** Oklab Parser

#+BEGIN_SRC js
function parseOklab(color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 0
          ? parsePercent(c)
          : pos === 1 || pos === 3
          ? c.endsWith("%") ? parsePercent(c) : parseNumber(c)
          : parseHueAsRadians(c)
      ),
    ],
    ([format, [L, C, H, A]]) => [
      format,
      [L, C * Math.cos(H), C * Math.sin(H), A],
    ],
  );
}
#+END_SRC

***** Token Parsers

****** Number Parser

#+BEGIN_SRC js
function parseNumber(n) {
  return pipe(n, parseFloat, precision);
}
#+END_SRC

****** Percent Parser

#+BEGIN_SRC js
function parsePercent(percentage) {
  return pipe(percentage, parseFloat, numberFromPercent);
}
#+END_SRC

****** RGB Channel Parser

#+BEGIN_SRC js
function parseChannel(channel) {
  return pipe(channel, parseFloat, numberFromRgb);
}
#+END_SRC

****** Hue Parsers

#+BEGIN_SRC js
function parseHue(hue) {
  return hueCorrection(
    hue.endsWith("grad")
      ? gradToDegrees(parseFloat(hue))
      : hue.endsWith("rad")
      ? radToDegrees(parseFloat(hue))
      : hue.endsWith("turn")
      ? numberToDegrees(parseFloat(hue))
      : parseFloat(hue),
  );
}

function parseHueAsRadians(hue) {
  return hue.endsWith("rad") && !hue.endsWith("grad")
    ? parseNumber(hue)
    : pipe(hue, parseHue, radFromDegrees);
}
#+END_SRC

****** CIE* Parser

#+BEGIN_SRC js
function parseCie(unique, color) {
  return pipe(
    extractor(color),
    ([format, components]) => [
      format,
      components.length === 4 ? components : [...components, "1"],
    ],
    ([format, components]) => [
      format,
      components.map((c, pos) =>
        pos === 0
          ? parseNumber(c)
          : pos === 3
          ? c.endsWith("%") ? parsePercent(c) : parseNumber(c)
          : unique(c, pos)
      ),
    ],
  );
}
#+END_SRC

***** Output

#+BEGIN_SRC js
export function output(data) {
  return pipe(
    data,
    ([format, components]) => COLOR_ASSEMBLER(components)[format],
  );
}
#+END_SRC

#+BEGIN_SRC js
function COLOR_ASSEMBLER(components) {
  return {
    hex: hexOutput(components),
    rgb: legacyOutput("rgb", components),
    hsl: legacyOutput("hsl", components),
    cmyk: modernOutput("device-cmyk", components),
    hwb: modernOutput("hwb", components),
    cielab: modernOutput("lab", components),
    cielch: modernOutput("lch", components),
    oklab: modernOutput("oklab", components),
  };
}

function hexOutput([R, G, B, A]) {
  return "#".concat(R, G, B, A === "ff" ? "" : A);
}

function legacyOutput(prefix, [C1, C2, C3, A]) {
  return `${A === 1 ? prefix : prefix.concat("a")}(`.concat(
    (A === 1 ? [C1, C2, C3] : [C1, C2, C3, precision(parseFloat(A))]).join(
      ", ",
    ),
    ")",
  );
}

function modernOutput(prefix, components) {
  return `${prefix}(`.concat(
    components.slice(0, components.length - 1).join(" "),
    components[components.length - 1] === 1
      ? ""
      : ` / ${precision(parseFloat(components.slice(-1)))}`,
    ")",
  );
}
#+END_SRC

** Error Handling
:PROPERTIES:
:header-args:js: :tangle "./lib/error.js" :comments link
:END:

#+BEGIN_SRC js
export class QSCError extends Error {
  constructor({
    name = "Unknown Error",
    reason = "here's why",
    suggestion = "try this",
  } = {}) {
    super();
    this.name = name;
    this.message = `
${reason}
${suggestion}
${"=".repeat(80)}
`;
  }
}
#+END_SRC

** Data
:PROPERTIES:
:header-args:js: :tangle "./lib/data.js" :comments link
:END:

**** Named Color Keywords

#+BEGIN_SRC js
export const NAMED_COLOR_KEYWORDS = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
#+END_SRC

**** Colors Project Web Defaults

#+BEGIN_SRC js
export const A11Y_PALETTE = {
  navy: "#001f3f",
  blue: "#0074d9",
  aqua: "#7fdbff",
  teal: "#39cccc",
  olive: "#3d9970",
  green: "#2ecc40",
  lime: "#01ff70",
  yellow: "#ffdc00",
  orange: "#ff851b",
  red: "#ff4136",
  maroon: "#85144b",
  fuchsia: "#f012be",
  purple: "#b10dc9",
  black: "#111111",
  gray: "#aaaaaa",
  grey: "#aaaaaa",
  silver: "#dddddd",
  white: "#ffffff",
};
#+END_SRC

**** System Font Stacks

#+BEGIN_SRC js
export const SYSTEM_FONT_STACKS = {
  sans:
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  serif:
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  monospace:
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
};
#+END_SRC
