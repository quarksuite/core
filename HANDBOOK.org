#+TITLE: QuarkSuite Core Handbook (v2.0.0)
#+PROPERTY: header-args:js :results silent :tangle no :comments none :mkdirp yes

* Table of Contents :TOC@5:
- [[#summary][Summary]]
- [[#basic-workflow][Basic Workflow]]
  - [[#modules][Modules]]
  - [[#color][Color]]
    - [[#1-set-a-base-color][1. Set a base color]]
    - [[#2-generate-a-base-scheme][2. Generate a base scheme]]
    - [[#3-generate-raw-palette-data][3. Generate raw palette data]]
    - [[#4-filter-palette-data-for-accessibility][4. Filter palette data for accessibility]]
  - [[#content][Content]]
  - [[#tokens][Tokens]]
  - [[#tokensjs-output][=tokens.js= Output]]
- [[#advanced-workflow][Advanced Workflow]]
  - [[#modules-1][Modules]]
  - [[#color-1][Color]]
    - [[#rules][Rules]]
      - [[#1-color][1. Color]]
        - [[#1a-color-should-be-converted-to-rgb][1a. Color should be converted to RGB]]
        - [[#1b-color-chroma-should-be-reduced-by-5-and-hue-adjusted-clockwise-60-degrees][1b. Color chroma should be reduced by 5% and hue adjusted clockwise 60 degrees]]
        - [[#1c-color-should-be-scaled-to-an-analogous-harmony][1c. Color should be scaled to an analogous harmony]]
      - [[#2-palette][2. Palette]]
        - [[#2a-generate-material-palettes-for-ui-and-text-with-accents-and-state][2a. Generate material palettes for UI and text (with accents and state)]]
        - [[#2b-check-palette-validity-against-wcag-standards-where-ui-is-aa-large-and-text-is-aaa][2b. Check palette validity against WCAG standards (where UI is AA large and text is AAA)]]
    - [[#processes][Processes]]
    - [[#result][Result]]
  - [[#content-1][Content]]
    - [[#rules-1][Rules]]
      - [[#1-global][1. Global]]
        - [[#1a-the-global-modular-scale-is-5-values-derived-from-a-ratio-of-132][1a. The global modular scale is 5 values derived from a ratio of 1.32]]
      - [[#2-text][2. Text]]
        - [[#2a-body-uses-regular-and-bold-weights-with-a-sans-serif-system-fallback][2a. Body uses regular and bold weights with a sans-serif system fallback]]
        - [[#2b-headings-use-light-and-black-weights-with-a-serif-system-fallback][2b. Headings use light and black weights with a serif system fallback]]
        - [[#2c-size-is-bidirectional-in-rem-units-with-an-em-inversion][2c. Size is bidirectional in rem units with an em inversion]]
        - [[#2d-leading-is-ranged-with-minimum-of-12-to-a-maximum-of-15][2d. Leading is ranged with minimum of 1.2 to a maximum of 1.5]]
        - [[#2e-measure-is-ranged-in-ch-with-a-minimum-of-48-to-a-maximum-of-75][2e. Measure is ranged in ch with a minimum of 48 to a maximum of 75]]
      - [[#3-spacing][3. Spacing]]
        - [[#3a-spacing-is-bidirectional-in-ex-units][3a. Spacing is bidirectional in ex units]]
      - [[#4-grid][4. Grid]]
        - [[#4a-fractionals-are-bidirectional][4a. Fractionals are bidirectional]]
        - [[#4b-grid-dimensions-are-set][4b. Grid dimensions are set]]
      - [[#5-viewport][5. Viewport]]
        - [[#5a-viewport-dimensions-are-ranged-set-for-width-height-min-and-max][5a. Viewport dimensions are ranged set for width, height, min, and max]]
    - [[#result-1][Result]]
  - [[#tokens-1][Tokens]]
  - [[#tokensjs-output-1][=tokens.js= Output]]
- [[#modular-workflow][Modular Workflow]]
  - [[#color-2][Color]]
    - [[#modules-2][Modules]]
    - [[#constants][Constants]]
    - [[#recipe][Recipe]]
  - [[#content-2][Content]]
    - [[#modules-3][Modules]]
    - [[#text][Text]]
      - [[#constants-1][Constants]]
      - [[#recipe-1][Recipe]]
    - [[#spacing][Spacing]]
      - [[#recipe-2][Recipe]]
    - [[#grid][Grid]]
      - [[#recipe-3][Recipe]]
    - [[#viewport][Viewport]]
      - [[#constants-2][Constants]]
      - [[#recipe-4][Recipe]]
  - [[#tokens-2][Tokens]]
- [[#exporting-tokens][Exporting Tokens]]
  - [[#1-import-exporterjs-module][1. Import =exporter.js= module]]
  - [[#2-import-the-generated-tokens][2. Import the generated tokens]]
  - [[#3-define-project][3. Define project]]
  - [[#4-set-domain-targets][4. Set domain targets]]
  - [[#5-write-to-filesystem][5. Write to filesystem]]
  - [[#6-run-build][6. Run build]]
  - [[#buildjs-output][=build.js= Output]]
- [[#next-steps][Next Steps]]

* Summary

This document is a practical guide to QuarkSuite Core. It's intended to introduce you, the reader, to the library and
its purpose from a user perspective. For a technical overview, [[https://github.com/quarksuite/core/blob/v2-workspace/API.org][refer to the API]].

This document /intentionally/ skips setup and environment details (see the README) to focus instead on a working
example.

We'll be covering three workflows in order of complexity:

+ Basic
+ Advanced
+ Modular

The basic workflow will show you simple token generation and collection assembly. From there, you'll get into the
advanced usage of defining rules and processes to scale collections. The modular workflow will show you how to
distribute your rules and token structures to share with other projects.

By the end of this document, I hope you learn a little something about how you can use QuarkSuite to create consistent,
accessible baselines for your web projects.

If any part of the handbook is hard to understand, please open an issue and let me know.

* Basic Workflow

QuarkSuite allows a lot of flexibility in how you can work, but for our purposes, we'll begin by creating a single file named
=tokens.js= and build our baseline up from there.

** Modules

For our project, we'll need specific functionality from the =color.js= and =content.js= modules.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
import {
  convert,
  adjust,
  harmony,
  palette,
  accessibility,
  tokens as color
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/color.js";
import {
  text,
  ms,
  tokens as content
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/content.js";
#+END_SRC

** Color

The first set of data we'll create is our color palette.

*** 1. Set a base color

Let's begin by setting a base color and slightly adjusting it for our use.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
const swatch = convert("rgb", "#7ea");
const base = adjust({ chroma: -5, hue: 60 }, swatch);
#+END_SRC

*** 2. Generate a base scheme

Next, we want to generate an analogous color harmony as the basis of our palette generation.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
const scheme = harmony({ configuration: "analogous" }, base);
#+END_SRC

*** 3. Generate raw palette data

The next step is to generate the raw palette data for further processing. In this case, we'll create a =ui= and =body=
palette from the first and second colors in our scheme.

Assuming our web project is an app, we'll want to generate a =material= configuration.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
const ui = palette({
  configuration: "material",
  accents: true,
  states: true
}, scheme[0]);
const body = palette({ configuration: "material", accents: true }, scheme[1]);
#+END_SRC

*** 4. Filter palette data for accessibility

Let's ensure our palettes will be usable in our defined contexts (=ui, =body=) by performing a color accessibility check
for each one (based on WCAG standards).

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
const uiA11y = accessibility({ mode: "standard", rating: "AA", large: true }, ui);
const bodyA11y = accessibility({ mode: "standard", rating: "AAA" }, body);
#+END_SRC

** Content

The main concern for our content data at this point is to generate a global modular scale as the starting point for
creating numeric token data.

For that, we're going to generate a =5= value modular scale from a base of =1= and a somewhat unconventional ratio of
=1.32=.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
const scale = ms({ ratio: 1.32, values: 5 }, 1);
#+END_SRC

** Tokens

Now we're ready to actually create our tokens. For that, we'll create a token object to export. Let's wrap the tokens
in a namespace of =hb= (for handbook) before slotting and transforming our data sets.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/tokens.js"
export default {
  hb: {
    color: {
      ui: color(uiA11y),
      text: color(bodyA11y),
      splash: scheme[2]
    },
    text: {
      body: text({ system: "sans", weights: ["regular", "bold"] }, "Work Sans"),
      heading: text({ system: "serif", weights: ["light", "black"] }, "Work Sans"),
      size: content({ type: "bidirectional", unit: "rem", inversion: "em" }, scale),
      leading: content({ type: "ranged", min: 1.2, max: 1.5, context: "max" }, scale),
      measure: content({ type: "ranged", unit: "ch", min: 48, max: 75, context: "max" }, scale)
    },
    spacing: content({ type: "bidirectional", unit: "ex" }, scale),
    grid: {
      fr: content({ type: "bidirectional", unit: "fr" }, scale),
      ...content({ type: "grid" }, scale)
    },
    viewport: {
      w: content({ type: "ranged", unit: "vw", min: 10, max: 100, context: "max" }, scale),
      h: content({ type: "ranged", unit: "vh", min: 10, max: 100, context: "max" }, scale),
      min: content({ type: "ranged", unit: "vmin", min: 10, max: 100, context: "max" }, scale),
      max: content({ type: "ranged", unit: "vmax", min: 10, max: 100, context: "max" }, scale),
    }
  }
};
#+END_SRC

** =tokens.js= Output

Our =tokens.js= file should now look something like the following code.

#+BEGIN_SRC js
import {
  convert,
  adjust,
  harmony,
  palette,
  accessibility,
  tokens as color
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/color.js";
import {
  text,
  ms,
  tokens as content
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/content.js";

const swatch = convert("rgb", "#7ea");
const base = adjust({ chroma: -5, hue: 60 }, swatch);

const scheme = harmony({ configuration: "analogous" }, base);

const ui = palette({
  configuration: "material",
  accents: true,
  states: true
}, scheme[0]);
const body = palette({ configuration: "material", accents: true }, scheme[1]);

const uiA11y = accessibility({ mode: "standard", rating: "AA", large: true }, ui);
const bodyA11y = accessibility({ mode: "standard", rating: "AAA" }, body);

const scale = ms({ ratio: 1.32, values: 5 }, 1);

export default {
  hb: {
    color: {
      ui: color(uiA11y),
      text: color(bodyA11y),
      splash: scheme[2]
    },
    text: {
      body: text({ system: "sans", weights: ["regular", "bold"] }, "Work Sans"),
      heading: text({ system: "serif", weights: ["light", "black"] }, "Work Sans"),
      size: content({ type: "bidirectional", unit: "rem", inversion: "em" }, scale),
      leading: content({ type: "ranged", min: 1.2, max: 1.5, context: "max" }, scale),
      measure: content({ type: "ranged", unit: "ch", min: 48, max: 75, context: "max" }, scale)
    },
    spacing: content({ type: "bidirectional", unit: "ex" }, scale),
    grid: {
      fr: content({ type: "bidirectional", unit: "fr" }, scale),
      ...content({ type: "grid" }, scale)
    },
    viewport: {
      w: content({ type: "ranged", unit: "vw", min: 10, max: 100, context: "max" }, scale),
      h: content({ type: "ranged", unit: "vh", min: 10, max: 100, context: "max" }, scale),
      min: content({ type: "ranged", unit: "vmin", min: 10, max: 100, context: "max" }, scale),
      max: content({ type: "ranged", unit: "vmax", min: 10, max: 100, context: "max" }, scale),
    }
  }
};
#+END_SRC

* Advanced Workflow

The basic workflow is great for small projects that need a singular data set.

The cracks in this approach starts to show the second you want to work with /multiple/ data sets.

The library provides a =workflow.js= module to handle these advanced use cases. Its only purpose is altering the way
library functions work to unlock design patterns that will be valuable for the user who needs to scale.

If the basic workflow is a bottom-up procedure where we assemble data from a known value, then advanced usage dictates a
top-down *set of rules* for the expected result to an unknown value.

** Modules

The first thing to do is import =workflow.js=, so let's do that now.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
import {
  convert,
  adjust,
  harmony,
  palette,
  accessibility,
  tokens as color
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/color.js";
import {
  text,
  ms,
  tokens as content
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/content.js";
import {
  preset,
  process,
  pipeline,
  propagate,
  delegate
} from "https://cdn.jsdelvr.net/gh/quarksuite/core@2.0.0-26/workflow.js";
#+END_SRC

** Color

Now, what set of rules directs our color token generation? Think about it for a second before we go on.

*** Rules

**** 1. Color

***** 1a. Color should be converted to RGB

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const toRgb = preset(convert, "rgb");
#+END_SRC

***** 1b. Color chroma should be reduced by 5% and hue adjusted clockwise 60 degrees

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const reduceChroma5 = preset(adjust, { chroma: -5 });
const shiftHueRight60 = preset(adjust, { hue: 60 });
#+END_SRC

***** 1c. Color should be scaled to an analogous harmony

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const scaleToAnalogous = preset(harmony, { configuration: "analogous" });
#+END_SRC

**** 2. Palette

***** 2a. Generate material palettes for UI and text (with accents and state)

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const paletteOpts = { configuration: "material", accents: true };
const genPalette = preset(palette, { ...paletteOpts, states: true });
const genTextPalette = preset(palette, paletteOpts);
#+END_SRC

***** 2b. Check palette validity against WCAG standards (where UI is AA large and text is AAA)

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const a11yOpts = { mode: "standard" };
const a11y = preset(accessibility, { ...a11yOpts, rating: "AA", large: true });
const a11yText = preset(accessibility, { ...a11yOpts, rating: "AAA" });
#+END_SRC

*** Processes

We can now define reusable processes that will actually carry out our rules. Particularly we want to create some to
properly generate our UI and text palettes. Notice how the token emitter (=color=) is dropped right in at the end.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const generatePaletteTokens = process(genPalette, a11y, color);
const generateTextPaletteTokens = process(genTextPalette, a11yText, color);
#+END_SRC

*** Result

All of the above makes our actual color generation code read like an order.

#+BEGIN_QUOTE
"Convert =#7ea= to RGB. Reduce chroma by 5 and shift hue 60 degrees right. Next, scale the result to an analogous
harmony. Then delegate the UI and text color token processes as =main= and =accent=. Leave =splash= alone."
#+END_QUOTE

The output is identical to the basic procedure but expressed in a more declarative way.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const scheme = pipeline(
  "#7ea",
  toRgb,
  reduceChroma5,
  shiftHueRight60,
  scaleToAnalogous
);

const [main, accent, splash] = delegate(
  scheme,
  generatePaletteTokens,
  generateTextPaletteTokens
);
#+END_SRC

** Content

Content modular scales are so simple compared to color that applying a top-down approach to them usually isn't
necessary. Let's say we do it anyway, though. How would that look?

*** Rules

**** 1. Global

***** 1a. The global modular scale is 5 values derived from a ratio of 1.32

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const genGlobalScale = preset(ms, { ratio: 1.32, values: 5});
#+END_SRC

**** 2. Text

***** 2a. Body uses regular and bold weights with a sans-serif system fallback

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const bodyAttrs = preset(text, { system: "sans", weights: ["regular", "bold"]});
#+END_SRC

***** 2b. Headings use light and black weights with a serif system fallback

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const headingAttrs = preset(text, { system: "serif", weights: ["light", "black"]});
#+END_SRC

***** 2c. Size is bidirectional in rem units with an em inversion

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const sizeAttrs = preset(content, { type: "bidirectional", unit: "rem", inversion: "em" });
#+END_SRC

***** 2d. Leading is ranged with minimum of 1.2 to a maximum of 1.5

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const leadingAttrs = preset(content, { type: "ranged", min: 1.2, max: 1.5, context: "max" });
#+END_SRC

***** 2e. Measure is ranged in ch with a minimum of 48 to a maximum of 75

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const measureAttrs = preset(content, { type: "ranged", unit: "ch", min: 48, max: 75, context: "max" });
#+END_SRC

**** 3. Spacing

***** 3a. Spacing is bidirectional in ex units

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const spacingAttrs = preset(content, { type: "bidirectional", unit: "ex" });
#+END_SRC

**** 4. Grid

***** 4a. Fractionals are bidirectional

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const gridFractionalAttrs = preset(content, { type: "bidirectional", unit: "fr" });
#+END_SRC

***** 4b. Grid dimensions are set

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const gridAttrs = preset(content, { type: "grid" });
#+END_SRC

**** 5. Viewport

***** 5a. Viewport dimensions are ranged set for width, height, min, and max

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const viewportOpts = { type: "ranged", min: 10, max: 100, context: "max" };
const viewportAttrs = [
  preset(content, { ...viewportOpts, unit: "vw"}),
  preset(content, { ...viewportOpts, unit: "vh"}),
  preset(content, { ...viewportOpts, unit: "vmin"}),
  preset(content, { ...viewportOpts, unit: "vmax"}),
];
#+END_SRC

*** Result

Let's assume for the sake of experimentation that instead of generating content tokens from a single global scale, we
want to generate a unique scale for each rule. Then we'll generate the tokens by category.

First, we'll set up a factory to generate modular scales on demand.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const scaleFactory = preset(propagate, genGlobalScale);
#+END_SRC

Now we'll delegate our content scale rules to generated scales. The text category has five subcategories.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const [
  body,
  heading,
  size,
  leading,
  measure
] = delegate(
  scaleFactory([1, 1, 1, 1, 1]),
  bodyAttrs,
  headingAttrs,
  sizeAttrs,
  leadingAttrs,
  measureAttrs
);
#+END_SRC

Spacing is its own category.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const spacing = pipeline(1, genGlobalScale, spacingAttrs);
#+END_SRC

Then we want to generate two subcategories for our grid category.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const [fractionals, grid] = delegate(
  scaleFactory([1, 1]),
  gridFractionalAttrs,
  gridAttrs
);
#+END_SRC

Finally, we apply the viewport rules to four subcategories.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
const [w, h, min, max] = delegate(
  scaleFactory([1, 1, 1, 1]),
  ...viewportAttrs
);
#+END_SRC

** Tokens

Since we've used a top-down approach, our token dictionary is going to look a little different. We've now effectively
separated token generation behavior from token collection structure. This means it's easier to restructure our
collection as needed.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/advanced-workflow/tokens.js"
export default {
  hb: {
    color: { ui: main, text: accent, splash },
    text: { body, heading, size, leading, measure },
    spacing,
    grid: { fr: fractionals, ...grid },
    viewport: { w, h, min, max }
  }
}
#+END_SRC

** =tokens.js= Output

We're done, so let's take a final look at what we've done.

#+BEGIN_SRC js
import {
  convert,
  adjust,
  harmony,
  palette,
  accessibility,
  tokens as color
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/color.js";
import {
  text,
  ms,
  tokens as content
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/content.js";
import {
  preset,
  process,
  pipeline,
  propagate,
  delegate
} from "https://cdn.jsdelvr.net/gh/quarksuite/core@2.0.0-26/workflow.js";

const toRgb = preset(convert, "rgb");

const reduceChroma5 = preset(adjust, { chroma: -5 });
const shiftHueRight60 = preset(adjust, { hue: 60 });

const scaleToAnalogous = preset(harmony, { configuration: "analogous" });

const paletteOpts = { configuration: "material", accents: true };
const genPalette = preset(palette, { ...paletteOpts, states: true });
const genTextPalette = preset(palette, paletteOpts);

const a11yOpts = { mode: "standard" };
const a11y = preset(accessibility, { ...a11yOpts, rating: "AA", large: true });
const a11yText = preset(accessibility, { ...a11yOpts, rating: "AAA" });

const generatePaletteTokens = process(genPalette, a11y, color);
const generateTextPaletteTokens = process(genTextPalette, a11yText, color);

const scheme = pipeline(
  "#7ea",
  toRgb,
  reduceChroma5,
  shiftHueRight60,
  scaleToAnalogous
);

const [main, accent, splash] = delegate(
  scheme,
  generatePaletteTokens,
  generateTextPaletteTokens
);

const genGlobalScale = preset(ms, { ratio: 1.32, values: 5});

const bodyAttrs = preset(text, { system: "sans", weights: ["regular", "bold"]});

const headingAttrs = preset(text, { system: "serif", weights: ["light", "black"]});

const sizeAttrs = preset(content, { type: "bidirectional", unit: "rem", inversion: "em" });

const leadingAttrs = preset(content, { type: "ranged", min: 1.2, max: 1.5, context: "max" });

const measureAttrs = preset(content, { type: "ranged", unit: "ch", min: 48, max: 75, context: "max" });

const spacingAttrs = preset(content, { type: "bidirectional", unit: "ex" });

const gridFractionalAttrs = preset(content, { type: "bidirectional", unit: "fr" });

const gridAttrs = preset(content, { type: "grid" });

const viewportOpts = { type: "ranged", min: 10, max: 100, context: "max" };
const viewportAttrs = [
  preset(content, { ...viewportOpts, unit: "vw"}),
  preset(content, { ...viewportOpts, unit: "vh"}),
  preset(content, { ...viewportOpts, unit: "vmin"}),
  preset(content, { ...viewportOpts, unit: "vmax"}),
];

const scaleFactory = preset(propagate, genGlobalScale);

const [
  body,
  heading,
  size,
  leading,
  measure
] = delegate(
  scaleFactory([1, 1, 1, 1, 1]),
  bodyAttrs,
  headingAttrs,
  sizeAttrs,
  leadingAttrs,
  measureAttrs
);

const spacing = pipeline(1, genGlobalScale, spacingAttrs);

const [fractionals, grid] = delegate(
  scaleFactory([1, 1]),
  gridFractionalAttrs,
  gridAttrs
);

const [w, h, min, max] = delegate(
  scaleFactory([1, 1, 1, 1]),
  ...viewportAttrs
);

export default {
  hb: {
    color: { ui: main, text: accent, splash },
    text: { body, heading, size, leading, measure },
    spacing,
    grid: { fr: fractionals, ...grid },
    viewport: { w, h, min, max }
  }
}
#+END_SRC

* Modular Workflow

The more complex our token generation needs become, the more we'll start identifying habits in our process. These
habits will replicate over projects and it will become tedious to set up the boilerplate. The solution here is to
/automate/ our habits.

Wrapping them in functions is the simplest approach. That's the one we'll use.

A modular workflow involves shifting your rules and processes from active to passive behavior. Think about what remains
constant and what changes, and then expose /only/ those knobs.

You may have also noticed that =tokens.js= is growing with each rule and process we define. Time to break things up.

** Color

First, we'll create a new file named =color-recipe.js=.

The key to refactoring our color token generation is to identify the variables and turn them into knobs without changing
the meaning of our rules. How can we do that?

*** Modules

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/color-recipe.js"
import {
  convert,
  adjust,
  harmony,
  palette,
  accessibility,
  tokens as color
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/color.js";
import {
  preset,
  process,
  pipeline,
  delegate
} from "https://cdn.jsdelvr.net/gh/quarksuite/core@2.0.0-26/workflow.js";
#+END_SRC

*** Constants

We look at our constants:

+ The palettes will always output with material configurations
+ The palettes will always output with accents and interface states
+ UI and text contexts will always be delegated to the first two indexes
+ Any remaining indexes are left untouched

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/color-recipe.js"
const paletteOpts = { configuration: "material", accents: true };
const genPalette = preset(palette, { ...paletteOpts, states: true });
const genTextPalette = preset(palette, paletteOpts);

const a11yOpts = { mode: "standard" };
const a11y = preset(accessibility, { ...a11yOpts, rating: "AA", large: true });
const a11yText = preset(accessibility, { ...a11yOpts, rating: "AAA" });

const generatePaletteTokens = process(genPalette, a11y, color);
const generateTextPaletteTokens = process(genTextPalette, a11yText, color);
#+END_SRC

*** Recipe

And derive a recipe from our variables:

+ The color won't always have its properties adjusted
+ The color won't always scale to an analogous harmony
+ The output won't always be in RGB format

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/color-recipe.js"
export default function({ scheme = "analogous", format = "rgb" }, swatch) {
  const setFormat = preset(convert, format);
  const setScheme = preset(harmony, { configuration: scheme });

  const base = pipeline(swatch, setFormat, setScheme);

  return delegate(
    Array.isArray(base)
      ? base
      : [base, base],
    generatePaletteTokens,
    generateTextPaletteTokens
  );
}
#+END_SRC

** Content

First, create a new file named =content-recipes.js=.

Now we're going to modularize one category at a time.

*** Modules

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/content-recipes.js"
import {
  text,
  ms,
  tokens as content
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/content.js";
import {
  preset,
  delegate
} from "https://cdn.jsdelvr.net/gh/quarksuite/core@2.0.0-26/workflow.js";
#+END_SRC

*** Text

**** Constants

+ Body family always outputs with regular and bold weights
+ Heading family always outputs with light and black weights

+ Size is always bidirectional in rems with em inversion
+ Leading is always a unitless range
+ Measure is always ranged in ch

**** Recipe

+ Body system fallback is not always sans-serif
+ Heading system fallback is not always serif

+ The default minimum and maximum leading is not always a good fit
+ The default minimum and maximum measure is not always a good fit

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/content-recipes.js"
export function textRecipe({ body = "sans", heading = "serif" }, font) {
  const bodyAttrs = preset(text, { system: body, weights: ["regular", "bold"] });
  const headingAttrs = preset(text, { system: heading, weights: ["light", "black"] });

  return delegate([font, font], bodyAttrs, headingAttrs);
}

export function typographyRecipe({ leading = [1.2, 1.5], measure = [48, 75] }, ms) {
  const sizeAttrs = preset(content, { type: "bidirectional", unit: "rem", inversion: "em" });

  const [leadingMin, leadingMax] = leading;
  const leadingAttrs = preset(content, {
    type: "ranged",
    min: leadingMin,
    max: leadingMax,
    context: "max"
  });

  const [measureMin, measureMax] = measure;
  const measureAttrs = preset(content, {
    type: "ranged",
    unit: "ch",
    min: measureMin,
    max: measureMax,
    context: "max"
  });

  return delegate([ms, ms, ms], sizeAttrs, leadingAttrs, measureAttrs);
}
#+END_SRC

*** Spacing

**** Recipe

+ The spacing will not always be in ex

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/content-recipes.js"
export function spacingRecipe(unit, ms) {
  return content({ type: "bidirectional", unit }, ms);
}
#+END_SRC

*** Grid

**** Recipe

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/content-recipes.js"
export function gridRecipe(ms) {
  const gridFractionalAttrs = preset(content, { type: "bidirectional", unit: "fr" });
  const gridAttrs = preset(content, { type: "grid" });

  return delegate([ms, ms], gridFractionalAttrs, gridAttrs);
}
#+END_SRC

*** Viewport

**** Constants

+ The output will always be viewport relative corresponding with dimensions

**** Recipe

+ The output will not always need every dimension
+ The default minimum and maximum length is not always a good fit

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/content-recipes.js"
export function viewportRecipe({
  dimensions = ["width", "height", "min", "max"],
  min = 10,
  max = 100
}, ms) {
  const viewportOpts = { type: "ranged", min, max, context: "max" };

  const targets = [
    ["width", "vw"],
    ["height", "vh"],
    ["min", "vmin"],
    ["max", "vmax"]
  ];

  return targets
    .filter(([length], index) => length === dimensions[index])
    .map(([length, unit]) => content({ ...viewportOpts, unit }, ms));
}
#+END_SRC

** Tokens

Finally, let's reassemble our tokens using the recipes we just made.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/modular-workflow/tokens.js"
import { adjust } from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/color.js";
import { ms } from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/content.js";
import paletteRecipe from "./color-recipe.js";
import {
  textRecipe,
  typographyRecipe,
  spacingRecipe,
  gridRecipe,
  viewportRecipe
} from "./content-recipes.js";

const [main, accent, splash] = paletteRecipe({}, adjust({
    chroma: -5,
    hue: 60
}, "#7ea"));

const [body, heading] = textRecipe({}, "Work Sans");

const scale = ms({ ratio: 1.32, values: 5 }, 1);

const [size, leading, measure] = typographyRecipe({}, scale);

const spacing = spacingRecipe("ex", scale);

const [fractionals, grid] = gridRecipe(scale);

const [w, h, min, max] = viewportRecipe({}, scale);

export default {
  hb: {
    color: { ui: main, text: accent, splash },
    text: { body, heading, size, leading, measure },
    spacing,
    grid: { fr: fractionals, ...grid },
    viewport: { w, h, min, max }
  }
}
#+END_SRC

* Exporting Tokens

#+BEGIN_QUOTE
At this point, it's important to note that it's a good idea to keep your token generating code apart from your exporting
code. This will allow you to tailor your exporting process to a given JavaScript engine. And this means you can *safely
adapt the exporting logic for different engines*.

Example:

+ =build.web.js=: when using the native web
+ =build.node.js=: when using Node.js
+ =build.deno.js=: when using Deno
+ =build.qjs.js=: when using QuickJS

Generally speaking, you will not need to export your tokens more than a few times during development, but I'm sure you
can see the usefulness of this structure.
#+END_QUOTE

If your web project uses JavaScript itself to style your interface (such as a CSS-in-JS library):
congratulations. You're done already. Go forth and create.

For the rest of us, we'll need to export our tokens to use in our target environments.

Since we're still here, we'll now create a =build.js= file for the exporting process.

** 1. Import =exporter.js= module

First, we have to pull in the exporters themselves before we can do anything.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/build.js"
import {
  stylesheet,
  data,
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/exporter.js";
#+END_SRC

** 2. Import the generated tokens

Next, we import the tokens we created in =tokens.js=.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/build.js"
import tokens from "./tokens.js";
#+END_SRC

** 3. Define project

This step is crucial. Unless we wrap the tokens in an object that contains a =project= property, the exporters *will
throw an error*. This is by design; it prevents us from accidentally invoking an exporter on arbitrary token
collections.

In this sense, =project= works like a tag that tells an exporter "this is a complete dictionary. You may
proceed". Otherwise, it's "stop what you're doing. Right now."

We'll store the token dictionary as =dict= for later.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/build.js"
const dict = {
  project: {
    name: "Handbook Example Tokens",
    author: "Chatman R. Jr",
    license: "Unlicense",
    version: "0.1.0"
  },
  ...tokens
};
#+END_SRC

** 4. Set domain targets

#+BEGIN_QUOTE
At this point, you should know that the exporter functions do not write to your filesystem. This is for security.

Instead, they format the token dictionary to a file-ready state which you can then write to a file yourself using your
environment's native API or a library.
#+END_QUOTE

Here's the fun part. We'll format our dictionary based on the domain targets.

In this case, we want to export our tokens as CSS custom properties and JSON. And let's also store the results in
=targets=.

As a bonus, exporters transform token collections in a dictionary /recursively/. This means the structure of your token
collection is your choice.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/build.js"
const targets = {
  css: stylesheet("css", dict),
  json: data("json", dict)
};
#+END_SRC

** 5. Write to filesystem

#+BEGIN_QUOTE
Hint: if you're using QuarkSuite server side and you're exporting a single format, you can print the output of the
exporter to the console and copy/paste or pipe the result to a new file.
#+END_QUOTE

Time to actually write the file to our OS. Let's assume we've been building our tokens in Deno (v1.20.5) so far.

#+BEGIN_SRC js :tangle "../quarksuite:examples/handbook/basic-workflow/build.js"
import { ensureDir } from "https://deno.land/std@0.143.0/fs/mod.ts";

const out = "./dist";

// This will create the output directory if it does not exist
await ensureDir(out);

Object.entries(targets).forEach(async ([ext, output]) => {
  await Deno.writeTextFile(out.concat(`/tokens.${ext}`), output);
});
#+END_SRC

** 6. Run build

Finally, we run =build.js= to create our export files.

#+BEGIN_SRC shell
deno run --allow-read --allow-write build.js
#+END_SRC

This will output =./dist= with our exported tokens.

#+BEGIN_SRC text
dist
├── tokens.css
└── tokens.json
#+END_SRC

** =build.js= Output

Our build file is now complete and we won't need to touch it again for a good while.

#+BEGIN_SRC js
import {
  stylesheet,
  data,
} from "https://cdn.jsdelivr.net/gh/quarksuite/core@2.0.0-26/exporter.js";

import tokens from "./tokens.js";

const dict = {
  project: {
    name: "Handbook Example Tokens",
    author: "Chatman R. Jr",
    license: "Unlicense",
    version: "0.1.0"
  },
  ...tokens
};

const targets = {
  css: stylesheet("css", dict),
  json: data("json", dict)
};

import { ensureDir } from "https://deno.land/std@0.143.0/fs/mod.ts";

const out = "./dist";

// This will create the output directory if it does not exist
await ensureDir(out);

Object.entries(targets).forEach(async ([ext, output]) => {
  await Deno.writeTextFile(out.concat(`/tokens.${ext}`), output);
});
#+END_SRC

* Next Steps

With that, we've reached the end of the handbook. Hopefully, you were able to follow along. You now know the core
approaches to using and customizing QuarkSuite for your design token workflow. I didn't cover everything, but I want to
think I've provided a good foundation for the experimental reader to build on.

If I missed the mark, submit an issue as always.

If you've read the handbook but you haven't read the API, I recommend doing that because it [[https://github.com/quarksuite/core/blob/v2-workspace/API.org][expands on the technical
details]] not clarified here.

To those who have already read both documents by now: thank you for your time. I hope you got something out of it even
if you don't use the library.
