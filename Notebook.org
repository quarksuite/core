#+TITLE: QuarkSuite (v2)
#+PROPERTY: header-args:deno :tangle yes :mkdirp yes
#+PROPERTY: header-args:js :tangle yes :mkdirp yes
#+PROPERTY: header-args:shell :results output code

* Table of Contents :TOC@5:
- [[#summary][Summary]]
- [[#whats-new-in-v2][What's New in v2?]]
  - [[#workflows][Workflows]]
  - [[#concrete-idioms][Concrete Idioms]]
  - [[#settled-types][Settled Types]]
  - [[#simple-data-rendering][Simple Data Rendering]]
  - [[#wtcg-design-token-spec][WTCG Design Token Spec]]
  - [[#improved-performance][Improved Performance]]
  - [[#internal-simplicity][Internal Simplicity]]
  - [[#improved-modularity][Improved Modularity]]
- [[#spec][Spec]]
  - [[#api][API]]
    - [[#functional-utilities][Functional Utilities]]
      - [[#fn_process][fn_process]]
        - [[#fn_process-examples][fn_process Examples]]
        - [[#fn_process-implementation][fn_process Implementation]]
        - [[#fn_process-tests][fn_process Tests]]
        - [[#fn_process-errors][fn_process Errors]]
      - [[#fn_preset][fn_preset]]
        - [[#fn_preset-examples][fn_preset Examples]]
        - [[#fn_preset-implementation][fn_preset Implementation]]
        - [[#fn_preset-tests][fn_preset Tests]]
        - [[#fn_preset-errors][fn_preset Errors]]
      - [[#fn_pipeline][fn_pipeline]]
        - [[#fn_pipeline-examples][fn_pipeline Examples]]
        - [[#fn_pipeline-implementation][fn_pipeline Implementation]]
        - [[#fn_pipeline-tests][fn_pipeline Tests]]
        - [[#fn_pipeline-errors][fn_pipeline Errors]]
    - [[#color][Color]]
      - [[#color_adjust][color_adjust]]
        - [[#color_adjust-examples][color_adjust Examples]]
        - [[#color_adjust-implementation][color_adjust Implementation]]
        - [[#color_adjust-tests][color_adjust Tests]]
      - [[#color_mix][color_mix]]
        - [[#color_mix-examples][color_mix Examples]]
        - [[#color_mix-implementation][color_mix Implementation]]
        - [[#color_mix-tests][color_mix Tests]]
      - [[#color_as_hex][color_as_hex]]
        - [[#color_as_hex-examples][color_as_hex Examples]]
        - [[#color_as_hex-implementation][color_as_hex Implementation]]
        - [[#color_as_hex-tests][color_as_hex Tests]]
      - [[#color_as_rgb][color_as_rgb]]
        - [[#color_as_rgb-examples][color_as_rgb Examples]]
        - [[#color_as_rgb-implementation][color_as_rgb Implementation]]
        - [[#color_as_rgb-tests][color_as_rgb Tests]]
      - [[#color_as_hsl][color_as_hsl]]
        - [[#color_as_hsl-examples][color_as_hsl Examples]]
        - [[#color_as_hsl-implementation][color_as_hsl Implementation]]
        - [[#color_as_hsl-tests][color_as_hsl Tests]]
      - [[#color_as_cmyk][color_as_cmyk]]
        - [[#color_as_cmyk-examples][color_as_cmyk Examples]]
        - [[#color_as_cmyk-implementation][color_as_cmyk Implementation]]
        - [[#color_as_cmyk-tests][color_as_cmyk Tests]]
      - [[#color_as_hwb][color_as_hwb]]
        - [[#color_as_hwb-examples][color_as_hwb Examples]]
        - [[#color_as_hwb-implementation][color_as_hwb Implementation]]
        - [[#color_as_hwb-tests][color_as_hwb Tests]]
      - [[#color_as_cielab][color_as_cielab]]
        - [[#color_as_cielab-examples][color_as_cielab Examples]]
        - [[#color_as_cielab-implementation][color_as_cielab Implementation]]
        - [[#color_as_cielab-tests][color_as_cielab Tests]]
      - [[#color_as_cielch][color_as_cielch]]
        - [[#color_as_cielch-examples][color_as_cielch Examples]]
        - [[#color_as_cielch-implementation][color_as_cielch Implementation]]
        - [[#color_as_cielch-tests][color_as_cielch Tests]]
      - [[#color_as_oklab][color_as_oklab]]
        - [[#color_as_oklab-examples][color_as_oklab Examples]]
        - [[#color_as_oklab-implementation][color_as_oklab Implementation]]
        - [[#color_as_oklab-tests][color_as_oklab Tests]]
      - [[#color_as_oklch][color_as_oklch]]
        - [[#color_as_oklch-examples][color_as_oklch Examples]]
        - [[#color_as_oklch-implementation][color_as_oklch Implementation]]
        - [[#color_as_oklch-tests][color_as_oklch Tests]]
      - [[#color_as_dyad][color_as_dyad]]
        - [[#color_as_dyad-examples][color_as_dyad Examples]]
        - [[#color_as_dyad-implementation][color_as_dyad Implementation]]
        - [[#color_as_dyad-tests][color_as_dyad Tests]]
      - [[#color_as_complementary][color_as_complementary]]
        - [[#color_as_complementary-examples][color_as_complementary Examples]]
        - [[#color_as_complementary-implementation][color_as_complementary Implementation]]
        - [[#color_as_complementary-tests][color_as_complementary Tests]]
      - [[#color_as_analogous][color_as_analogous]]
        - [[#color_as_analogous-examples][color_as_analogous Examples]]
        - [[#color_as_analogous-implementation][color_as_analogous Implementation]]
        - [[#color_as_analogous-tests][color_as_analogous Tests]]
      - [[#color_as_split][color_as_split]]
        - [[#color_as_split-examples][color_as_split Examples]]
        - [[#color_as_split-implementation][color_as_split Implementation]]
        - [[#color_as_split-tests][color_as_split Tests]]
      - [[#color_as_clash][color_as_clash]]
        - [[#color_as_clash-examples][color_as_clash Examples]]
        - [[#color_as_clash-implementation][color_as_clash Implementation]]
        - [[#color_as_clash-tests][color_as_clash Tests]]
      - [[#color_as_triad][color_as_triad]]
        - [[#color_as_triad-examples][color_as_triad Examples]]
        - [[#color_as_triad-implementation][color_as_triad Implementation]]
        - [[#color_as_triad-tests][color_as_triad Tests]]
      - [[#color_as_tetrad][color_as_tetrad]]
        - [[#color_as_tetrad-examples][color_as_tetrad Examples]]
        - [[#color_as_tetrad-implementation][color_as_tetrad Implementation]]
        - [[#color_as_tetrad-tests][color_as_tetrad Tests]]
      - [[#color_as_square][color_as_square]]
        - [[#color_as_square-examples][color_as_square Examples]]
        - [[#color_as_square-implementation][color_as_square Implementation]]
        - [[#color_as_square-tests][color_as_square Tests]]
      - [[#color_as_star][color_as_star]]
        - [[#color_as_star-examples][color_as_star Examples]]
        - [[#color_as_star-implementation][color_as_star Implementation]]
        - [[#color_as_star-tests][color_as_star Tests]]
      - [[#color_as_hexagon][color_as_hexagon]]
        - [[#color_as_hexagon-examples][color_as_hexagon Examples]]
        - [[#color_as_hexagon-implementation][color_as_hexagon Implementation]]
        - [[#color_as_hexagon-tests][color_as_hexagon Tests]]
      - [[#color_as_tints][color_as_tints]]
      - [[#color_as_tones][color_as_tones]]
      - [[#color_as_shades][color_as_shades]]
      - [[#color_as_material][color_as_material]]
      - [[#color_as_blend][color_as_blend]]
      - [[#color_as_interpolation][color_as_interpolation]]
      - [[#color_as_token][color_as_token]]
      - [[#color_as_element][color_as_element]]
      - [[#palette_shift][palette_shift]]
      - [[#palette_sort][palette_sort]]
      - [[#palette_filter][palette_filter]]
      - [[#palette_contrast][palette_contrast]]
      - [[#palette_daltonize][palette_daltonize]]
    - [[#modular-scale][Modular Scale]]
      - [[#ms_create][ms_create]]
      - [[#ms_modify][ms_modify]]
      - [[#ms_split][ms_split]]
      - [[#ms_format][ms_format]]
      - [[#ms_as_tokens][ms_as_tokens]]
      - [[#ms_as_element][ms_as_element]]
    - [[#design-tokens][Design Tokens]]
      - [[#tokens_as_css][tokens_as_css]]
      - [[#tokens_as_scss][tokens_as_scss]]
      - [[#tokens_as_less][tokens_as_less]]
      - [[#tokens_as_styl][tokens_as_styl]]
      - [[#tokens_as_json][tokens_as_json]]
      - [[#tokens_as_yaml][tokens_as_yaml]]
      - [[#tokens_as_gpl][tokens_as_gpl]]
      - [[#tokens_as_sketchpalette][tokens_as_sketchpalette]]
      - [[#tokens_as_tailwind][tokens_as_tailwind]]
      - [[#tokens_as_styledict][tokens_as_styledict]]
      - [[#tokens_as_element][tokens_as_element]]
  - [[#internals][Internals]]
    - [[#functional][Functional]]
      - [[#composition-internals][Composition Internals]]
    - [[#color-1][Color]]
      - [[#conversion][Conversion]]
        - [[#tokenization][Tokenization]]
        - [[#validation][Validation]]
        - [[#extraction][Extraction]]
        - [[#parsing][Parsing]]
        - [[#calculation][Calculation]]
        - [[#serialization][Serialization]]
      - [[#color-adjustment][Color Adjustment]]
        - [[#target-properties][Target Properties]]
        - [[#perceptually-uniform-color-adjustment][Perceptually Uniform Color Adjustment]]
        - [[#color-adjustment-through-oklch][Color Adjustment Through OKLCH]]
      - [[#color-mixture][Color Mixture]]
        - [[#perceptually-uniform-color-mixture][Perceptually Uniform Color Mixture]]
        - [[#color-mixture-through-oklab][Color Mixture Through OKLab]]
    - [[#modular-scale-internals][Modular Scale Internals]]
    - [[#design-token-internals][Design Token Internals]]

* Summary

This document is my scratchpad/workspace as I further refine QuarkSuite. Literate programming gives me a clear space to
think, iterate, and speculate on different approaches to my ultimate goal of a more enjoyable, flexible, and powerful
design token development environment for web projects.

* What's New in v2?

** Workflows

v1 focused on utilities as the base API and built abstractions (formulas, bootstrappers) on top of it. v2 focuses
*exclusively* on the relationship between types, their available actions, and output emitters.

Rather than providing the factory pattern, I've resolved to /further improve/ the functional workflow.

** Concrete Idioms

Where v1 differentiated between its abstractions with a host of naming conventions, v2 reinforces an idiomatic
relationship between functions and their purpose. The API now follows a simple, explicit naming convention.

+ =type_action(y, x)=: indicates that a function performs an action on =x= with =y= modifying the output
+ =type_as_output(x)=: indicates that a function emits output /directly from/ =x=

** Settled Types

+ =fn=: functional helpers
+ =color=: individual colors (of any valid CSS format)
+ =palette=: generated color palettes
+ =ms=: modular scales
+ =tokens=: token collections

** Simple Data Rendering

After fiddling with a lot of approaches for a UI library, I realized that QuarkSuite doesn't really need a full library
so much as ways to render data to a view. =type_as_element= is a new emitter in v2 that indicates the output will be
HTML rendered or a web component.

** WTCG Design Token Spec

I can transition away from my own Quarks System Dictionary spec in favor of [[https://design-tokens.github.io/community-group/format/][adopting an emerging community spec]]. You
love to see it.

** Improved Performance

The library is already pretty fast, but it could be faster. That in itself is enough for me to research ways to squeeze
a little more performance out of everything happening under the hood.

** Internal Simplicity

Up until now, QuarkSuite used some internal patterns and structure that at the time was some pretty clever code. At the
same time, this makes it a bit /too clever to debug effectively/. I'm being more judicious toward complexity and
limiting it to where it's needed.

** Improved Modularity

Where v1 kept its code in a single =mod.js= file, v2 splits the functionality into discrete modules associated with the
available types. This will make it easier to develop and debug while allowing more types to be added in the future.

In addition, the internal library has been expanded so that each utility exposed in the API is truly uncoupled from the
rest. This means that modern build tools, and environments that support tree shaking, will only pull in what's needed.

* Spec

The library begins with an entry point =mod.js= that aggregates all the functionality to make it easier to experiment
during development before you've settled on what you need. QuarkSuite v2 separates all functionality by its input type.

#+BEGIN_SRC js :tangle "./v2/mod.js" :comments both
// Package all utility types

export * as fn from "./fn.js";
export * as color from "./color.js";
export * as ms from "./ms.js";
export * as tokens from "./tokens.js";
#+END_SRC

** API

The API documentation follows specific formatting that will hopefully make it easier to understand.

#+BEGIN_QUOTE
Example:

=name(y, x) => unknown=
+ =y = {}: unknown=: modifier description
+ =x: unknown=: data description
#+END_QUOTE

*** Functional Utilities
:PROPERTIES:
:header-args:js: :tangle "./v2/fn.js" :comments both
:END:

**** fn_process

A functional utility that combines emitters into a process.

+ =fn_process(...emitters) => (x)=
  + =emitters: Array<(x)>=: sequence of emitters to combine

***** fn_process Examples

***** fn_process Implementation

#+BEGIN_SRC js
export function fn_process(...emitters) {
  return compose(...emitters);
}
#+END_SRC

***** fn_process Tests

***** fn_process Errors

**** fn_preset

A functional utility that accepts an action and its modifiers and converts it to an emitter.

+ =fn_preset(action, y) => (x)=
  + =action: (y, x) => unknown=: the action to transform
  + =y: unknown=: the action's associated modifiers

***** fn_preset Examples

***** fn_preset Implementation

#+BEGIN_SRC js
export function fn_preset(action, y) {
  return (x) => action(y, x);
}
#+END_SRC

***** fn_preset Tests

***** fn_preset Errors

**** fn_pipeline

A functional utility that shuttles data =x= through a process pipeline.

+ =fn_pipeline(x, ...processes) => unknown=
  + =x: unknown=: data to pipe
  + =processes: Array<(x)>=: sequence of processes to transform data

***** fn_pipeline Examples

***** fn_pipeline Implementation

#+BEGIN_SRC js
export function fn_pipeline(x, ...processes) {
  return compose(...processes)(x);
}
#+END_SRC

***** fn_pipeline Tests

***** fn_pipeline Errors

*** Color
:PROPERTIES:
:header-args:js: :tangle "./v2/color.js" :comments both
:END:

**** color_adjust

An action that adjusts the =properties= of a given valid CSS =color=. Positive property values will increase while
negative values will decrease.

+ =color_adjust(properties, color) => string=
  - =properties: {}=: the color properties to adjust
    * =properties.lightness = 0: number=: adjust the color's lightness (as a percentage)
    * =properties.chroma = 0: number=: adjust the color's chroma (as a percentage)
    * =properties.hue = 0: number=: adjust the color's hue (in degrees)
    * =properties.alpha = 0: number=: adjust the color's transparency (as a percentage)
  - =color: string=: the color to adjust

***** color_adjust Examples

***** color_adjust Implementation

#+BEGIN_SRC js
export function color_adjust(properties, color) {
  // Do nothing by default
  const { lightness = 0, chroma = 0, hue = 0, alpha = 0 } = properties;

  return colorAdjustment({ lightness, chroma, hue, alpha }, color);
}
#+END_SRC

***** color_adjust Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_adjust_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_adjust } from "../color.js";

describe("color_adjust(properties, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => color_adjust({}, "invalid")).toThrow();
  });

  it("should correctly adjust lightness of samples", () => {
    expect(color_adjust({ lightness: -25 }, "white")).toBe("#aeaeae");
    expect(color_adjust({ lightness: 25 }, "gray")).toBe("#cdcdcd");
    expect(color_adjust({ lightness: 50 }, "black")).toBe("#636363");
    expect(color_adjust({ lightness: -25 }, "red")).toBe("#a10000");
    expect(color_adjust({ lightness: 10 }, "orange")).toBe("#ffc644");
    expect(color_adjust({ lightness: -16 }, "yellow")).toBe("#cbc900");
    expect(color_adjust({ lightness: -32 }, "lime")).toBe("#009300");
    expect(color_adjust({ lightness: 16 }, "cyan")).toBe("#54ffff");
    expect(color_adjust({ lightness: 32 }, "blue")).toBe("#479dff");
    expect(color_adjust({ lightness: 24 }, "purple")).toBe("#cf5fcc");
    expect(color_adjust({ lightness: -24 }, "magenta")).toBe("#a900ad");
  });

  it("should correctly adjust chroma of samples", () => {
    expect(color_adjust({ chroma: 50 }, "white")).toBe("#ffdbfc");
    expect(color_adjust({ chroma: 50 }, "gray")).toBe("#bb5d7d");
    expect(color_adjust({ chroma: 75 }, "black")).toBe("#060000");
    expect(color_adjust({ chroma: -25 }, "red")).toBe("#e64a3b");
    expect(color_adjust({ chroma: -10 }, "orange")).toBe("#f6a941");
    expect(color_adjust({ chroma: -16 }, "yellow")).toBe("#fcfe66");
    expect(color_adjust({ chroma: -32 }, "lime")).toBe("#71f56a");
    expect(color_adjust({ chroma: -75 }, "cyan")).toBe("#e0e0e0");
    expect(color_adjust({ chroma: 32 }, "blue")).toBe("#1e00ff");
    expect(color_adjust({ chroma: 24 }, "purple")).toBe("#8d008f");
    expect(color_adjust({ chroma: -24 }, "magenta")).toBe("#f04bee");
  });

  it("should correctly adjust hue of samples", () => {
    expect(color_adjust({ hue: 30 }, "white")).toBe("#ffffff");
    expect(color_adjust({ hue: 60 }, "gray")).toBe("#808080");
    expect(color_adjust({ hue: 90 }, "black")).toBe("#000000");
    expect(color_adjust({ hue: 150 }, "red")).toBe("#00b48c");
    expect(color_adjust({ hue: 180 }, "orange")).toBe("#5bc0ff");
    expect(color_adjust({ hue: 210 }, "yellow")).toBe("#ffc2ff");
    expect(color_adjust({ hue: 240 }, "lime")).toBe("#ff6072");
    expect(color_adjust({ hue: 270 }, "cyan")).toBe("#f0e55d");
    expect(color_adjust({ hue: 300 }, "blue")).toBe("#0075a4");
    expect(color_adjust({ hue: 330 }, "purple")).toBe("#5e21a6");
    expect(color_adjust({ hue: 360 }, "magenta")).toBe("#ff00ff");
  });

  it("should correctly adjust alpha of samples", () => {
    expect(color_adjust({ alpha: -10 }, "white")).toBe("#ffffffe6");
    expect(color_adjust({ alpha: -20 }, "gray")).toBe("#808080cc");
    expect(color_adjust({ alpha: -30 }, "black")).toBe("#000000b3");
    expect(color_adjust({ alpha: -40 }, "red")).toBe("#ff000099");
    expect(color_adjust({ alpha: -50 }, "orange")).toBe("#ffa50080");
    expect(color_adjust({ alpha: -60 }, "yellow")).toBe("#ffff0066");
    expect(color_adjust({ alpha: -70 }, "lime")).toBe("#00ff004d");
    expect(color_adjust({ alpha: -80 }, "cyan")).toBe("#00ffff33");
    expect(color_adjust({ alpha: -90 }, "blue")).toBe("#0000ff1a");
    expect(color_adjust({ alpha: -100 }, "purple")).toBe("#80008000");
    expect(color_adjust({ alpha: -110 }, "magenta")).toBe("#ff00ff00");
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_adjust_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_adjust(properties, color)
  • should reject invalid colors
  • should correctly adjust lightness of samples
  • should correctly adjust chroma of samples
  • should correctly adjust hue of samples
  • should correctly adjust alpha of samples

running 5 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_adjust_test.js
test color_adjust(properties, color) > should reject invalid colors ... ok (16ms)
test color_adjust(properties, color) > should correctly adjust lightness of samples ... ok (30ms)
test color_adjust(properties, color) > should correctly adjust chroma of samples ... ok (14ms)
test color_adjust(properties, color) > should correctly adjust hue of samples ... ok (14ms)
test color_adjust(properties, color) > should correctly adjust alpha of samples ... ok (15ms)

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (133ms)

#+end_src

**** color_mix

An action that mixes an input =color= and a =target= color with a set level of =strength=.

+ =color_mix(settings, color) => string=
  - =settings: {}=: the mixture options to set
    * =settings.target = color: string=: set the target (any valid CSS color)
    * =settings.strength = 0: number=: set the strength (as a percentage, negative values reverse the direction)
  - =color: string=: the color to mix

***** color_mix Examples

***** color_mix Implementation

#+BEGIN_SRC js
export function color_mix(settings, color) {
  // Do nothing by default
  const { target = color, strength = 0 } = settings;

  return colorMix(color, target, strength);
}
#+END_SRC

***** color_mix Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_mix_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_adjust, color_mix } from "../color.js";

describe("color_mix(settings, color)", () => {
  const samples = [
    ["red", ["#ff0000", "#ff4b00", "#ff6e00", "#ff8b00", "#ffa500"], "orange"],
    [
      "orange",
      ["#ffa500", "#ffbc00", "#ffd200", "#ffe900", "#ffff00"],
      "yellow",
    ],
    ["yellow", ["#ffff00", "#daff00", "#b0ff00", "#7cff00", "#00ff00"], "lime"],
    ["lime", ["#00ff00", "#00ff74", "#00ffa9", "#00ffd6", "#00ffff"], "cyan"],
    ["cyan", ["#00ffff", "#00d1ff", "#00a0ff", "#006aff", "#0000ff"], "blue"],
    ["blue", ["#0000ff", "#381fde", "#5424be", "#6b1e9f", "#800080"], "purple"],
    [
      "purple",
      ["#800080", "#9e009e", "#bd00bd", "#de00de", "#ff00ff"],
      "magenta",
    ],
  ];

  const negations = [
    [
      "red",
      ["#ff0000", "#de5e58", "#b78087", "#8497b2", "#00a9db"],
      color_adjust({ hue: 180 }, "red"),
    ],
    [
      "orange",
      ["#ffa500", "#dfb172", "#bbb9a7", "#92bed4", "#5bc0ff"],
      color_adjust({ hue: 180 }, "orange"),
    ],
    [
      "yellow",
      ["#ffff00", "#fbf77c", "#f8eeb0", "#f6e4da", "#f4d8ff"],
      color_adjust({ hue: 180 }, "yellow"),
    ],
    [
      "lime",
      ["#00ff00", "#8ce77c", "#becbb0", "#e2aada", "#ff7dff"],
      color_adjust({ hue: 180 }, "lime"),
    ],
    [
      "cyan",
      ["#00ffff", "#8beeef", "#bddcdf", "#e2c9cf", "#ffb3bf"],
      color_adjust({ hue: 180 }, "cyan"),
    ],
    [
      "blue",
      ["#0000ff", "#383cc8", "#5e4592", "#803e5a", "#a02000"],
      color_adjust({ hue: 180 }, "blue"),
    ],
    [
      "purple",
      ["#800080", "#6f366a", "#5a4b52", "#3f5a37", "#006600"],
      color_adjust({ hue: 180 }, "purple"),
    ],
    [
      "magenta",
      ["#ff00ff", "#de72d5", "#b79ba9", "#85b774", "#00cd00"],
      color_adjust({ hue: 180 }, "magenta"),
    ],
  ];

  it("should reject an invalid color", () => {
    expect(() => color_mix({ target: "blue" }, "invalid")).toThrow();
  });

  it("should reject an invalid target", () => {
    expect(() => color_mix({ target: "invalid" }, "red")).toThrow();
  });

  it("should correctly mix samples", () => {
    samples.forEach(([color, results, target]) => {
      results.forEach((output, index) => {
        expect(color_mix({ target, strength: index * 25 }, color)).toBe(output);
      });
    });
  });

  it("should correctly negate opposites", () => {
    negations.forEach(([color, results, target]) => {
      results.forEach((output, index) => {
        expect(color_mix({ target, strength: index * 25 }, color)).toBe(output);
      });
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_mix_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_mix(settings, color)
  • should reject an invalid color
  • should reject an invalid target
  • should correctly mix samples
  • should correctly negate opposites

running 4 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_mix_test.js
test color_mix(settings, color) > should reject an invalid color ... ok (12ms)
test color_mix(settings, color) > should reject an invalid target ... ok (6ms)
test color_mix(settings, color) > should correctly mix samples ... ok (46ms)
test color_mix(settings, color) > should correctly negate opposites ... ok (53ms)

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (189ms)

#+end_src

**** color_as_hex

An emitter that accepts a valid CSS =color= and outputs its hexadecimal equivalent.

+ =color_as_hex(color) => string=
  + =color: string=: the color to convert

***** color_as_hex Examples

***** color_as_hex Implementation

#+BEGIN_SRC js
export function color_as_hex(color) {
  return serializeHex(convert(color, "hex"));
}
#+END_SRC

***** color_as_hex Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_hex_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_hex } from "../color.js";

describe("color_as_hex(color)", () => {
  const controlGroup = [
    ["black", "#000000"],
    ["gray", "#808080"],
    ["white", "#ffffff"],
  ];

  const samples = [
    ["red", "#ff0000"],
    ["orange", "#ffa500"],
    ["yellow", "#ffff00"],
    ["lime", "#00ff00"],
    ["cyan", "#00ffff"],
    ["blue", "#0000ff"],
    ["purple", "#800080"],
    ["magenta", "#ff00ff"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_hex("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_hex(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_hex(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_hex_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_hex(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_hex_test.js
test color_as_hex(color) > should reject invalid colors ... ok (14ms)
test color_as_hex(color) > should correctly convert the control group ... ok (14ms)
test color_as_hex(color) > should correctly convert the color samples ... ok (13ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (87ms)

#+end_src

**** color_as_rgb

An emitter that accepts a valid CSS =color= and outputs its RGB equivalent.

+ =color_as_rgb(color) => string=
  + =color: string=: the color to convert

***** color_as_rgb Examples

***** color_as_rgb Implementation

#+BEGIN_SRC js
export function color_as_rgb(color) {
  return serializeRgb(convert(color, "rgb"));
}
#+END_SRC

***** color_as_rgb Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_rgb_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_rgb } from "../color.js";

describe("color_as_rgb(color)", () => {
  const controlGroup = [
    ["black", "rgb(0, 0, 0)"],
    ["gray", "rgb(128, 128, 128)"],
    ["white", "rgb(255, 255, 255)"],
  ];

  const samples = [
    ["red", "rgb(255, 0, 0)"],
    ["orange", "rgb(255, 165, 0)"],
    ["yellow", "rgb(255, 255, 0)"],
    ["lime", "rgb(0, 255, 0)"],
    ["cyan", "rgb(0, 255, 255)"],
    ["blue", "rgb(0, 0, 255)"],
    ["purple", "rgb(128, 0, 128)"],
    ["magenta", "rgb(255, 0, 255)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_rgb("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_rgb(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_rgb(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_rgb_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_rgb(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_rgb_test.js
test color_as_rgb(color) > should reject invalid colors ... ok (14ms)
test color_as_rgb(color) > should correctly convert the control group ... ok (14ms)
test color_as_rgb(color) > should correctly convert the color samples ... ok (14ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (87ms)

#+end_src

**** color_as_hsl

An emitter that accepts a valid CSS =color= and outputs its HSL equivalent.

+ =color_as_hsl(color) => string=
  + =color: string=: the color to convert

***** color_as_hsl Examples

***** color_as_hsl Implementation

#+BEGIN_SRC js
export function color_as_hsl(color) {
  return serializeHsl(convert(color, "hsl"));
}
#+END_SRC

***** color_as_hsl Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_hsl_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_hsl } from "../color.js";

describe("color_as_hsl(color)", () => {
  const controlGroup = [
    ["black", "hsl(0, 0%, 0%)"],
    ["gray", "hsl(0, 0%, 50.196%)"],
    ["white", "hsl(0, 0%, 100%)"],
  ];

  const samples = [
    ["red", "hsl(0, 100%, 50%)"],
    ["orange", "hsl(38.824, 100%, 50%)"],
    ["yellow", "hsl(60, 100%, 50%)"],
    ["lime", "hsl(120, 100%, 50%)"],
    ["cyan", "hsl(180, 100%, 50%)"],
    ["blue", "hsl(240, 100%, 50%)"],
    ["purple", "hsl(300, 100%, 25.098%)"],
    ["magenta", "hsl(300, 100%, 50%)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_hsl("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_hsl(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_hsl(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_hsl_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_hsl(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_hsl_test.js
test color_as_hsl(color) > should reject invalid colors ... ok (16ms)
test color_as_hsl(color) > should correctly convert the control group ... ok (14ms)
test color_as_hsl(color) > should correctly convert the color samples ... ok (15ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (90ms)

#+end_src

**** color_as_cmyk

An emitter that accepts a valid CSS =color= and outputs its CMYK equivalent.

+ =color_as_cmyk(color) => string=
  + =color: string=: the color to convert

***** color_as_cmyk Examples

***** color_as_cmyk Implementation

#+BEGIN_SRC js
export function color_as_cmyk(color) {
  return serializeCmyk(convert(color, "cmyk"));
}
#+END_SRC

***** color_as_cmyk Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_cmyk_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_cmyk } from "../color.js";

describe("color_as_cmyk(color)", () => {
  const controlGroup = [
    ["black", "device-cmyk(0% 0% 0% 100%)"],
    ["gray", "device-cmyk(0% 0% 0% 49.804%)"],
    ["white", "device-cmyk(0% 0% 0% 0%)"],
  ];

  const samples = [
    ["red", "device-cmyk(0% 100% 100% 0%)"],
    ["orange", "device-cmyk(0% 35.294% 100% 0%)"],
    ["yellow", "device-cmyk(0% 0% 100% 0%)"],
    ["lime", "device-cmyk(100% 0% 100% 0%)"],
    ["cyan", "device-cmyk(100% 0% 0% 0%)"],
    ["blue", "device-cmyk(100% 100% 0% 0%)"],
    ["purple", "device-cmyk(0% 100% 0% 49.804%)"],
    ["magenta", "device-cmyk(0% 100% 0% 0%)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_cmyk("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_cmyk(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_cmyk(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_cmyk_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_cmyk(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_cmyk_test.js
test color_as_cmyk(color) > should reject invalid colors ... ok (15ms)
test color_as_cmyk(color) > should correctly convert the control group ... ok (14ms)
test color_as_cmyk(color) > should correctly convert the color samples ... ok (13ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (89ms)

#+end_src

**** color_as_hwb

An emitter that accepts a valid CSS =color= and outputs its HWB equivalent.

+ =color_as_hwb(color) => string=
  + =color: string=: the color to convert

***** color_as_hwb Examples

***** color_as_hwb Implementation

#+BEGIN_SRC js
export function color_as_hwb(color) {
  return serializeHwb(convert(color, "hwb"));
}
#+END_SRC

***** color_as_hwb Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_hwb_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_hwb } from "../color.js";

describe("color_as_hwb(color)", () => {
  const controlGroup = [
    ["black", "hwb(0 0% 100%)"],
    ["gray", "hwb(0 50.196% 49.804%)"],
    ["white", "hwb(0 100% 0%)"],
  ];

  const samples = [
    ["red", "hwb(0 0% 0%)"],
    ["orange", "hwb(38.824 0% 0%)"],
    ["yellow", "hwb(60 0% 0%)"],
    ["lime", "hwb(120 0% 0%)"],
    ["cyan", "hwb(180 0% 0%)"],
    ["blue", "hwb(240 0% 0%)"],
    ["purple", "hwb(300 0% 49.804%)"],
    ["magenta", "hwb(300 0% 0%)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_hwb("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_hwb(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_hwb(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_hwb_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_hwb(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_hwb_test.js
test color_as_hwb(color) > should reject invalid colors ... ok (16ms)
test color_as_hwb(color) > should correctly convert the control group ... ok (14ms)
test color_as_hwb(color) > should correctly convert the color samples ... ok (14ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (88ms)

#+end_src
**** color_as_cielab

An emitter that accepts a valid CSS =color= and outputs its CIELAB equivalent.

+ =color_as_cielab(color) => string=
  + =color: string=: the color to convert

***** color_as_cielab Examples

***** color_as_cielab Implementation

#+BEGIN_SRC js
export function color_as_cielab(color) {
  return serializeCielab(convert(color, "cielab"));
}
#+END_SRC

***** color_as_cielab Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_cielab_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_cielab } from "../color.js";

describe("color_as_cielab(color)", () => {
  const controlGroup = [
    ["black", "lab(0% 0 0)"],
    ["gray", "lab(53.585% 0 0)"],
    ["white", "lab(100% 0 0)"],
  ];

  const samples = [
    ["red", "lab(54.292% 80.812 69.885)"],
    ["orange", "lab(75.59% 27.519 79.116)"],
    ["yellow", "lab(97.607% -15.753 93.388)"],
    ["lime", "lab(87.818% -79.287 80.99)"],
    ["cyan", "lab(90.665% -50.665 -14.962)"],
    ["blue", "lab(29.568% 68.299 -112.029)"],
    ["purple", "lab(29.692% 56.118 -36.291)"],
    ["magenta", "lab(60.17% 93.55 -60.499)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_cielab("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_cielab(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_cielab(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_cielab_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_cielab(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_cielab_test.js
test color_as_cielab(color) > should reject invalid colors ... ok (14ms)
test color_as_cielab(color) > should correctly convert the control group ... ok (14ms)
test color_as_cielab(color) > should correctly convert the color samples ... ok (14ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (87ms)

#+end_src

**** color_as_cielch

An emitter that accepts a valid CSS =color= and outputs its CIELCH equivalent.

+ =color_as_cielch(color) => string=
  + =color: string=: the color to convert

***** color_as_cielch Examples

***** color_as_cielch Implementation

#+BEGIN_SRC js
export function color_as_cielch(color) {
  return serializeCielch(convert(color, "cielch"));
}
#+END_SRC

***** color_as_cielch Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_cielch_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_cielch } from "../color.js";

describe("color_as_cielch(color)", () => {
  const controlGroup = [
    ["black", "lch(0% 0 0)"],
    ["gray", "lch(53.585% 0 0)"],
    ["white", "lch(100% 0 0)"],
  ];

  const samples = [
    ["red", "lch(54.292% 106.839 40.853)"],
    ["orange", "lch(75.59% 83.766 70.821)"],
    ["yellow", "lch(97.607% 94.708 99.575)"],
    ["lime", "lch(87.818% 113.34 134.391)"],
    ["cyan", "lch(90.665% 52.828 196.452)"],
    ["blue", "lch(29.568% 131.207 301.369)"],
    ["purple", "lch(29.692% 66.83 327.109)"],
    ["magenta", "lch(60.17% 111.408 327.109)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_cielch("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_cielch(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_cielch(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_cielch_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_cielch(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_cielch_test.js
test color_as_cielch(color) > should reject invalid colors ... ok (14ms)
test color_as_cielch(color) > should correctly convert the control group ... ok (14ms)
test color_as_cielch(color) > should correctly convert the color samples ... ok (14ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (88ms)

#+end_src

**** color_as_oklab

An emitter that accepts a valid CSS =color= and outputs its OKLab equivalent.

+ =color_as_oklab(color) => string=
  + =color: string=: the color to convert

***** color_as_oklab Examples

***** color_as_oklab Implementation

#+BEGIN_SRC js
export function color_as_oklab(color) {
  return serializeOklab(convert(color, "oklab"));
}
#+END_SRC

***** color_as_oklab Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_oklab_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_oklab } from "../color.js";

describe("color_as_oklab(color)", () => {
  const controlGroup = [
    ["black", "oklab(0% 0 0)"],
    ["gray", "oklab(59.987% 0 0)"],
    ["white", "oklab(100% 0 0)"],
  ];

  const samples = [
    ["red", "oklab(62.796% 0.22486 0.12585)"],
    ["orange", "oklab(79.269% 0.05661 0.16138)"],
    ["yellow", "oklab(96.798% -0.07137 0.19857)"],
    ["lime", "oklab(86.644% -0.23389 0.1795)"],
    ["cyan", "oklab(90.54% -0.14944 -0.0394)"],
    ["blue", "oklab(45.201% -0.03246 -0.31153)"],
    ["purple", "oklab(42.091% 0.1647 -0.10147)"],
    ["magenta", "oklab(70.167% 0.27457 -0.16916)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_oklab("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_oklab(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_oklab(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_oklab_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_oklab(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_oklab_test.js
test color_as_oklab(color) > should reject invalid colors ... ok (15ms)
test color_as_oklab(color) > should correctly convert the control group ... ok (14ms)
test color_as_oklab(color) > should correctly convert the color samples ... ok (14ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (88ms)

#+end_src
**** color_as_oklch

An emitter that accepts a valid CSS =color= and outputs its OKLCH equivalent.

+ =color_as_oklch(color) => string=
  + =color: string=: the color to convert

***** color_as_oklch Examples

***** color_as_oklch Implementation

#+BEGIN_SRC js
export function color_as_oklch(color) {
  return serializeOklch(convert(color, "oklch"));
}
#+END_SRC

***** color_as_oklch Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_oklch_test.js" :comments both
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_oklch } from "../color.js";

describe("color_as_oklch(color)", () => {
  const controlGroup = [
    ["black", "oklch(0% 0 0)"],
    ["gray", "oklch(59.987% 0 0)"],
    ["white", "oklch(100% 0 0)"],
  ];

  const samples = [
    ["red", "oklch(62.796% 0.25768 29.234)"],
    ["orange", "oklch(79.269% 0.17103 70.67)"],
    ["yellow", "oklch(96.798% 0.21101 109.769)"],
    ["lime", "oklch(86.644% 0.29483 142.495)"],
    ["cyan", "oklch(90.54% 0.15455 194.769)"],
    ["blue", "oklch(45.201% 0.31321 264.052)"],
    ["purple", "oklch(42.091% 0.19345 328.363)"],
    ["magenta", "oklch(70.167% 0.32249 328.363)"],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_oklch("invalid")).toThrow();
  });

  it("should correctly convert the control group", () => {
    controlGroup.forEach(([input, output]) => {
      expect(color_as_oklch(input)).toBe(output);
    });
  });
  it("should correctly convert the color samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_oklch(input)).toBe(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_oklch_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_oklch(color)
  • should reject invalid colors
  • should correctly convert the control group
  • should correctly convert the color samples

running 3 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_oklch_test.js
test color_as_oklch(color) > should reject invalid colors ... ok (15ms)
test color_as_oklch(color) > should correctly convert the control group ... ok (14ms)
test color_as_oklch(color) > should correctly convert the color samples ... ok (14ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (88ms)

#+end_src

**** color_as_dyad

An emitter that accepts any valid CSS color and outputs a dyadic color scheme.

+ =color_as_dyad(color) => [string, string]=
  - =color: string=: the input color

***** color_as_dyad Examples

***** color_as_dyad Implementation

#+BEGIN_SRC js
export function color_as_dyad(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 90 }, color),
  ];
}
#+END_SRC

***** color_as_dyad Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_dyad_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_dyad } from "../color.js";

describe("color_as_dyad(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#7b9900"]],
    ["orange", ["#ffa500", "#23dc96"]],
    ["yellow", ["#ffff00", "#00ffff"]],
    ["lime", ["#00ff00", "#00e9ff"]],
    ["cyan", ["#00ffff", "#d5d0ff"]],
    ["blue", ["#0000ff", "#c00061"]],
    ["purple", ["#800080", "#931700"]],
    ["magenta", ["#ff00ff", "#ff3800"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_dyad("invalid")).toThrow();
  });

  it("should correctly emit dyads from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_dyad(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_dyad_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_dyad(color)
  • should reject invalid colors
  • should correctly emit dyads from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_dyad_test.js
test color_as_dyad(color) > should reject invalid colors ... ok (23ms)
test color_as_dyad(color) > should correctly emit dyads from samples ... ok (40ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (109ms)

#+end_src

**** color_as_complementary

An emitter that accepts any valid CSS color and outputs a complementary color scheme.

+ =color_as_complementary(color) => [string, string]=
  - =color: string=: the input color

***** color_as_complementary Examples

***** color_as_complementary Implementation

#+BEGIN_SRC js
export function color_as_complementary(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 180 }, color),
  ];
}
#+END_SRC

***** color_as_complementary Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_complementary_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_complementary } from "../color.js";

describe("color_as_complementary(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#00a9db"]],
    ["orange", ["#ffa500", "#5bc0ff"]],
    ["yellow", ["#ffff00", "#f4d8ff"]],
    ["lime", ["#00ff00", "#ff7dff"]],
    ["cyan", ["#00ffff", "#ffb3bf"]],
    ["blue", ["#0000ff", "#a02000"]],
    ["purple", ["#800080", "#006600"]],
    ["magenta", ["#ff00ff", "#00cd00"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_complementary("invalid")).toThrow();
  });

  it("should correctly emit complementary schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_complementary(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_complementary_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_complementary(color)
  • should reject invalid colors
  • should correctly emit complementary schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_complementary_test.js
test color_as_complementary(color) > should reject invalid colors ... ok (14ms)
test color_as_complementary(color) > should correctly emit complementary schemes from samples ... ok (37ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (96ms)

#+end_src

**** color_as_analogous

An emitter that accepts any valid CSS color and outputs an analogous color scheme.

+ =color_as_analogous(color) => [string, string, string]=
  - =color: string=: the input color

***** color_as_analogous Examples

***** color_as_analogous Implementation

#+BEGIN_SRC js
export function color_as_analogous(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 45 }, color),
    colorAdjustment({ hue: 45 * 2 }, color),
  ];
}
#+END_SRC

***** color_as_analogous Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_analogous_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_analogous } from "../color.js";

describe("color_as_analogous(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#de5f00", "#7b9900"]],
    ["orange", ["#ffa500", "#b7c826", "#23dc96"]],
    ["yellow", ["#ffff00", "#5bffb3", "#00ffff"]],
    ["lime", ["#00ff00", "#00fff5", "#00e9ff"]],
    ["cyan", ["#00ffff", "#72edff", "#d5d0ff"]],
    ["blue", ["#0000ff", "#8800d3", "#c00061"]],
    ["purple", ["#800080", "#9b002d", "#931700"]],
    ["magenta", ["#ff00ff", "#ff0061", "#ff3800"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_analogous("invalid")).toThrow();
  });

  it("should correctly emit analogous schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_analogous(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_analogous_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_analogous(color)
  • should reject invalid colors
  • should correctly emit analogous schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_analogous_test.js
test color_as_analogous(color) > should reject invalid colors ... ok (16ms)
test color_as_analogous(color) > should correctly emit analogous schemes from samples ... ok (42ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (103ms)

#+end_src

**** color_as_split

An emitter that accepts any valid CSS color and outputs a split complementary color scheme.

+ =color_as_split(color) => [string, string, string]=
  - =color: string=: the input color

***** color_as_split Examples

***** color_as_split Implementation

#+BEGIN_SRC js
export function color_as_split(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 180 - 30 }, color),
    colorAdjustment({ hue: 180 + 30 }, color),
  ];
}
#+END_SRC

***** color_as_split Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_split_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_split } from "../color.js";

describe("color_as_split(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#00b48c", "#0090ff"]],
    ["orange", ["#ffa500", "#00d2ff", "#a9acff"]],
    ["yellow", ["#ffff00", "#9cf3ff", "#ffc2ff"]],
    ["lime", ["#00ff00", "#df9eff", "#ff62e5"]],
    ["cyan", ["#00ffff", "#ffb4f8", "#ffbd87"]],
    ["blue", ["#0000ff", "#c50000", "#5d5c00"]],
    ["purple", ["#800080", "#475700", "#006a4e"]],
    ["magenta", ["#ff00ff", "#92b100", "#00d5a0"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_split("invalid")).toThrow();
  });

  it("should correctly emit split complementary schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_split(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_split_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_split(color)
  • should reject invalid colors
  • should correctly emit split complementary schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_split_test.js
test color_as_split(color) > should reject invalid colors ... ok (16ms)
test color_as_split(color) > should correctly emit split complementary schemes from samples ... ok (42ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (104ms)

#+end_src

**** color_as_clash


An emitter that accepts any valid CSS color and outputs a clash color scheme.

+ =color_as_clash(color) => [string, string, string]=
  - =color: string=: the input color

***** color_as_clash Examples

***** color_as_clash Implementation

#+BEGIN_SRC js
export function color_as_clash(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 90 }, color),
    colorAdjustment({ hue: 90 * 3 }, color),
  ];
}
#+END_SRC

***** color_as_clash Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_clash_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_clash } from "../color.js";

describe("color_as_clash(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#7b9900", "#a34fff"]],
    ["orange", ["#ffa500", "#23dc96", "#ff8cdc"]],
    ["yellow", ["#ffff00", "#00ffff", "#ffb3b9"]],
    ["lime", ["#00ff00", "#00e9ff", "#ff8300"]],
    ["cyan", ["#00ffff", "#d5d0ff", "#f0e55d"]],
    ["blue", ["#0000ff", "#c00061", "#008048"]],
    ["purple", ["#800080", "#931700", "#0051a8"]],
    ["magenta", ["#ff00ff", "#ff3800", "#00a6ff"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_clash("invalid")).toThrow();
  });

  it("should correctly emit clashing schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_clash(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_clash_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_clash(color)
  • should reject invalid colors
  • should correctly emit clashing schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_clash_test.js
test color_as_clash(color) > should reject invalid colors ... ok (15ms)
test color_as_clash(color) > should correctly emit clashing schemes from samples ... ok (42ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (104ms)

#+end_src

**** color_as_triad

An emitter that accepts any valid CSS color and outputs a triadic color scheme.

+ =color_as_triad(color) => [string, string, string]=
  - =color: string=: the input color

***** color_as_triad Examples

***** color_as_triad Implementation

#+BEGIN_SRC js
export function color_as_triad(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 120 }, color),
    colorAdjustment({ hue: 120 * 2 }, color),
  ];
}
#+END_SRC

***** color_as_triad Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_triad_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_triad } from "../color.js";

describe("color_as_triad(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#00ae00", "#4f6fff"]],
    ["orange", ["#ffa500", "#00dcd5", "#de99ff"]],
    ["yellow", ["#ffff00", "#00ffff", "#ffb3ff"]],
    ["lime", ["#00ff00", "#61c4ff", "#ff6072"]],
    ["cyan", ["#00ffff", "#ffbfff", "#ffd05c"]],
    ["blue", ["#0000ff", "#ce0000", "#007700"]],
    ["purple", ["#800080", "#773e00", "#006384"]],
    ["magenta", ["#ff00ff", "#ef8200", "#00c8ff"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_triad("invalid")).toThrow();
  });

  it("should correctly emit triadic schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_triad(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_triad_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_triad(color)
  • should reject invalid colors
  • should correctly emit triadic schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_triad_test.js
test color_as_triad(color) > should reject invalid colors ... ok (16ms)
test color_as_triad(color) > should correctly emit triadic schemes from samples ... ok (43ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (105ms)

#+end_src

**** color_as_tetrad

An emitter that accepts any valid CSS color and outputs a tetradic color scheme.

+ =color_as_tetrad(color) => [string, string, string, string]=
  - =color: string=: the input color

***** color_as_tetrad Examples

***** color_as_tetrad Implementation

#+BEGIN_SRC js
export function color_as_tetrad(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 45 }, color),
    colorAdjustment({ hue: 180 }, color),
    colorAdjustment({ hue: 180 + 45 }, color),
  ];
}
#+END_SRC

***** color_as_tetrad Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_tetrad_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_tetrad } from "../color.js";

describe("color_as_tetrad(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#de5f00", "#00a9db", "#0080ff"]],
    ["orange", ["#ffa500", "#b7c826", "#5bc0ff", "#c5a2ff"]],
    ["yellow", ["#ffff00", "#5bffb3", "#f4d8ff", "#ffb9ff"]],
    ["lime", ["#00ff00", "#00fff5", "#ff7dff", "#ff5cb0"]],
    ["cyan", ["#00ffff", "#72edff", "#ffb3bf", "#ffc56e"]],
    ["blue", ["#0000ff", "#8800d3", "#a02000", "#016c00"]],
    ["purple", ["#800080", "#9b002d", "#006600", "#00686b"]],
    ["magenta", ["#ff00ff", "#ff0061", "#00cd00", "#00d1d7"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_tetrad("invalid")).toThrow();
  });

  it("should correctly emit tetradic schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_tetrad(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_tetrad_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_tetrad(color)
  • should reject invalid colors
  • should correctly emit tetradic schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_tetrad_test.js
test color_as_tetrad(color) > should reject invalid colors ... ok (16ms)
test color_as_tetrad(color) > should correctly emit tetradic schemes from samples ... ok (48ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (111ms)

#+end_src

**** color_as_square

An emitter that accepts any valid CSS color and outputs a square color scheme.

+ =color_as_square(color) => [string, string, string, string]=
  - =color: string=: the input color

***** color_as_square Examples

***** color_as_square Implementation

#+BEGIN_SRC js
export function color_as_square(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 90 }, color),
    colorAdjustment({ hue: 90 * 2 }, color),
    colorAdjustment({ hue: 90 * 3 }, color),
  ];
}
#+END_SRC

***** color_as_square Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_square_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_square } from "../color.js";

describe("color_as_square(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#7b9900", "#00a9db", "#a34fff"]],
    ["orange", ["#ffa500", "#23dc96", "#5bc0ff", "#ff8cdc"]],
    ["yellow", ["#ffff00", "#00ffff", "#f4d8ff", "#ffb3b9"]],
    ["lime", ["#00ff00", "#00e9ff", "#ff7dff", "#ff8300"]],
    ["cyan", ["#00ffff", "#d5d0ff", "#ffb3bf", "#f0e55d"]],
    ["blue", ["#0000ff", "#c00061", "#a02000", "#008048"]],
    ["purple", ["#800080", "#931700", "#006600", "#0051a8"]],
    ["magenta", ["#ff00ff", "#ff3800", "#00cd00", "#00a6ff"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_square("invalid")).toThrow();
  });

  it("should correctly emit square schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_square(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_square_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_square(color)
  • should reject invalid colors
  • should correctly emit square schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_square_test.js
test color_as_square(color) > should reject invalid colors ... ok (16ms)
test color_as_square(color) > should correctly emit square schemes from samples ... ok (48ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (109ms)

#+end_src

**** color_as_star

An emitter that accepts any valid CSS color and outputs a star color scheme.

+ =color_as_star(color) => [string, string, string, string, string]=
  - =color: string=: the input color

***** color_as_star Examples

***** color_as_star Implementation

#+BEGIN_SRC js
export function color_as_star(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 72 }, color),
    colorAdjustment({ hue: 72 * 2 }, color),
    colorAdjustment({ hue: 72 * 3 }, color),
    colorAdjustment({ hue: 72 * 4 }, color),
  ];
}
#+END_SRC

***** color_as_star Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_star_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_star } from "../color.js";

describe("color_as_star(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#ac8500", "#00b47a", "#008aff", "#c43deb"]],
    ["orange", ["#ffa500", "#73d66d", "#00d5ff", "#b5a8ff", "#ff88ba"]],
    ["yellow", ["#ffff00", "#00ffff", "#85f8ff", "#ffbeff", "#ffbb85"]],
    ["lime", ["#00ff00", "#00faff", "#cca5ff", "#ff5fd1", "#ffa000"]],
    ["cyan", ["#00ffff", "#b1dcff", "#ffb6ff", "#ffc07c", "#cdf076"]],
    ["blue", ["#0000ff", "#ad0094", "#c90000", "#476300", "#007c82"]],
    ["purple", ["#800080", "#9a0000", "#535300", "#00695a", "#0043b3"]],
    ["magenta", ["#ff00ff", "#ff0000", "#aaa900", "#00d4b7", "#008cff"]],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_star("invalid")).toThrow();
  });

  it("should correctly emit star schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_star(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_star_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_star(color)
  • should reject invalid colors
  • should correctly emit star schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_star_test.js
test color_as_star(color) > should reject invalid colors ... ok (15ms)
test color_as_star(color) > should correctly emit star schemes from samples ... ok (54ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (115ms)

#+end_src

**** color_as_hexagon

An emitter that accepts any valid CSS color and outputs a hexagon color scheme.

+ =color_as_hexagon(color) => [string, string, string, string, string]=
  - =color: string=: the input color

***** color_as_hexagon Examples

***** color_as_hexagon Implementation

#+BEGIN_SRC js
export function color_as_hexagon(color) {
  return [
    colorAdjustment({ hue: 0 }, color),
    colorAdjustment({ hue: 60 }, color),
    colorAdjustment({ hue: 60 * 2 }, color),
    colorAdjustment({ hue: 60 * 3 }, color),
    colorAdjustment({ hue: 60 * 4 }, color),
    colorAdjustment({ hue: 60 * 5 }, color),
  ];
}
#+END_SRC

***** color_as_hexagon Tests

#+BEGIN_SRC js :tangle "./v2/tests/color_as_hexagon_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { color_as_hexagon } from "../color.js";

describe("color_as_hexagon(color)", () => {
  const samples = [
    ["red", ["#ff0000", "#c57500", "#00ae00", "#00a9db", "#4f6fff", "#d62fd2"]],
    [
      "orange",
      ["#ffa500", "#95d150", "#00dcd5", "#5bc0ff", "#de99ff", "#ff88a1"],
    ],
    [
      "yellow",
      ["#ffff00", "#00ffde", "#00ffff", "#f4d8ff", "#ffb3ff", "#ffc461"],
    ],
    [
      "lime",
      ["#00ff00", "#00ffff", "#61c4ff", "#ff7dff", "#ff6072", "#ffb400"],
    ],
    [
      "cyan",
      ["#00ffff", "#96e3ff", "#ffbfff", "#ffb3bf", "#ffd05c", "#b3f78b"],
    ],
    [
      "blue",
      ["#0000ff", "#9e00b2", "#ce0000", "#a02000", "#007700", "#0075a4"],
    ],
    [
      "purple",
      ["#800080", "#9c0000", "#773e00", "#006600", "#006384", "#253ab4"],
    ],
    [
      "magenta",
      ["#ff00ff", "#ff0000", "#ef8200", "#00cd00", "#00c8ff", "#527aff"],
    ],
  ];

  it("should reject invalid colors", () => {
    expect(() => color_as_hexagon("invalid")).toThrow();
  });

  it("should correctly emit hexagon schemes from samples", () => {
    samples.forEach(([input, output]) => {
      expect(color_as_hexagon(input)).toEqual(output);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color_as_hexagon_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  color_as_hexagon(color)
  • should reject invalid colors
  • should correctly emit hexagon schemes from samples

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color_as_hexagon_test.js
test color_as_hexagon(color) > should reject invalid colors ... ok (16ms)
test color_as_hexagon(color) > should correctly emit hexagon schemes from samples ... ok (61ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (123ms)

#+end_src

**** color_as_tints

**** color_as_tones

**** color_as_shades

**** color_as_material

**** color_as_blend

**** color_as_interpolation

**** color_as_token

**** color_as_element

**** palette_shift

**** palette_sort

**** palette_filter

**** palette_contrast

**** palette_daltonize

*** Modular Scale
:PROPERTIES:
:header-args:js: :tangle "./v2/ms.js" :comments both
:END:

**** ms_create

**** ms_modify

**** ms_split

**** ms_format

**** ms_as_tokens

**** ms_as_element

*** Design Tokens
:PROPERTIES:
:header-args:js: :tangle "./v2/tokens.js" :comments both
:END:

**** tokens_as_css

**** tokens_as_scss

**** tokens_as_less

**** tokens_as_styl

**** tokens_as_json

**** tokens_as_yaml

**** tokens_as_gpl

**** tokens_as_sketchpalette

**** tokens_as_tailwind

**** tokens_as_styledict

**** tokens_as_element

** Internals

*** Functional
:PROPERTIES:
:header-args:js: :tangle "./v2/fn.js" :comments both
:END:

**** Composition Internals

#+BEGIN_SRC js :tangle "./v2/fn.js"
function compose(...fns) {
  return (x) => fns.reduce((g, f) => f(g), x);
}
#+END_SRC

*** Color
:PROPERTIES:
:header-args:js: :tangle "./v2/color.js" :comments both
:END:

QuarkSuite accepts and processes most valid CSS color formats defined in [[https://www.w3.org/TR/css-color-4/][CSS Color Module Level 4]]. There are no color objects
to pass around, you just use the colors themselves and get colors back.

**** Conversion

Under the hood, a sequence of tokenization, validation, extraction, parsing, conversion, and serialization (mostly)
guarantees correct color input /and/ output. So wield those colors with confidence.

***** Tokenization

Color format tokenization follows the spec as closely as possible.

Then we have basic =NUMBER_TOKENS=, a =PERCENTAGE_TOKEN=, tokens for the legacy and modern =DELIMITERS=, a
=COMPONENT_TOKEN= combining the first two, and a =HUE_TOKEN=. That's all that's needed to account for every format
QuarkSuite supports.

#+BEGIN_SRC js
const NUMBER_TOKEN = /(?:-?(?!0\d)\d+(?:\.\d+)?)/;
const PERCENTAGE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "%)"].join(""),
);

const LEGACY_DELIMITER = /(?:[\s,]+)/;
const LEGACY_ALPHA_DELIMITER = new RegExp(
  LEGACY_DELIMITER.source.replace(",", ",/"),
);
const MODERN_DELIMITER = new RegExp(LEGACY_DELIMITER.source.replace(",", ""));
const MODERN_ALPHA_DELIMITER = new RegExp(
  LEGACY_ALPHA_DELIMITER.source.replace(",", ""),
);

const COMPONENT_TOKEN = new RegExp(
  ["(?:", PERCENTAGE_TOKEN.source, "|", NUMBER_TOKEN.source, ")"].join(""),
);
const HUE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "(?:deg|g?rad|turn)?)"].join(""),
);
#+END_SRC

***** Validation

Defining tokens will make validation of the functional color formats incredibly simple as the tokens can be combined
with the correct format prefix to create a full color string.

****** Named Color Validation

QuarkSuite supports CSS named colors through to CSS Color Module 4 using an object query.

#+BEGIN_SRC js
const NAMED_COLOR_KEYWORDS = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};

function namedValidator(color) {
  return Boolean(NAMED_COLOR_KEYWORDS[color]);
}
#+END_SRC

****** RGB Hex Validation

This can be done with a regular expression.

#+BEGIN_SRC js
function hexValidator(color) {
  return /^#([\da-f]{3,4}){1,2}$/i.test(color);
}
#+END_SRC

****** Validating Functional Formats

The functional formats require a bit of extra processing. Good thing we created those tokens earlier. Functional formats
always have an optional alpha component, so we tack that onto the end. If =legacy= is =true=, then we use the legacy
delimiters. Otherwise, we know it's a modern format.

Each format has varying components, so we map over the tokens we plug in and link them with delimiters.

#+BEGIN_SRC js
function matchFunctionalFormat({ prefix, legacy = true }, tokens) {
  const VALUES = tokens.map((token) => token.source);

  const DELIMITER = legacy ? LEGACY_DELIMITER.source : MODERN_DELIMITER.source;
  const ALPHA_DELIMITER = legacy
    ? LEGACY_ALPHA_DELIMITER.source
    : MODERN_ALPHA_DELIMITER.source;

  return new RegExp(
    `(?:^${prefix}\\(`.concat(
      VALUES.join(DELIMITER),
      `(?:${[ALPHA_DELIMITER, COMPONENT_TOKEN.source].join("")})?\\))`,
    ),
  );
}
#+END_SRC

******* RGB Validation

=matchFunctionalFormats= makes validating the remaining CSS formats a matter of slotting in tokens with the right
prefix. As you'll see, some tokens repeat and others have to be slotted individually.

#+BEGIN_SRC js
function rgbValidator(color) {
  return matchFunctionalFormat(
    { prefix: "rgba?" },
    Array(3).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

******* HSL Validation

#+BEGIN_SRC js
function hslValidator(color) {
  return matchFunctionalFormat({ prefix: "hsla?" }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENTAGE_TOKEN),
  ]).test(color);
}
#+END_SRC

******* CMYK Validation

=device-cmyk= is the first modern format, so the legacy flag will have to be disabled. It's also technically been moved
to CSS Color Module 5, but I implemented it before I found that out.

#+BEGIN_SRC js
function cmykValidator(color) {
  return matchFunctionalFormat(
    { prefix: "device-cmyk", legacy: false },
    Array(4).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

******* HWB Validation

#+BEGIN_SRC js
function hwbValidator(color) {
  return matchFunctionalFormat({ prefix: "hwb", legacy: false }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENTAGE_TOKEN),
  ]).test(color);
}
#+END_SRC

******* CIELAB/CIELCH Validation

These two formats are scalar and polar variants of the same color space, so I'll combine their validators.

#+BEGIN_SRC js
function cielabValidator(color) {
  return matchFunctionalFormat({ prefix: "lab", legacy: false }, [
    PERCENTAGE_TOKEN,
    ...Array(2).fill(NUMBER_TOKEN),
  ]).test(color);
}

function cielchValidator(color) {
  return matchFunctionalFormat({ prefix: "lch", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

******* OKLab/OKLCH Validation

Same with OKLab/OKLCH, which recently became standard so I reimplemented them according to the spec.

#+BEGIN_SRC js
function oklabValidator(color) {
  return matchFunctionalFormat({ prefix: "oklab", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    NUMBER_TOKEN,
  ]).test(color);
}

function oklchValidator(color) {
  return matchFunctionalFormat({ prefix: "oklch", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

****** Preparing Validation

From here, we'll implement a =validator()= that accepts input and checks it against all of the available formats. A valid
color will match /one of/ the available formats and get slotted in a =[format, color]= tuple.

#+BEGIN_SRC js
function validator(input) {
  const SUPPORTED_FORMATS = {
    named: namedValidator,
    hex: hexValidator,
    rgb: rgbValidator,
    hsl: hslValidator,
    cmyk: cmykValidator,
    hwb: hwbValidator,
    cielab: cielabValidator,
    cielch: cielchValidator,
    oklab: oklabValidator,
    oklch: oklchValidator,
  };

  return (
    Object.entries(SUPPORTED_FORMATS)
      .map(([format, test]) => [format, test(input) && input])
      .find(([, color]) => color) || InvalidColorError(input)
  );
}
#+END_SRC

****** Invalid Color Handling

Otherwise, the input does not match any of the available formats and throws a useful error.

#+BEGIN_SRC js
class InvalidColor extends Error {
  constructor(input, ...params) {
    super(...params);

    // Stack trace (for v8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, InvalidColor);
    }

    this.name = "Invalid Color Format";
    this.message = `
${"-".repeat(100)}
"${input}" is not a valid color.
${"-".repeat(100)}

Supported color formats:

- Named colors
- RGB Hex
- Functional RGB
- Functional HSL
- Functional CMYK
- Functional HWB
- Functional CIELAB/CIELCH
- Functional OKLab/OKLCH

Read more about these formats at: https://www.w3.org/TR/css-color-4/
${"=".repeat(100)}
`;
  }
}

function InvalidColorError(input) {
  return new InvalidColor(input);
}
#+END_SRC

***** Extraction

Once we're sure we have a valid color, we need to extract its components. Since CSS color formats really have just two
forms (hexadecimal and functional), that's how many extractors we need.

****** RGB Hex Extractor

For RGB Hex extraction, we need to consider that RGB colors can also come in the form =#RGB(A)=. So we'll use =expandHex()= to expand
those to a full =#RRGGBB(AA)=. And then we have =hexExtractor()= to do the extraction proper.

#+BEGIN_SRC js
function hexExtractor(color) {
  return expandHex(color).match(/[\da-f]{2}/gi);
}

function expandHex(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

****** Functional Format Extractor

Extracting from functional formats requires that the values be picked /with their units attached/. We'll need this
information for parsing them prior to format conversion.

This is done with =componentExtractor()=.

#+BEGIN_SRC js
function componentExtractor(color) {
  return color.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
}
#+END_SRC

****** Extraction Preparation

Now with all the parts in place, we'll create a general =extractor()= that consumes a valid color tuple. If the =format=
is =hex=, we'll call =hexExtractor()=, otherwise it's a functional format and must be handled by =componentExtractor()=.

We also need to do additional work if the =format= is =named=, so we pass its value in =NAMED_COLOR_KEYWORDS= through
=hexExtractor()=.

Note that we're also passing the extraction along in the =[format, components]= tuple form for additional parsing.

#+BEGIN_SRC js
function extractor(validated) {
  const [format, color] = validated;

  if (format === "named") {
    return ["hex", hexExtractor(NAMED_COLOR_KEYWORDS[color])];
  }

  if (format === "hex") {
    return ["hex", hexExtractor(color)];
  }

  return [format, componentExtractor(color)];
}
#+END_SRC

***** Parsing

Before we get into actual color conversion, we're going to parse the extracted values according to their format. In
other words, we're going break them down into a calculable state that we can pass along to each conversion function.

We're going to use the extraction tuple and create a parser for each format so there are no false positives.

But first...

****** Math

We're going to prepare some helpers for the necessary value conversions we'll need to perform.

******* Clamping Values

Before anything else, we'll need a helper to =clamp()= values between a =min= and =max=. Some values in functional
formats are capped, and others are not. We'll see which when we implement the serializer.

#+BEGIN_SRC js
function clamp(x, a, b) {
  if (x < a) {
    return a;
  }

  if (x > b) {
    return b;
  }

  return x;
}
#+END_SRC

******* Hex Fragment <-> Channel

Now, we're going to need to convert hex fragments to and from their RGB channel equivalents.

=16= is the /radix/ (or base) of hexadecimal, so we use =parseInt()= to convert the hex value to a decimal and
=toString()= to convert a decimal to hexadecimal.

#+BEGIN_SRC js
function hexFragmentToChannel(hex) {
  return parseInt(hex, 16);
}

function hexFragmentFromChannel(channel) {
  return clamp(channel, 0, 255).toString(16).padStart(2, "0");
}
#+END_SRC

******* Number <-> Percentage

Some functional formats will need to have their numbers converted to percentages or the reverse.

#+BEGIN_SRC js
function numberToPercentage(n) {
  return n * 100;
}

function numberFromPercentage(percentage) {
  return percentage / 100;
}
#+END_SRC

******* Number <-> Channel

RGB channels need to be converted to a =0-1= range to be useful in calculation. And then they need to be converted back
to channels later.

#+BEGIN_SRC js
function numberToChannel(n) {
  return Math.round(n * 255);
}

function numberFromChannel(channel) {
  return channel / 255;
}
#+END_SRC

******* Hue Component

Some of the color conversions require the [[https://www.rapidtables.com/convert/number/how-degrees-to-radians.html][hue as radians]]. And then we need to be able to [[https://www.rapidtables.com/convert/number/how-radians-to-degrees.html][convert back]].

The hue component also supports gradians and rotations, so we'll have to account for those as well to stay true to the
spec.

#+BEGIN_SRC js
function radiansToDegrees(radians) {
  return (radians * 180) / Math.PI;
}

function radiansFromDegrees(degrees) {
  return (degrees * Math.PI) / 180;
}

function gradiansToDegrees(gradians) {
  return gradians * (180 / 200);
}

function turnsToDegrees(turns) {
  return turns * 360;
}
#+END_SRC

******* Hue Correction

A stipulation of the hue component in the spec is that it must support hue values greater than a single revolution.

However, if it's to be useful in calculation, we must then /correct/ the value to a range =-360-360= or one full
rotation clockwise and counterclockwise. Our implmentation of =hueCorrection()= takes care of that.

#+BEGIN_SRC js
function hueCorrection(hue) {
  let h = hue;

  if (Math.sign(hue) === -1) {
    h = Math.abs(hue + 360);
  }

  if (hue > 360) {
    h = hue % 360;
  }

  return clamp(h, -360, 360);
}
#+END_SRC

****** Parsing RGB Hex

RGB Hex must be parsed as RGB channels to be mathematically useful. That's what =parseHex()= does.

If =A= is missing, then we attach it to ensure uniformity. Finally, we convert the hex fragments to RGB. The alpha
component needs additional handling.

#+BEGIN_SRC js
function parseHex([format, components]) {
  const [r, g, b, A] = components;

  const [R, G, B] = [r, g, b].map((fragment) => hexFragmentToChannel(fragment));

  if (A) {
    return [
      format,
      [R, G, B, numberFromChannel(hexFragmentToChannel(parseFloat(A)))],
    ];
  }

  return [format, [R, G, B, 1]];
}
#+END_SRC

****** Parsing Functional RGB

As stated above, RGB must be converted to a =0-1= range to be mathematically useful. This is a straightforward
conversion because of our =numberFromChannel()= helper. Meanwhile, percentage values are valid for =a=.

We check to see if =a= is a percentage value and convert it or leave it alone.

This is an operation we'll repeat multiple times during parsing, so it's captured in a =parsePercentage()= helper.

#+BEGIN_SRC js
function parsePercentage(component) {
  if (component.endsWith("%")) {
    return numberFromPercentage(parseFloat(component));
  }
  return parseFloat(component);
}

function parseRgb([format, components]) {
  const [r, g, b, A] = components;

  const [R, G, B] = [r, g, b].map((channel) => {
    if (channel.endsWith("%")) return parsePercentage(channel);
    return numberFromChannel(parseFloat(channel));
  });

  if (A) {
    return [format, [R, G, B, parsePercentage(A)]];
  }

  return [format, [R, G, B, 1]];
}
#+END_SRC

****** Parsing Functional HSL

The =h= component will need special processing depending on its units. And our conversion goal is /degrees/. Other than
that, =s= and =l= need conversion to a =0-1= range, and =A= is handled as usual.

Several formats beyond this point have a hue value, so we'll create a =parseHue()= helper to capture that logic.

#+BEGIN_SRC js
function parseHue(hue) {
  let HUE = parseFloat(hue);

  if (hue.endsWith("rad")) {
    HUE = radiansToDegrees(HUE);
  }

  if (hue.endsWith("grad")) {
    HUE = gradiansToDegrees(HUE);
  }

  if (hue.endsWith("turn")) {
    HUE = turnsToDegrees(HUE);
  }

  return hueCorrection(HUE);
}

function parseHsl([format, components]) {
  const [h, s, l, A] = components;

  let H = parseHue(h);

  const [S, L] = [s, l].map((percentage) =>
    numberFromPercentage(parseFloat(percentage))
  );

  if (A) {
    return [format, [H, S, L, parsePercentage(A)]];
  }

  return [format, [H, S, L, 1]];
}
#+END_SRC

****** Parsing Functional CMYK

Functional CMYK is dead simple to parse. We check to see if the components are percentages and convert them. Otherwise,
we coerce them to numbers with no additional processing.

#+BEGIN_SRC js
function parseCMYK([format, components]) {
  const [C, M, Y, K, A] = components.map((V) => {
    if (V.endsWith("%")) return parsePercentage(V);
    return parseFloat(V);
  });

  if (A) {
    return [format, [C, M, Y, K, A]];
  }

  return [format, [C, M, Y, K, 1]];
}
#+END_SRC

****** Parsing Functional HWB

Parsing functional HWB simply reuses =parseHSL()= because in this area they are /identical/.

****** Parsing Functional CIELAB/CIELCH

Of these two, the only one that requires any special attention is CIELCH because of that hue component. CIELAB just
passes its values through number coercion.

#+BEGIN_SRC js
function parseCielab([format, components]) {
  const [$L, $a, $b, A] = components;

  const [L, a, b] = [$L, $a, $b].map((component) => parseFloat(component));

  if (A) {
    return [format, [L, a, b, parsePercentage(A)]];
  }

  return [format, [L, a, b, 1]];
}

function parseCielch([format, components]) {
  const [$L, c, h, A] = components;

  const [L, C] = [$L, c].map((component) => parseFloat(component));
  const H = parseHue(h);

  if (A) {
    return [format, [L, C, H, parsePercentage(A)]];
  }

  return [format, [L, C, H, 1]];
}
#+END_SRC

****** Parsing OKLab/OKLCH

Parsing OKLab/OKLCH is similar to the above section, but it's important to note that OKLCH calculations expect the hue
in /radians/. =L= is also converted to a =0-1= range.

#+BEGIN_SRC js
function parseOklab([format, components]) {
  const [$L, $a, $b, A] = components;

  const L = parsePercentage($L);
  const [a, b] = [$a, $b].map((component) => parseFloat(component));

  if (A) {
    return [format, [L, a, b, parsePercentage(A)]];
  }

  return [format, [L, a, b, 1]];
}

function parseOklch([format, components]) {
  const [$L, c, h, A] = components;

  const L = parsePercentage($L);
  const C = parseFloat(c);
  const H = radiansFromDegrees(parseHue(h));

  if (A) {
    return [format, [L, C, H, parsePercentage(A)]];
  }

  return [format, [L, C, H, 1]];
}
#+END_SRC

****** Parsing Preparation

Similar to the validator and extractor, the =parser()= will read a color tuple and execute the correct parsing function
for a matched format. And then it throws back a transformed tuple of =[format, values]=.

#+BEGIN_SRC js
function parser(extracted) {
  const [format] = extracted;

  const FORMAT_PARSERS = {
    hex: parseHex,
    rgb: parseRgb,
    hsl: parseHsl,
    cmyk: parseCMYK,
    hwb: parseHsl, // identical to HSL
    cielab: parseCielab,
    cielch: parseCielch,
    oklab: parseOklab,
    oklch: parseOklch,
  };

  return FORMAT_PARSERS[format](extracted);
}
#+END_SRC

***** Calculation

Having completed our necessary preparations, we can finally move on to color conversion. QuarkSuite handles conversion
with a very precise method.

The idea: as a tool created for the web, and therefore largely for screens, every color used will eventually have to
pass through the sRGB gamut. This means that sRGB is our given /conversion anchor/.

With this in mind we can say color conversion is best structured as a pipeline where =INPUT -> RGB -> OUTPUT= routes
every input format to its targeted output format.

Some formats need to be linked into the pipeline. Specifically =Scalar <-> Polar= formats.

****** Preamble

To keep things simple, I'll keep using the color tuple data structure up until the point it's actually time to hand a
color back to the user. This is a *major* change from v1, where I attempted to reassemble the color within each conversion
function which sometimes led to wonky behavior from the pipeline.

It makes far more sense to keep passing along the raw conversions to the color tuple for serialization and make
reassembly an explicit, predictable step.

By this point, we're assuming the color has been validated, extracted, and correctly parsed. So we'll be passing along
the result of parsing as the color tuple =[format, values]=.

In the color conversion functions themselves, we'll be passing the results along as the =[format, results]= tuple.

****** RGB <-> RGB

Yes, we do have to account for RGB converting to and from itself, because the parsed RGB can't be serialized.

#+BEGIN_SRC js
function rgbInputIdentity([, values]) {
  const [r, g, b, A] = values;

  const [R, G, B] = [r, g, b].map((channel) => numberToChannel(channel));

  return ["rgb", [R, G, B, A]];
}

function rgbOutputIdentity([, rgbValues]) {
  return ["rgb", rgbValues];
}
#+END_SRC


****** INPUT -> RGB

The first process in the conversion pipeline is to take the =INPUT= format and convert it to =RGB=.

******* Hex -> RGB

If you remember from =parseHex()=, a parsed hexadecimal color is already a valid RGB result. So we mark it as such and pass it
through.

#+BEGIN_SRC js
function hexToRgb([, values]) {
  return ["rgb", values];
}
#+END_SRC

******* HSL -> RGB

To convert HSL to RGB, we use [[https://www.rapidtables.com/convert/color/hsl-to-rgb.html][this conversion formula from RapidTables]].

#+BEGIN_SRC js
function calculateRgb(C, X, H) {
  return new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);
}

function hslToRgb([, values]) {
  const [H, S, L, A] = values;

  // Calculate chroma
  const C = (1 - Math.abs(2 * L - 1)) * S;
  const X = C * (1 - Math.abs(((H / 60) % 2) - 1));
  const m = L - C / 2;

  const [R, G, B] = Array.from(calculateRgb(C, X, H))
    .find(([, condition]) => condition)
    .flatMap((result) => result)
    .map((n) => numberToChannel(n + m));

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* CMYK -> RGB

#+BEGIN_QUOTE
IMPORTANT: CSS Color Module 5 will use a device-independent conversion of CMYK through the CIELAB space. This means the
below approach is outdated. For practicality and compatibility's sake, I still use the old conversion method through
sRGB. Which works today.
#+END_QUOTE

#+BEGIN_QUOTE
UPDATE: The below approach is not outdated in CSS Color Module 5, but it is considered a /naive/ conversion. It works
well enough for the purposes of this library either way.
#+END_QUOTE

Conversion of CMYK to RGB is [[https://www.rapidtables.com/convert/color/cmyk-to-rgb.html][covered by another RapidTables formula]].

#+BEGIN_SRC js
function cmykToRgb([, values]) {
  const [C, M, Y, K, A] = values;

  const [R, G, B] = [C, M, Y].map((V) => numberToChannel((1 - V) * (1 - K)));

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* HWB -> RGB

The formula for conversion of HWB to RGB is [[https://www.w3.org/TR/css-color-4/#hwb-to-rgb][adapted from the spec itself]].

#+BEGIN_SRC js
function hwbToRgb([, values]) {
  const [H, W, BLK, A] = values;

  // Achromacity
  if (W + BLK >= 1) {
    let GRAY = numberToChannel(W / (W + BLK));

    return ["rgb", [Array(3).fill(GRAY), A]];
  }

  // Conversion
  const [, [r, g, b]] = hslToRgb(["hsl", [H, 1, 0.5, 1]]);
  const [R, G, B] = [r, g, b].map((channel) =>
    numberToChannel(numberFromChannel(channel) * (1 - W - BLK) + W)
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* CIELAB -> RGB

The steps for the CIELAB to RGB conversion are as follows:

1. Convert CIELAB to CIEXYZ
2. Convert CIEXYZ to LRGB
3. Convert LRGB to RGB

The actual equations are helpfully [[http://www.brucelindbloom.com/index.html?Math.html][provided by Bruce Lindbloom]].

#+BEGIN_SRC js
function cielabToCiexyz([L, a, b]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const WHITE = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const FY = (L + 16) / 116;
  const FX = a / 500 + FY;
  const FZ = FY - b / 200;

  // Calculate xyz
  const [X, Y, Z] = [
    FX ** 3 > ε ? FX ** 3 : (116 * FX - 16) / κ,
    L > κ * ε ? FY ** 3 : L / κ,
    FZ ** 3 > ε ? FZ ** 3 : (116 * FZ - 16) / κ,
  ].map((V, i) => V * WHITE[i]);

  return [X, Y, Z];
}

function ciexyzToLrgb([X, Y, Z]) {
  const D65_CHROMATIC_ADAPTATION = [
    [0.9555766, -0.0230393, 0.0631636],
    [-0.0282895, 1.0099416, 0.0210077],
    [0.0122982, -0.020483, 1.3299098],
  ];

  const LINEAR_RGB_TRANSFORMATION_MATRIX = [
    [3.2404542, -1.5371385, -0.4985314],
    [-0.969266, 1.8760108, 0.041556],
    [0.0556434, -0.2040259, 1.0572252],
  ];

  const [CX, CY, CZ] = D65_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => X * V1 + Y * V2 + Z * V3,
  );

  const [LR, LG, LB] = LINEAR_RGB_TRANSFORMATION_MATRIX.map(
    ([V1, V2, V3]) => CX * V1 + CY * V2 + CZ * V3,
  );

  return [LR, LG, LB];
}

function lrgbToRgb([LR, LG, LB]) {
  return [LR, LG, LB].map((V) =>
    V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055
  );
}

function cielabToRgb([, values]) {
  const [L, a, b, A] = values;

  const [R, G, B] = lrgbToRgb(ciexyzToLrgb(cielabToCiexyz([L, a, b]))).map(
    (n) => numberToChannel(n),
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* OKLAB -> RGB

The OKLab to RGB conversion steps are adapted from the creator, Björn Ottosson's, [[https://bottosson.github.io/posts/oklab/][original post about it]].

The process breaks down to:

1. Convert OKLab to LRGB
2. Convert LRGB to RGB

Simple and direct.

#+BEGIN_SRC js
function oklabToLrgb([L, a, b]) {
  const LINEAR_LMS_CONE_ACTIVATIONS = [
    [0.3963377774, 0.2158037573],
    [0.1055613458, 0.0638541728],
    [0.0894841775, 1.291485548],
  ];

  const OKLAB_TO_LRGB_MATRIX = [
    [4.076416621, 3.3077115913, 0.2309699292],
    [-1.2684380046, 2.6097574011, 0.3413193965],
    [-0.0041960863, 0.7034186147, 1.707614701],
  ];

  const [LONG, M, S] = LINEAR_LMS_CONE_ACTIVATIONS.map(([V1, V2], pos) => {
    if (pos === 0) return L + a * V1 + b * V2;
    if (pos === 1) return L - a * V1 - b * V2;
    return L - a * V1 - b * V2;
  }).map((V) => V ** 3);

  const [LR, LG, LB] = OKLAB_TO_LRGB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return LONG * V1 - M * V2 + S * V3;
    if (pos === 1) return LONG * V1 + M * V2 - S * V3;
    return LONG * V1 - M * V2 + S * V3;
  });

  return [LR, LG, LB];
}

function oklabToRgb([, values]) {
  const [L, a, b, A] = values;

  const [R, G, B] = lrgbToRgb(oklabToLrgb([L, a, b])).map((n) =>
    numberToChannel(n)
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

****** RGB -> OUTPUT

The next stage is to get the output format /from/ the RGB.

******* RGB -> Hex

Getting RGB to hexadecimal color output is a similarly stratightforward implementation.

Rounding the results is necessary because hexadecimal format expects integers. Having reached our target output, we can
now forward the result for serializing.

#+BEGIN_SRC js
function hexFromRgb([, rgbValues]) {
  const [r, g, b, a] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => hexFragmentFromChannel(channel));
  const A = hexFragmentFromChannel(numberToChannel(a));

  return ["hex", [R, G, B, A]];
}
#+END_SRC

******* RGB -> HSL

Getting RGB to an HSL output color is [[https://www.rapidtables.com/convert/color/rgb-to-hsl.html][handled by another RapidTables formula]].

#+BEGIN_SRC js
function calculateHue(R, G, B, cmax, delta) {
  return new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);
}

function calculateSaturation(delta, L) {
  return delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));
}

function calculateLightness(cmin, cmax) {
  return (cmax + cmin) / 2;
}

function hslFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const cmin = Math.min(R, G, B);
  const cmax = Math.max(R, G, B);
  const delta = cmax - cmin;

  const L = calculateLightness(cmin, cmax);
  const [H] = Array.from(calculateHue(R, G, B, cmax, delta)).find(
    ([, condition]) => condition,
  );
  const S = calculateSaturation(delta, L);

  return ["hsl", [H, S, L, A]];
}
#+END_SRC

******* RGB -> CMYK

Getting RGB to CMYK output [[https://www.rapidtables.com/convert/color/rgb-to-cmyk.html][requires yet another RapidTables formula]].

#+BEGIN_SRC js
function cmykFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const K = 1 - Math.max(R, G, B);
  const [C, M, Y] = [R, G, B].map((channel) => (1 - channel - K) / (1 - K));

  return ["cmyk", [C, M, Y, K, A]];
}
#+END_SRC

******* RGB -> HWB

The formula for converting RGB to HWB output is also [[https://www.w3.org/TR/css-color-4/#rgb-to-hwb][pulled from the spec]].

#+BEGIN_SRC js
function hwbFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const cmax = Math.max(R, G, B);
  const cmin = Math.min(R, G, B);
  const delta = cmax - cmin;

  const [H] = Array.from(calculateHue(R, G, B, cmax, delta)).find(
    ([, condition]) => condition,
  );

  const [W, BLK] = [cmin, 1 - cmax];

  return ["hwb", [H, W, BLK, A]];
}
#+END_SRC

******* RGB -> CIELAB

For getting CIELAB output from RGB, we'll be leaning on Bruce Lindbloom's equations again.

The process is as follows:

1. RGB to LRGB
2. LRGB to CIEXYZ
3. CIEXYZ to CIELAB

#+BEGIN_SRC js
function rgbToLrgb([R, G, B]) {
  return [R, G, B].map((V) =>
    V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4
  );
}

function lrgbToCiexyz([LR, LG, LB]) {
  const D65_REFERENCE_WHITE = [
    [0.4124564, 0.3575761, 0.1804375],
    [0.2126729, 0.7151522, 0.072175],
    [0.0193339, 0.119192, 0.9503041],
  ];

  const D50_CHROMATIC_ADAPTATION = [
    [1.0478112, 0.0228866, -0.050127],
    [0.0295424, 0.9904844, -0.0170491],
    [-0.0092345, 0.0150436, 0.7521316],
  ];

  const [x, y, z] = D65_REFERENCE_WHITE.map(
    ([V1, V2, V3]) => LR * V1 + LG * V2 + LB * V3,
  );

  const [X, Y, Z] = D50_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => x * V1 + y * V2 + z * V3,
  );

  return [X, Y, Z];
}

function ciexyzToCielab([X, Y, Z]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const D50_WHITE = [0.96422, 1.0, 0.82521];

  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z]
    .map((V, i) => V / D50_WHITE[i])
    .map((V) => (V > ε ? Math.cbrt(V) : (κ * V + 16) / 116));

  const [L, a, b] = [116 * FY - 16, 500 * (FX - FY), 200 * (FY - FZ)];

  return [L, a, b];
}

function cielabFromRgb([, rgbValues]) {
  const [r, g, $b, A] = rgbValues;

  const [R, G, B] = [r, g, $b].map((channel) => numberFromChannel(channel));
  const [L, a, b] = ciexyzToCielab(lrgbToCiexyz(rgbToLrgb([R, G, B])));

  return ["cielab", [L, a, b, A]];
}
#+END_SRC

******* RGB -> OKLAB

To get Oklab output from RGB, we're going to use the inversion also documented by its creator.

That process goes:

1. RGB to LRGB
2. LRGB to OKLAB

#+BEGIN_SRC js
function lrgbToOklab([LR, LG, LB]) {
  const NONLINEAR_LMS_CONE_ACTIVATIONS = [
    [0.4122214708, 0.5363325363, 0.0514459929],
    [0.2119034982, 0.6806995451, 0.1073969566],
    [0.0883024619, 0.2817188376, 0.6299787005],
  ];

  const RGB_OKLAB_MATRIX = [
    [0.2104542553, 0.793617785, 0.0040720468],
    [1.9779984951, 2.428592205, 0.4505937099],
    [0.0259040371, 0.7827717662, 0.808675766],
  ];

  const [L, M, S] = NONLINEAR_LMS_CONE_ACTIVATIONS.map(
    ([L, M, S]) => L * LR + M * LG + S * LB,
  ).map((V) => Math.cbrt(V));

  return RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return V1 * L + V2 * M - V3 * S;
    if (pos === 1) return V1 * L - V2 * M + V3 * S;
    return V1 * L + V2 * M - V3 * S;
  });
}

function oklabFromRgb([, rgbValues]) {
  const [r, g, $b, A] = rgbValues;

  const [R, G, B] = [r, g, $b].map((channel) => numberFromChannel(channel));
  const [L, a, b] = lrgbToOklab(rgbToLrgb([R, G, B]));

  return ["oklab", [L, a, b, A]];
}
#+END_SRC

****** SCALAR <-> POLAR

The last thing we need to do before wiring everything up is create a bridge to and from CIELAB & OKLab to their polar
coordinate alter-egos (CIELCH & OKLCH).

Since we already have a completed chain of =INPUT -> RGB -> OUTPUT= for both formats, we don't need to do much more.

The two basically [[https://www.w3.org/TR/css-color-4/#lab-to-lch][share formulas]], so I'm going to create the helpers =scalarToPolar()= and =scalarFromPolar=.

#+BEGIN_SRC js
function scalarToPolar([, scalarValues]) {
  const [L, a, b, A] = scalarValues;

  const C = Math.sqrt(a ** 2 + b ** 2);
  const H = Math.atan2(b, a);

  return [L, C, H, A];
}

function scalarFromPolar([, polarValues]) {
  const [L, C, H, A] = polarValues;

  const a = C * Math.cos(H);
  const b = C * Math.sin(H);

  return [L, a, b, A];
}
#+END_SRC

******* CIELAB <-> CIELCH

#+BEGIN_SRC js
function cielabToCielch([, cielabValues]) {
  return ["cielch", scalarToPolar(["cielab", cielabValues])];
}

function cielabFromCielch([, cielchValues]) {
  return ["cielab", scalarFromPolar(["cielch", cielchValues])];
}
#+END_SRC

******* OKLab <-> OKLCH

#+BEGIN_SRC js
function oklabToOklch([, oklabValues]) {
  return ["oklch", scalarToPolar(["oklab", oklabValues])];
}

function oklabFromOklch([, oklchValues]) {
  return ["oklab", scalarFromPolar(["oklch", oklchValues])];
}
#+END_SRC

****** Color Conversion Pipeline

Phew, now that we've prepared each individual format, it's time to construct the color conversion pipeline.

This will essentially be composed of two objects: =INPUT_TO_RGB= and =RGB_TO_OUTPUT= inside our main color =convert()=
function. You give it a color as input which then gets validated, has its components, extracted, and then parsed. The
parsed values are then passed along and converted to a specified output format.

#+BEGIN_SRC js
function convert(color, to) {
  // Let's make the pathway explicit
  const valid = validator(color);
  const extraction = extractor(valid);
  const [format, values] = parser(extraction);

  // Takes the input and converts it to RGB depending on format
  const INPUT_TO_RGB = (input) => ({
    named: hexToRgb(input),
    hex: hexToRgb(input),
    rgb: rgbInputIdentity(input), // identity
    hsl: hslToRgb(input),
    cmyk: cmykToRgb(input),
    hwb: hwbToRgb(input),
    cielab: cielabToRgb(input),
    cielch: cielabToRgb(cielabFromCielch(input)),
    oklab: oklabToRgb(input),
    oklch: oklabToRgb(oklabFromOklch(input)),
  });

  // Takes the RGB and converts to output target
  const RGB_TO_OUTPUT = (rgb) => ({
    hex: hexFromRgb(rgb),
    rgb: rgbOutputIdentity(rgb), // identity
    hsl: hslFromRgb(rgb),
    cmyk: cmykFromRgb(rgb),
    hwb: hwbFromRgb(rgb),
    cielab: cielabFromRgb(rgb),
    cielch: cielabToCielch(cielabFromRgb(rgb)),
    oklab: oklabFromRgb(rgb),
    oklch: oklabToOklch(oklabFromRgb(rgb)),
  });

  // Construct the pipeline
  const OUTPUT = RGB_TO_OUTPUT(INPUT_TO_RGB([format, values])[format])[to];

  return OUTPUT;
}
#+END_SRC

***** Serialization

All of that is well and good, but this leaves the converted color in a state that the user doesn't expect, and the
browser can't make any use of. That's why we have to /serialize/ the result.

Serialization is basically validation in reverse. We take the conversion data, perform the final bits of modification,
and then put it back into a color string and give it to the user. We want a different serialization method based on the
format, but we already have that information.

Now let's create the serialization functions.

****** Serializing RGB Hex

Concatenate the =hexResult= with a =#=. If the alpha channel is =ff=, the color is opaque and alpha should be removed.

#+BEGIN_SRC js
function serializeHex([, hexResult]) {
  const [R, G, B, A] = hexResult;

  if (A === "ff") {
    return "#".concat(R, G, B);
  }
  return "#".concat(R, G, B, A);
}
#+END_SRC

****** Serializing Functional Formats

Functional color formats have an incredibly uniform syntax, so let's create a helper =serializeFunctionalFormat()= to
logically assemble the data. It needs to be generic enough for us to simply attach a prefix and plug in values; similar
to =matchFunctionalFormat()= above.

#+BEGIN_SRC js
function serializeFunctionalFormat({ prefix, legacy = true }, components) {
  const DELIMITER = legacy ? ", " : " ";
  const ALPHA_DELIMITER = legacy ? ", " : " / ";

  // Coercing the result of toFixed() to a number preserves precision while removing trailing zeroes.
  const isOpaque = components[components.length - 1] === 1;
  const values = components.slice(0, components.length - 1);
  const alpha = (+components.slice(-1)).toFixed(3);

  return (legacy && !isOpaque ? `${prefix}a(` : `${prefix}(`).concat(
    values.join(DELIMITER),
    isOpaque ? "" : ALPHA_DELIMITER.concat(alpha),
    ")",
  );
}
#+END_SRC

******* Serializing RGB

#+BEGIN_SRC js
function serializeRgb([, rgbResult]) {
  const [r, g, b, A] = rgbResult;

  // Clamp RGB channels 0-255
  const [R, G, B] = [r, g, b].map(
    (component) => +clamp(component, 0, 255).toFixed(3),
  );

  return serializeFunctionalFormat({ prefix: "rgb" }, [R, G, B, A]);
}
#+END_SRC

******* Serializing HSL

#+BEGIN_SRC js
function serializeHsl([, hslResult]) {
  const [h, s, l, A] = hslResult;

  // Correct the hue result
  const H = hueCorrection(+h.toFixed(3));

  // convert saturation, lightness to percentages
  const [S, L] = [s, l].map((n) => `${+numberToPercentage(n).toFixed(3)}%`);

  return serializeFunctionalFormat({ prefix: "hsl" }, [H, S, L, A]);
}
#+END_SRC

******* Serializing CMYK

#+BEGIN_SRC js
function serializeCmyk([, cmykResult]) {
  const [c, m, y, k, A] = cmykResult;

  // Convert to percentage, cap at 0-100
  const [C, M, Y, K] = [c, m, y, k].map(
    (n) =>
      `${+clamp(numberToPercentage(isNaN(n) ? 0 : n), 0, 100).toFixed(3)}%`,
  );

  return serializeFunctionalFormat({ prefix: "device-cmyk", legacy: false }, [
    C,
    M,
    Y,
    K,
    A,
  ]);
}
#+END_SRC

******* Serializing HWB

#+BEGIN_SRC js
function serializeHwb([, hslResult]) {
  const [h, w, blk, A] = hslResult;

  // Correct the hue result
  const H = hueCorrection(+h.toFixed(3));

  // convert white, black to percentages
  const [W, BLK] = [w, blk].map((n) => `${+numberToPercentage(n).toFixed(3)}%`);

  return serializeFunctionalFormat({ prefix: "hwb", legacy: false }, [
    H,
    W,
    BLK,
    A,
  ]);
}
#+END_SRC

******* Serializing CIELAB/CIELCH

#+BEGIN_SRC js
function serializeCielab([, cielabValues]) {
  const [$L, $a, $b, A] = cielabValues;

  // Clamp lightness at 0-100
  const L = `${+clamp($L, 0, 100).toFixed(3)}%`;

  // Clamp a, b at ±127
  const [a, b] = [$a, $b].map((n) => +clamp(n, -127, 127).toFixed(3));

  return serializeFunctionalFormat({ prefix: "lab", legacy: false }, [
    L,
    a,
    b,
    A,
  ]);
}

function serializeCielch([, cielchValues]) {
  const [$L, c, h, A] = cielchValues;

  // Clamp lightness at 0-100
  const L = `${+clamp($L, 0, 100).toFixed(3)}%`;

  // Clamp chroma at 0-132
  const C = +clamp(c, 0, 132).toFixed(3);

  let H = h;

  // Hue is powerless if chroma is 0
  if (C === 0) {
    H = 0;
  } else {
    // Otherwise, convert hue to degrees, correct hue
    H = +hueCorrection(radiansToDegrees(h)).toFixed(3);
  }

  return serializeFunctionalFormat({ prefix: "lch", legacy: false }, [
    L,
    C,
    H,
    A,
  ]);
}
#+END_SRC

******* Serializing OKLab/OKLCH

#+BEGIN_SRC js
function serializeOklab([, oklabValues]) {
  const [$L, $a, $b, A] = oklabValues;

  // Convert number to percentage, clamp at 0-100
  const L = `${+clamp(numberToPercentage($L), 0, 100).toFixed(3)}%`;

  // Clamp a, b at ±0.5
  const [a, b] = [$a, $b].map((n) => +clamp(n, -0.5, 0.5).toFixed(5));

  return serializeFunctionalFormat({ prefix: "oklab", legacy: false }, [
    L,
    a,
    b,
    A,
  ]);
}

function serializeOklch([, oklchValues]) {
  const [$L, c, h, A] = oklchValues;

  // Convert lightness to percentage, clamp at 0-100
  const L = `${+clamp(numberToPercentage($L), 0, 100).toFixed(3)}%`;

  // Clamp chroma at 0-0.5
  const C = +clamp(c, 0, 0.5).toFixed(5);

  let H = h;

  // Hue is powerless if chroma is 0
  if (C === 0) {
    H = 0;
  } else {
    // Otherwise, convert hue to degrees, correct hue
    H = +hueCorrection(radiansToDegrees(h)).toFixed(3);
  }

  return serializeFunctionalFormat({ prefix: "oklch", legacy: false }, [
    L,
    C,
    H,
    A,
  ]);
}
#+END_SRC

**** Color Adjustment

Now that color conversion is handled, we can move on to color actions. The first necessary action we can perform on a
color is /adjustment/.

***** Target Properties

The properties we can adjust include:

+ Lightness/Luminance: The amount of light a color reflects or absorbs relative to its illuminant (light source). Though
  it's easier to think of it as how light or dark a given color is (with amounts >50 trending toward white and <50
  trending toward black).
+ Chroma/Saturation: A measure of a color's chromatic purity. Generally, a measure of color /intensity/ (with amounts
  >50 trending toward vivid and <50 trending toward subtle). An achromatic color will thereby be some shade of gray.
+ Hue: This can be thought of as a color's inherent quality. When we say light blue or muted yellow, the hue describes
  the way our eyes /perceive/ a given color. Hue is adjusted in terms of a wheel (where ±360 changes nothing and 180
  shifts hue to its opposite).
+ Alpha: A measure of how much light a color allows to pass through it (with amounts >50 trending toward solid and <50
  trending toward total transparency).

***** Perceptually Uniform Color Adjustment

Many color libraries allow you to choose the color space you want to adjust colors through or otherwise default to sRGB
as it's the most familiar to developers and digital designers.

This is the point where I emphasize that QuarkSuite is not a general purpose color manipulation library. QuarkSuite
allows color manipulation /only to the extent needed/ for practical color palette creation and modification. The sRGB
color space has some quirks that made it unreliable for sequential, predictable palette building.

Color properties in the sRGB space are not /orthogonal/. That is, a hue shift is also a lightness shift. Adjusting
lightness sometimes influences hue. Adjusting chroma sometimes made a color darker.

It's one of those things that didn't bother me much as a designer but became an immediate problem when developing a
tool; these small, subtle shifts led to weird behavior when replicated at scale. It also made predictable color blending
an exercise in frustration.

***** Color Adjustment Through OKLCH

OKLab solved the above issues. As an offshoot of CIELAB, perceptual uniformity is baked into its calculations. As an
/improvement/ on CIELAB, these calculations were adjusted for increased practicality and predictability. In short, it
made sequential palette building both possible and simpler.

Its OKLCH polar form is also vastly more intuitive for color property adjustment than its raw OKLab scalar form.

The approach in steps:

1. Convert the input color to OKLCH equivalent
2. Adjust its target properties
3. Convert result back to its input format

#+BEGIN_SRC js
function extractOklchValues(color) {
  const convertedOklch = serializeOklch(convert(color, "oklch"));
  const [, components] = extractor(["oklch", convertedOklch]);

  return components.map((V) => parseFloat(V));
}

function adjustColorProperties(
  { lightness, chroma, hue, alpha },
  [l, c, h, a],
) {
  // Adjust properties only if defined, make values parseable
  let L = numberFromPercentage(lightness ? l + lightness : l);
  let C = chroma ? c + numberFromPercentage(chroma) * 0.5 * 0.5 : c;
  let H = radiansFromDegrees(hue ? hueCorrection(h + hue) : h);
  let A = alpha ? (a ?? 1) + numberFromPercentage(alpha) : a ?? 1;

  // Return adjusted values
  return [L, C, H, A];
}

function serializeInput([format, values]) {
  const SERIALIZATION_TARGETS = {
    hex: serializeHex,
    rgb: serializeRgb,
    hsl: serializeHsl,
    cmyk: serializeCmyk,
    hwb: serializeHwb,
    cielab: serializeCielab,
    cielch: serializeCielch,
    oklab: serializeOklab,
    oklch: serializeOklch,
  };

  return SERIALIZATION_TARGETS[format]([format, values]);
}

function colorAdjustment(
  { lightness = 0, chroma = 0, hue = 0, alpha = 0 },
  color,
) {
  // Ensure color is valid and store its format
  const [format] = validator(color);

  // Extract its OKLCH values
  const values = extractOklchValues(color);

  // Adjust target properties
  const [L, C, H, A] = adjustColorProperties(
    { lightness, chroma, hue, alpha },
    values,
  );

  // Serialize oklch result
  const oklch = serializeOklch(["oklch", [L, C, H, A]]);

  // If input format is named, convert to hex
  if (format === "named") {
    return serializeInput(convert(oklch, "hex"));
  }

  // Otherwise use input format
  return serializeInput(convert(oklch, format));
}
#+END_SRC

**** Color Mixture

The second important color action is mixture (or blending). This is when we take a color and, well, mix it with another
color. This allows us to create colors for serving as natural gradient stops or to create /true/ tints, tones, and
shades from a color.

***** Perceptually Uniform Color Mixture

Similar to color adjustment, all color mixture happens through the OKLab space. The main advantage of using OKLab in
this area is that it yields smooth, even blending. This is most evident when blending blue with white.

When I attempted color mixing through the sRGB space, I wouldn't always get the expected results. Especially when mixing
colors of high chroma with those of low. This often resulted in the high chroma color looking slightly washed out or
(depending on the strength of the mixture) the low chroma color overwriting the high chroma.

Either way, the results didn't seem like true blends to my eyes (even if they were mathematically correct).

***** Color Mixture Through OKLab

In the area of color mixture, raw scalar OKLab is the ideal tool. This is because when we talk about color blending,
we're actually talking about /color difference/.

A color blend is what you get when you calculate the difference of a blending =target= from an input =color= adjusted for the =strength=
of the mixture. Returning the difference gives you the point of intersection, which is also the blend result.

The process goes:

1. Convert the blend target and input color to OKLab
2. Parse the OKLab values
3. Calculate the blend result (as =X + (Y - X) * strength=) for the individual components
4. Revert the result to the input color format and return it

Note that we also added a condition to reverse the mixture direction if =strength= is negative.

#+BEGIN_SRC js
function getOklabValues(color) {
  return convert(color, "oklab");
}

function calculateMixture(color, target, strength) {
  // convert blend target and input color to OKLab
  const [, [$L, $a, $b, $A]] = getOklabValues(color);
  const [, [$$L, $$a, $$b, $$A]] = getOklabValues(target);

  // calculate the blend result
  const [L, a, b, A] = [
    [$L, $$L],
    [$a, $$a],
    [$b, $$b],
    [$A, $$A],
  ].map(([X, Y]) => {
    // if -strength, blend FROM target
    // --------------------------------------------------------------
    // Note: Object.is() is a handy way to explicitly check for a strength of -0, which
    // should also trigger a blend inversion. This is not caught by Math.sign() alone,
    // because the way JS treats signed zeroes is identical.
    //
    // Which also means `Math.sign(strength) === -0` didn't work either.
    if (Math.sign(strength) === -1 || Object.is(strength, -0)) {
      return Y + (X - Y) * Math.abs(strength);
    }

    // Otherwise, blend TO target
    return X + (Y - X) * strength;
  });

  return [L, a, b, A];
}

function colorMix(color, target, strength) {
  // Validate input color and store its format
  const [format] = validator(color);

  // Calculate blend
  const [L, a, b, A] = calculateMixture(
    color,
    target,
    numberFromPercentage(strength),
  );

  // Serialize the blend result
  const oklab = serializeOklab(["oklab", [L, a, b, A]]);

  if (format === "named") {
    return serializeInput(convert(oklab, "hex"));
  }

  return serializeInput(convert(oklab, format));
}
#+END_SRC

*** Modular Scale Internals

*** Design Token Internals
