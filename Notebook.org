#+TITLE: QuarkSuite (v2)
#+PROPERTY: header-args:deno :tangle no
#+PROPERTY: header-args:js :tangle yes :mkdirp yes

* Table of Contents :TOC@5:
- [[#summary][Summary]]
- [[#whats-new-in-v2][What's New in v2?]]
  - [[#workflows][Workflows]]
  - [[#concrete-idioms][Concrete Idioms]]
  - [[#settled-types][Settled Types]]
  - [[#simple-data-rendering][Simple Data Rendering]]
  - [[#wtcg-design-token-spec][WTCG Design Token Spec]]
  - [[#improved-performance][Improved Performance]]
  - [[#internal-simplicity][Internal Simplicity]]
- [[#spec][Spec]]
  - [[#api][API]]
    - [[#functional-utilities][Functional Utilities]]
      - [[#fn_process][fn_process]]
        - [[#fn_process-examples][fn_process Examples]]
        - [[#fn_process-implementation][fn_process Implementation]]
        - [[#fn_process-tests][fn_process Tests]]
        - [[#fn_process-errors][fn_process Errors]]
      - [[#fn_preset][fn_preset]]
        - [[#fn_preset-examples][fn_preset Examples]]
        - [[#fn_preset-implementation][fn_preset Implementation]]
        - [[#fn_preset-tests][fn_preset Tests]]
        - [[#fn_preset-errors][fn_preset Errors]]
      - [[#fn_pipeline][fn_pipeline]]
        - [[#fn_pipeline-examples][fn_pipeline Examples]]
        - [[#fn_pipeline-implementation][fn_pipeline Implementation]]
        - [[#fn_pipeline-tests][fn_pipeline Tests]]
        - [[#fn_pipeline-errors][fn_pipeline Errors]]
    - [[#color][Color]]
      - [[#color_adjust][color_adjust]]
      - [[#color_mix][color_mix]]
      - [[#color_as_hex][color_as_hex]]
      - [[#color_as_rgb][color_as_rgb]]
      - [[#color_as_hsl][color_as_hsl]]
      - [[#color_as_cmyk][color_as_cmyk]]
      - [[#color_as_hwb][color_as_hwb]]
      - [[#color_as_lab][color_as_lab]]
      - [[#color_as_lch][color_as_lch]]
      - [[#color_as_oklab][color_as_oklab]]
      - [[#color_as_oklch][color_as_oklch]]
      - [[#color_as_dyad][color_as_dyad]]
      - [[#color_as_complementary][color_as_complementary]]
      - [[#color_as_analogous][color_as_analogous]]
      - [[#color_as_split][color_as_split]]
      - [[#color_as_clash][color_as_clash]]
      - [[#color_as_triad][color_as_triad]]
      - [[#color_as_tetrad][color_as_tetrad]]
      - [[#color_as_square][color_as_square]]
      - [[#color_as_star][color_as_star]]
      - [[#color_as_hexagon][color_as_hexagon]]
      - [[#color_as_tints][color_as_tints]]
      - [[#color_as_tones][color_as_tones]]
      - [[#color_as_shades][color_as_shades]]
      - [[#color_as_material][color_as_material]]
      - [[#color_as_blend][color_as_blend]]
      - [[#color_as_interpolation][color_as_interpolation]]
      - [[#color_as_token][color_as_token]]
      - [[#color_as_element][color_as_element]]
      - [[#palette_shift][palette_shift]]
      - [[#palette_sort][palette_sort]]
      - [[#palette_filter][palette_filter]]
      - [[#palette_contrast][palette_contrast]]
      - [[#palette_daltonize][palette_daltonize]]
    - [[#modular-scale][Modular Scale]]
      - [[#ms_create][ms_create]]
      - [[#ms_modify][ms_modify]]
      - [[#ms_split][ms_split]]
      - [[#ms_format][ms_format]]
      - [[#ms_as_tokens][ms_as_tokens]]
      - [[#ms_as_element][ms_as_element]]
    - [[#design-tokens][Design Tokens]]
      - [[#tokens_as_css][tokens_as_css]]
      - [[#tokens_as_scss][tokens_as_scss]]
      - [[#tokens_as_less][tokens_as_less]]
      - [[#tokens_as_styl][tokens_as_styl]]
      - [[#tokens_as_json][tokens_as_json]]
      - [[#tokens_as_yaml][tokens_as_yaml]]
      - [[#tokens_as_gpl][tokens_as_gpl]]
      - [[#tokens_as_sketchpalette][tokens_as_sketchpalette]]
      - [[#tokens_as_tailwind][tokens_as_tailwind]]
      - [[#tokens_as_styledict][tokens_as_styledict]]
      - [[#tokens_as_element][tokens_as_element]]
  - [[#internals][Internals]]
    - [[#functional][Functional]]
      - [[#composition-internals][Composition Internals]]
    - [[#color-1][Color]]
      - [[#tokenization][Tokenization]]
      - [[#validation][Validation]]
        - [[#named-color-validation][Named Color Validation]]
        - [[#rgb-hex-validation][RGB Hex Validation]]
        - [[#functional-formats][Functional Formats]]
        - [[#preparing-validation][Preparing Validation]]
        - [[#invalid-color-handling][Invalid Color Handling]]
      - [[#extraction][Extraction]]
        - [[#rgb-hex-extractor][RGB Hex Extractor]]
        - [[#functional-format-extractor][Functional Format Extractor]]
        - [[#extraction-preparation][Extraction Preparation]]
      - [[#parsing][Parsing]]
        - [[#math][Math]]
        - [[#parsing-rgb-hex][Parsing RGB Hex]]
        - [[#parsing-functional-rgb][Parsing Functional RGB]]
        - [[#parsing-functional-hsl][Parsing Functional HSL]]
        - [[#parsing-functional-cmyk][Parsing Functional CMYK]]
        - [[#parsing-functional-hwb][Parsing Functional HWB]]
        - [[#parsing-functional-cielabcielch][Parsing Functional CIELAB/CIELCH]]
        - [[#parsing-oklaboklch][Parsing OKLab/OKLCH]]
        - [[#parsing-preparation][Parsing Preparation]]
      - [[#conversion][Conversion]]
        - [[#preamble][Preamble]]
        - [[#input---rgb][INPUT -> RGB]]
        - [[#rgb---output][RGB -> OUTPUT]]
        - [[#scalar---polar][SCALAR <-> POLAR]]
        - [[#color-conversion-pipeline][Color Conversion Pipeline]]
      - [[#serialization][Serialization]]
    - [[#modular-scale-internals][Modular Scale Internals]]
    - [[#design-token-internals][Design Token Internals]]

* Summary

This document is my scratchpad/workspace as I further refine QuarkSuite. Literate programming gives me a clear space to
think, iterate, and speculate on different approaches to my ultimate goal of a more enjoyable, flexible, and powerful
design token development environment for web projects.

* What's New in v2?

** Workflows

v1 focused on utilities as the base API and built abstractions (formulas, bootstrappers) on top of it. v2 focuses
*exclusively* on the relationship between types, their available actions, and output emitters.

Rather than providing the factory pattern, I've resolved to /further improve/ the functional workflow.

** Concrete Idioms

Where v1 differentiated between its abstractions with a host of naming conventions, v2 reinforces an idiomatic
relationship between functions and their purpose. The API now follows a simple, explicit naming convention.

+ =type_action(y, x)=: indicates that a function performs an action on =x= with =y= modifying the output
+ =type_as_output(x)=: indicates that a function emits output /directly from/ =x=

** Settled Types

+ =fn=: functional helpers
+ =color=: individual colors (of any valid CSS format)
+ =palette=: generated color palettes
+ =ms=: modular scales
+ =tokens=: token collections

** Simple Data Rendering

After fiddling with a lot of approaches for a UI library, I realized that QuarkSuite doesn't really need a full library
so much as ways to render data to a view. =type_as_element= is a new emitter in v2 that indicates the output will be
HTML rendered or a web component.


** WTCG Design Token Spec

I can transition away from my own Quarks System Dictionary spec in favor of [[https://design-tokens.github.io/community-group/format/][adopting an emerging community spec]]. You
love to see it.

** Improved Performance

The library is already pretty fast, but it could be faster. That in itself is enough for me to research ways to squeeze
a little more performance out of everything happening under the hood.

** Internal Simplicity

Up until now, QuarkSuite used some internal patterns and structure that at the time was some pretty clever code. At the
same time, this makes it a bit /too clever to debug effectively/. I'm being more judicious toward complexity and
limiting it to where it's needed.

* Spec

The library begins with an entry point =mod.js= that aggregates all the functionality to make it easier to experiment
during development before you've settled on what you need. QuarkSuite v2 separates all functionality by its input type.

#+BEGIN_SRC js :tangle "./v2/mod.js" :comments both
// Package all utility types

export * as fn from "./fn.js";
export * as color from "./color.js";
export * as ms from "./ms.js";
export * as tokens from "./tokens.js";
#+END_SRC

** API

The API documentation follows specific formatting that will hopefully make it easier to understand.

#+BEGIN_QUOTE
/Example/:

=name(y, x) => unknown=
+ =y = {}: unknown=: modifier description
+ =x: unknown=: data description
#+END_QUOTE

*** Functional Utilities
:PROPERTIES:
:header-args:js: :tangle "./v2/fn.js" :comments both
:END:

**** fn_process

A functional utility that combines emitters into a process.

+ =fn_process(...emitters) => (x)=
  + =emitters: Array<(x)>=: sequence of emitters to combine

***** fn_process Examples

***** fn_process Implementation

#+BEGIN_SRC js
export function fn_process(...emitters) {
  return compose(...emitters);
}
#+END_SRC

***** fn_process Tests

***** fn_process Errors

**** fn_preset

A functional utility that accepts an action and its modifiers and converts it to an emitter.

+ =fn_preset(action, y) => (x)=
  + =action: (y, x) => unknown=: the action to transform
  + =y: unknown=: the action's associated modifiers

***** fn_preset Examples

***** fn_preset Implementation

#+BEGIN_SRC js
export function fn_preset(action, y) {
  return (x) => action(y, x);
}
#+END_SRC

***** fn_preset Tests

***** fn_preset Errors

**** fn_pipeline

A functional utility that shuttles data =x= through a process pipeline.

+ =fn_pipeline(x, ...processes) => unknown=
  + =x: unknown=: data to pipe
  + =processes: Array<(x)>=: sequence of processes to transform data

***** fn_pipeline Examples

***** fn_pipeline Implementation

#+BEGIN_SRC js
export function fn_pipeline(x, ...processes) {
  return compose(...processes)(x);
}
#+END_SRC

***** fn_pipeline Tests

***** fn_pipeline Errors

*** Color
:PROPERTIES:
:header-args:js: :tangle "./v2/color.js" :comments both
:END:

**** color_adjust

**** color_mix

**** color_as_hex

**** color_as_rgb

**** color_as_hsl

**** color_as_cmyk

**** color_as_hwb

**** color_as_lab

**** color_as_lch

**** color_as_oklab

**** color_as_oklch

**** color_as_dyad

**** color_as_complementary

**** color_as_analogous

**** color_as_split

**** color_as_clash

**** color_as_triad

**** color_as_tetrad

**** color_as_square

**** color_as_star

**** color_as_hexagon

**** color_as_tints

**** color_as_tones

**** color_as_shades

**** color_as_material

**** color_as_blend

**** color_as_interpolation

**** color_as_token

**** color_as_element

**** palette_shift

**** palette_sort

**** palette_filter

**** palette_contrast

**** palette_daltonize

*** Modular Scale
:PROPERTIES:
:header-args:js: :tangle "./v2/ms.js" :comments both
:END:

**** ms_create

**** ms_modify

**** ms_split

**** ms_format

**** ms_as_tokens

**** ms_as_element

*** Design Tokens
:PROPERTIES:
:header-args:js: :tangle "./v2/tokens.js" :comments both
:END:

**** tokens_as_css

**** tokens_as_scss

**** tokens_as_less

**** tokens_as_styl

**** tokens_as_json

**** tokens_as_yaml

**** tokens_as_gpl

**** tokens_as_sketchpalette

**** tokens_as_tailwind

**** tokens_as_styledict

**** tokens_as_element

** Internals

*** Functional
:PROPERTIES:
:header-args:js: :tangle "./v2/fn.js" :comments both
:END:

**** Composition Internals

#+BEGIN_SRC js :tangle "./v2/fn.js"
function compose(...fns) {
  return (x) => fns.reduce((g, f) => f(g), x);
}
#+END_SRC

*** Color
:PROPERTIES:
:header-args:js: :tangle "./v2/color.js" :comments both
:END:

QuarkSuite accepts and processes most valid CSS color formats defined in [[https://www.w3.org/TR/css-color-4/][CSS Color Module Level 4]]. There are no color objects
to pass around, you just use the colors themselves and get colors back.

Under the hood, a sequence of tokenization, validation, extraction, parsing, conversion, and serialization (mostly)
guarantees correct color input /and/ output. So wield those colors with confidence.

**** Tokenization

Color format tokenization follows the spec as closely as possible.

Then we have basic =NUMBER_TOKENS=, a =PERCENTAGE_TOKEN=, tokens for the legacy and modern =DELIMITERS=, a
=COMPONENT_TOKEN= combining the first two, and a =HUE_TOKEN=. That's all that's needed to account for every format
QuarkSuite supports.

#+BEGIN_SRC js
const NUMBER_TOKEN = /(?:-?(?!0\d)\d+(?:\.\d+)?)/;
const PERCENTAGE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "%)"].join(""),
);

const LEGACY_DELIMITER = /(?:[\s,]+)/;
const LEGACY_ALPHA_DELIMITER = new RegExp(
  LEGACY_DELIMITER.source.replace(",", ",/"),
);
const MODERN_DELIMITER = new RegExp(LEGACY_DELIMITER.source.replace(",", ""));
const MODERN_ALPHA_DELIMITER = new RegExp(
  LEGACY_ALPHA_DELIMITER.source.replace(",", ""),
);

const COMPONENT_TOKEN = new RegExp(
  ["(?:", PERCENTAGE_TOKEN.source, "|", NUMBER_TOKEN.source, ")"].join(""),
);
const HUE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "(?:deg|g?rad|turn)?)"].join(""),
);
#+END_SRC

**** Validation

Defining tokens will make validation of the functional color formats incredibly simple as the tokens can be combined
with the correct format prefix to create a full color string.

***** Named Color Validation

QuarkSuite supports CSS named colors through to CSS Color Module 4 using an object query.

#+BEGIN_SRC js
const NAMED_COLOR_KEYWORDS = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};

function namedValidator(color) {
  return Boolean(NAMED_COLOR_KEYWORDS[color]);
}
#+END_SRC

***** RGB Hex Validation

This can be done with a regular expression.

#+BEGIN_SRC js
function hexValidator(color) {
  return /^#([\da-f]{3,4}){1,2}$/i.test(color);
}
#+END_SRC

***** Functional Formats

The functional formats require a bit of extra processing. Good thing we created those tokens earlier. Functional formats
always have an optional alpha component, so we tack that onto the end. If =legacy= is =true=, then we use the legacy
delimiters. Otherwise, we know it's a modern format.

Each format has varying components, so we map over the tokens we plug in and link them with delimiters.

#+BEGIN_SRC js
function matchFunctionalFormat({ prefix, legacy = true }, tokens) {
  const VALUES = tokens.map((token) => token.source);

  const DELIMITER = legacy ? LEGACY_DELIMITER.source : MODERN_DELIMITER.source;
  const ALPHA_DELIMITER = legacy
    ? LEGACY_ALPHA_DELIMITER.source
    : MODERN_ALPHA_DELIMITER.source;

  return new RegExp(
    `(?:^${prefix}\\(`.concat(
      VALUES.join(DELIMITER),
      `(?:${[ALPHA_DELIMITER, COMPONENT_TOKEN.source].join("")})?\\))`,
    ),
  );
}
#+END_SRC

****** RGB Validation

=matchFunctionalFormats= makes validating the remaining CSS formats a matter of slotting in tokens with the right
prefix. As you'll see, some tokens repeat and others have to be slotted individually.

#+BEGIN_SRC js
function rgbValidator(color) {
  return matchFunctionalFormat(
    { prefix: "rgba?" },
    Array(3).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

****** HSL Validation

#+BEGIN_SRC js
function hslValidator(color) {
  return matchFunctionalFormat({ prefix: "hsla?" }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENTAGE_TOKEN),
  ]).test(color);
}
#+END_SRC

****** CMYK Validation

=device-cmyk= is the first modern format, so the legacy flag will have to be disabled. It's also technically been moved
to CSS Color Module 5, but I implemented it before I found that out.

#+BEGIN_SRC js
function cmykValidator(color) {
  return matchFunctionalFormat(
    { prefix: "device-cmyk", legacy: false },
    Array(4).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

****** HWB Validation

#+BEGIN_SRC js
function hwbValidator(color) {
  return matchFunctionalFormat({ prefix: "hwb", legacy: false }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENTAGE_TOKEN),
  ]).test(color);
}
#+END_SRC

****** CIELAB/CIELCH Validation

These two formats are scalar and polar variants of the same color space, so I'll combine their validators.

#+BEGIN_SRC js
function cielabValidator(color) {
  return matchFunctionalFormat({ prefix: "lab", legacy: false }, [
    PERCENTAGE_TOKEN,
    ...Array(2).fill(NUMBER_TOKEN),
  ]).test(color);
}

function cielchValidator(color) {
  return matchFunctionalFormat({ prefix: "lch", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

****** OKLab/OKLCH Validation

Same with OKLab/OKLCH, which recently became standard so I reimplemented them according to the spec.

#+BEGIN_SRC js
function oklabValidator(color) {
  return matchFunctionalFormat({ prefix: "oklab", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    NUMBER_TOKEN,
  ]).test(color);
}

function oklchValidator(color) {
  return matchFunctionalFormat({ prefix: "oklch", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

***** Preparing Validation

From here, we'll implement a =validator()= that accepts input and checks it against all of the available formats. A valid
color will match /one of/ the available formats and get slotted in a =[format, color]= tuple.

#+BEGIN_SRC js
function validator(input) {
  const SUPPORTED_FORMATS = {
    named: namedValidator,
    hex: hexValidator,
    rgb: rgbValidator,
    hsl: hslValidator,
    cmyk: cmykValidator,
    hwb: hwbValidator,
    cielab: cielabValidator,
    cielch: cielchValidator,
    oklab: oklabValidator,
    oklch: oklchValidator,
  };

  return (
    Object.entries(SUPPORTED_FORMATS)
      .map(([format, test]) => [format, test(input) && input])
      .find(([, color]) => color) || InvalidColorError(input)
  );
}
#+END_SRC

***** Invalid Color Handling

Otherwise, the input does not match any of the available formats and throws a useful error.

#+BEGIN_SRC js
class InvalidColor extends Error {
  constructor(input, ...params) {
    super(...params);

    // Stack trace (for v8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, InvalidColor);
    }

    this.name = "Invalid Color Format";
    this.message = `
${"-".repeat(100)}
"${input}" is not a valid color.
${"-".repeat(100)}

Supported color formats:

- Named colors
- RGB Hex
- Functional RGB
- Functional HSL
- Functional CMYK
- Functional HWB
- Functional CIELAB/CIELCH
- Functional OKLab/OKLCH

Read more about these formats at: https://www.w3.org/TR/css-color-4/
${"=".repeat(100)}
`;
  }
}

function InvalidColorError(input) {
  return new InvalidColor(input);
}
#+END_SRC

**** Extraction

Once we're sure we have a valid color, we need to extract its components. Since CSS color formats really have just two
forms (hexadecimal and functional), that's how many extractors we need.

***** RGB Hex Extractor

For RGB Hex extraction, we need to consider that RGB colors can also come in the form =#RGB(A)=. So we'll use =expandHex()= to expand
those to a full =#RRGGBB(AA)=. And then we have =hexExtractor()= to do the extraction proper.

#+BEGIN_SRC js
function hexExtractor(color) {
  return expandHex(color).match(/[\da-f]{2}/gi);
}

function expandHex(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

***** Functional Format Extractor

Extracting from functional formats requires that the values be picked /with their units attached/. We'll need this
information for parsing them prior to format conversion.

This is done with =componentExtractor()=.

#+BEGIN_SRC js
function componentExtractor(color) {
  return color.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
}
#+END_SRC

***** Extraction Preparation

Now with all the parts in place, we'll create a general =extractor()= that consumes a valid color tuple. If the =format=
is =hex=, we'll call =hexExtractor()=, otherwise it's a functional format and must be handled by =componentExtractor()=.

We also need to do additional work if the =format= is =named=, so we pass its value in =NAMED_COLOR_KEYWORDS= through
=hexExtractor()=.

Note that we're also passing the extraction along in the =[format, components]= tuple form for additional parsing.

#+BEGIN_SRC js
function extractor(validated) {
  const [format, color] = validated;

  if (format === "named") {
    return ["hex", hexExtractor(NAMED_COLOR_KEYWORDS[color])];
  }

  if (format === "hex") {
    return ["hex", hexExtractor(color)];
  }

  return [format, componentExtractor(color)];
}
#+END_SRC

**** Parsing

Before we get into actual color conversion, we're going to parse the extracted values according to their format. In
other words, we're going break them down into a calculable state that we can pass along to each conversion function.

We're going to use the extraction tuple and create a parser for each format so there are no false positives.

But first...

***** Math

We're going to prepare some helpers for the necessary value conversions we'll need to perform.

****** Clamping Values

Before anything else, we'll need a helper to =clamp()= values between a =min= and =max=. Some values in functional
formats are capped, and others are not. We'll see which when we implement the serializer.

#+BEGIN_SRC js
function clamp(x, a, b) {
  if (x < a) {
    return a;
  }

  if (x > b) {
    return b;
  }

  return x;
}
#+END_SRC

****** Hex Fragment <-> Channel

Now, we're going to need to convert hex fragments to and from their RGB channel equivalents.

=16= is the /radix/ (or base) of hexadecimal, so we use =parseInt()= to convert the hex value to a decimal and
=toString()= to convert a decimal to hexadecimal.

#+BEGIN_SRC js
function hexFragmentToChannel(hex) {
  return parseInt(hex, 16);
}

function hexFragmentFromChannel(channel) {
  return channel.toString(16).padStart(2, "0");
}
#+END_SRC

****** Number <-> Percentage

Some functional formats will need to have their numbers converted to percentages or the reverse.

#+BEGIN_SRC js
function numberToPercentage(n) {
  return n * 100;
}

function numberFromPercentage(percentage) {
  return percentage / 100;
}
#+END_SRC

****** Number <-> Channel

RGB channels need to be converted to a =0-1= range to be useful in calculation. And then they need to be converted back
to channels later.

#+BEGIN_SRC js
function numberToChannel(n) {
  return n * 255;
}

function numberFromChannel(channel) {
  return channel / 255;
}
#+END_SRC

****** Hue Component

Some of the color conversions require the [[https://www.rapidtables.com/convert/number/how-degrees-to-radians.html][hue as radians]]. And then we need to be able to [[https://www.rapidtables.com/convert/number/how-radians-to-degrees.html][convert back]].

The hue component also supports gradians and rotations, so we'll have to account for those as well to stay true to the
spec.

#+BEGIN_SRC js
function radiansToDegrees(radians) {
  return (radians * 180) / Math.PI;
}

function radiansFromDegrees(degrees) {
  return (degrees * Math.PI) / 180;
}

function gradiansToDegrees(gradians) {
  return gradians * (180 / 200);
}

function turnsToDegrees(turns) {
  return turns * 360;
}
#+END_SRC

****** Hue Correction

A stipulation of the hue component in the spec is that it must support hue values greater than a single revolution.

However, if it's to be useful in calculation, we must then /correct/ the value to a range =-360-360= or one full
rotation clockwise and counterclockwise. Our implmentation of =hueCorrection()= takes care of that.

#+BEGIN_SRC js
function hueCorrection(hue) {
  let h = hue;

  if (Math.sign(hue) === -1) {
    h = Math.abs(hue + 360);
  }

  if (hue > 360) {
    h = hue % 360;
  }

  return clamp(h, -360, 360);
}
#+END_SRC

***** Parsing RGB Hex

RGB Hex must be parsed as RGB channels to be mathematically useful. That's what =parseHex()= does.

If =A= is missing, then we attach it to ensure uniformity. Finally, we convert the hex fragments to RGB. The alpha
component needs additional handling.

#+BEGIN_SRC js
function parseHex([format, components]) {
  const [r, g, b, A] = components;

  const [R, G, B] = [r, g, b].map((fragment) => hexFragmentToChannel(fragment));

  if (A) {
    return [
      format,
      [R, G, B, numberFromChannel(hexFragmentToChannel(parseFloat(A)))],
    ];
  }

  return [format, [R, G, B, 1]];
}
#+END_SRC

***** Parsing Functional RGB

As stated above, RGB must be converted to a =0-1= range to be mathematically useful. This is a straightforward
conversion because of our =numberFromChannel()= helper. Meanwhile, percentage values are valid for =a=.

We check to see if =a= is a percentage value and convert it or leave it alone.

This is an operation we'll repeat multiple times during parsing, so it's captured in a =parsePercentage()= helper.

#+BEGIN_SRC js
function parsePercentage(component) {
  if (component.endsWith("%")) {
    return numberFromPercentage(parseFloat(component));
  }
  return parseFloat(component);
}

function parseRgb([format, components]) {
  const [r, g, b, A] = components;

  const [R, G, B] = [r, g, b].map((channel) => {
    if (channel.endsWith("%")) return parsePercentage(channel);
    return numberFromChannel(parseFloat(channel));
  });

  if (A) {
    return [format, [R, G, B, parsePercentage(A)]];
  }

  return [format, [R, G, B, 1]];
}
#+END_SRC

***** Parsing Functional HSL

The =h= component will need special processing depending on its units. And our conversion goal is /degrees/. Other than
that, =s= and =l= need conversion to a =0-1= range, and =A= is handled as usual.

Several formats beyond this point have a hue value, so we'll create a =parseHue()= helper to capture that logic.

#+BEGIN_SRC js
function parseHue(hue) {
  let HUE = parseFloat(hue);

  if (hue.endsWith("rad")) {
    HUE = radiansToDegrees(HUE);
  }

  if (hue.endsWith("grad")) {
    HUE = gradiansToDegrees(HUE);
  }

  if (hue.endsWith("turn")) {
    HUE = turnsToDegrees(HUE);
  }

  return hueCorrection(HUE);
}

function parseHsl([format, components]) {
  const [h, s, l, A] = components;

  let H = parseHue(h);

  const [S, L] = [s, l].map((percentage) =>
    numberFromPercentage(parseFloat(percentage))
  );

  if (A) {
    return [format, [H, S, L, parsePercentage(A)]];
  }

  return [format, [H, S, L, 1]];
}
#+END_SRC

***** Parsing Functional CMYK

Functional CMYK is dead simple to parse. We check to see if the components are percentages and convert them. Otherwise,
we coerce them to numbers with no additional processing.

#+BEGIN_SRC js
function parseCMYK([format, components]) {
  const [C, M, Y, K, A] = components.map((V) => {
    if (V.endsWith("%")) return parsePercentage(V);
    return parseFloat(V);
  });

  if (A) {
    return [format, [C, M, Y, K, A]];
  }

  return [format, [C, M, Y, K, 1]];
}
#+END_SRC

***** Parsing Functional HWB

Parsing functional HWB simply reuses =parseHSL()= because in this area they are /identical/.

***** Parsing Functional CIELAB/CIELCH

Of these two, the only one that requires any special attention is CIELCH because of that hue component. CIELAB just
passes its values through number coercion.

#+BEGIN_SRC js
function parseCielab([format, components]) {
  const [$L, $a, $b, A] = components;

  const [L, a, b] = [$L, $a, $b].map((component) => parseFloat(component));

  if (A) {
    return [format, [L, a, b, parsePercentage(A)]];
  }

  return [format, [L, a, b, 1]];
}

function parseCielch([format, components]) {
  const [$L, c, h, A] = components;

  const [L, C] = [$L, c].map((component) => parseFloat(component));
  const H = parseHue(h);

  if (A) {
    return [format, [L, C, H, parsePercentage(A)]];
  }

  return [format, [L, C, H, 1]];
}
#+END_SRC

***** Parsing OKLab/OKLCH

Parsing OKLab/OKLCH is similar to the above section, but it's important to note that OKLCH calculations expect the hue
in /radians/. =L= is also converted to a =0-1= range.

#+BEGIN_SRC js
function parseOklab([format, components]) {
  const [$L, $a, $b, A] = components;

  const L = parsePercentage($L);
  const [a, b] = [$a, $b].map((component) => parseFloat(component));

  if (A) {
    return [format, [L, a, b, parsePercentage(A)]];
  }

  return [format, [L, a, b, 1]];
}

function parseOklch([format, components]) {
  const [$L, c, h, A] = components;

  const L = parsePercentage($L);
  const C = parseFloat(c);
  const H = radiansFromDegrees(parseHue(h));

  if (A) {
    return [format, [L, C, H, parsePercentage(A)]];
  }

  return [format, [L, C, H, 1]];
}
#+END_SRC

***** Parsing Preparation

Similar to the validator and extractor, the =parser()= will read a color tuple and execute the correct parsing function
for a matched format. And then it throws back a transformed tuple of =[format, values]=.

#+BEGIN_SRC js
function parser(extracted) {
  const [format] = extracted;

  const FORMAT_PARSERS = {
    hex: parseHex,
    rgb: parseRgb,
    hsl: parseHsl,
    cmyk: parseCMYK,
    hwb: parseHsl, // identical to HSL
    cielab: parseCielab,
    cielch: parseCielch,
    oklab: parseOklab,
    oklch: parseOklch,
  };

  return FORMAT_PARSERS[format](extracted);
}
#+END_SRC

**** Conversion

Having completed our necessary preparations, we can finally move on to color conversion. QuarkSuite handles conversion
with a very precise method.

The idea: as a tool created for the web, and therefore largely for screens, every color used will eventually have to
pass through the sRGB gamut. This means that sRGB is our given /conversion anchor/.

With this in mind we can say color conversion is best structured as a pipeline where =INPUT -> RGB -> OUTPUT= routes
every input format to its targeted output format.

Some formats need to be linked into the pipeline. Specifically =Scalar <-> Polar= formats.

***** Preamble

To keep things simple, I'll keep using the color tuple data structure up until the point it's actually time to hand a
color back to the user. This is a *major* change from v1, where I attempted to reassemble the color within each conversion
function which sometimes led to wonky behavior from the pipeline.

It makes far more sense to keep passing along the raw conversions to the color tuple for serialization and make
reassembly an explicit, predictable step.

By this point, we're assuming the color has been validated, extracted, and correctly parsed. So we'll be passing along
the result of parsing as the color tuple =[format, values]=.

In the color conversion functions themselves, we'll be passing the results along as the =[format, results]= tuple.

***** INPUT -> RGB

The first process in the conversion pipeline is to take the =INPUT= format and convert it to =RGB=.

****** Hex -> RGB

If you remember from =parseHex()=, a parsed hexadecimal color is already a valid RGB result. So we mark it as such and pass it
through.

#+BEGIN_SRC js
function hexToRgb([, values]) {
  return ["rgb", values];
}
#+END_SRC

****** HSL -> RGB

To convert HSL to RGB, we use [[https://www.rapidtables.com/convert/color/hsl-to-rgb.html][this conversion formula from RapidTables]].

#+BEGIN_SRC js
function calculateRgb(C, X, H) {
  return new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);
}

function hslToRgb([, values]) {
  const [H, S, L, A] = values;

  // Calculate chroma
  const C = (1 - Math.abs(2 * L - 1)) * S;
  const X = C * (1 - Math.abs(((H / 60) % 2) - 1));
  const m = L - C / 2;

  const [R, G, B] = Array.from(calculateRgb(C, X, H))
    .find(([, condition]) => condition)
    .flatMap((result) => result)
    .map((n) => numberToChannel(n + m));

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

****** CMYK -> RGB

#+BEGIN_QUOTE
IMPORTANT: CSS Color Module 5 will use a device-independent conversion of CMYK through the CIELAB space. This means the
below approach is outdated. For practicality and compatibility's sake, I still use the old conversion method through
sRGB. Which works today.
#+END_QUOTE

Conversion of CMYK to RGB is [[https://www.rapidtables.com/convert/color/cmyk-to-rgb.html][covered by another RapidTables formula]].

#+BEGIN_SRC js
function cmykToRgb([, values]) {
  const [C, M, Y, K, A] = values;

  const [R, G, B] = [C, M, Y].map((V) => numberToChannel((1 - V) * (1 - K)));

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

****** HWB -> RGB

The formula for conversion of HWB to RGB is [[https://www.w3.org/TR/css-color-4/#hwb-to-rgb][adapted from the spec itself]].

#+BEGIN_SRC js
function hwbToRgb([, values]) {
  const [H, W, BLK, A] = values;

  // Achromacity
  if (W + BLK >= 1) {
    let GRAY = numberToChannel(W / (W + BLK));

    return ["rgb", [Array(3).fill(GRAY), A]];
  }

  // Conversion
  const [, [r, g, b, a]] = hslToRgb(["hsl", [H, 1, 0.5, 1]]);
  const [R, G, B] = [r, g, b].map((channel) =>
    numberToChannel(numberFromChannel(channel) * (1 - W - BLK) + W)
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

****** CIELAB -> RGB

The steps for the CIELAB to RGB conversion are as follows:

1. Convert CIELAB to CIEXYZ
2. Convert CIEXYZ to LRGB
3. Convert LRGB to RGB

The actual equations are helpfully [[http://www.brucelindbloom.com/index.html?Math.html][provided by Bruce Lindbloom]].

#+BEGIN_SRC js
function cielabToCiexyz([L, a, b]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const WHITE = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const FY = (L + 16) / 116;
  const FX = a / 500 + FY;
  const FZ = FY - b / 200;

  // Calculate xyz
  const [X, Y, Z] = [
    FX ** 3 > ε ? FX ** 3 : (116 * FX - 16) / κ,
    L > κ * ε ? FY ** 3 : L / κ,
    FZ ** 3 > ε ? FZ ** 3 : (116 * FZ - 16) / κ,
  ].map((V, i) => V * WHITE[i]);

  return [X, Y, Z];
}

function ciexyzToLrgb([X, Y, Z]) {
  const D65_CHROMATIC_ADAPTATION = [
    [0.9555766, -0.0230393, 0.0631636],
    [-0.0282895, 1.0099416, 0.0210077],
    [0.0122982, -0.020483, 1.3299098],
  ];

  const LINEAR_RGB_TRANSFORMATION_MATRIX = [
    [3.2404542, -1.5371385, -0.4985314],
    [-0.969266, 1.8760108, 0.041556],
    [0.0556434, -0.2040259, 1.0572252],
  ];

  const [CX, CY, CZ] = D65_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => X * V1 + Y * V2 + Z * V3,
  );

  const [LR, LG, LB] = LINEAR_RGB_TRANSFORMATION_MATRIX.map(
    ([V1, V2, V3]) => CX * V1 + CY * V2 + CZ * V3,
  );

  return [LR, LG, LB];
}

function lrgbToRgb([LR, LG, LB]) {
  return [LR, LG, LB].map((V) =>
    V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055
  );
}

function cielabToRgb([, values]) {
  const [L, a, b, A] = values;

  const [R, G, B] = lrgbToRgb(ciexyzToLrgb(cielabToCiexyz([L, a, b]))).map(
    (n) => numberToChannel(n),
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

****** OKLAB -> RGB

The OKLab to RGB conversion steps are adapted from the creator, Björn Ottosson's, [[https://bottosson.github.io/posts/oklab/][original post about it]].

The process breaks down to:

1. Convert OKLab to LRGB
2. Convert LRGB to RGB

Simple and direct.

#+BEGIN_SRC js
function oklabToLrgb([L, a, b]) {
  const LINEAR_LMS_CONE_ACTIVATIONS = [
    [0.3963377774, 0.2158037573],
    [0.1055613458, 0.0638541728],
    [0.0894841775, 1.291485548],
  ];

  const OKLAB_TO_LRGB_MATRIX = [
    [4.076416621, 3.3077115913, 0.2309699292],
    [-1.2684380046, 2.6097574011, 0.3413193965],
    [-0.0041960863, 0.7034186147, 1.707614701],
  ];

  const [LONG, M, S] = LINEAR_LMS_CONE_ACTIVATIONS.map(([V1, V2], pos) => {
    if (pos === 0) return L + a * V1 + b * V2;
    if (pos === 1) return L - a * V1 - b * V2;
    return L - a * V1 - b * V2;
  }).map((V) => V ** 3);

  const [LR, LG, LB] = OKLAB_TO_LRGB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return LONG * V1 - M * V2 + S * V3;
    if (pos === 1) return LONG * V1 + M * V2 - S * V3;
    return LONG * V1 - M * V2 + S * V3;
  });

  return [LR, LG, LB];
}

function oklabToRgb([, values]) {
  const [L, a, b, A] = values;

  const [R, G, B] = lrgbToRgb(oklabToLrgb([L, a, b])).map((n) =>
    numberToChannel(n)
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

***** RGB -> OUTPUT

The next stage is to get the output format /from/ the RGB.

****** RGB -> Hex

Getting RGB to hexadecimal color output is a similarly stratightforward implementation.

Rounding the results is necessary because hexadecimal format expects integers. Having reached our target output, we can
now forward the result for serializing.

#+BEGIN_SRC js
function hexFromRgb([, rgbValues]) {
  const [r, g, b, a] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) =>
    hexFragmentFromChannel(Math.round(channel))
  );
  const A = hexFragmentFromChannel(Math.round(numberToChannel(a)));

  return ["hex", [R, G, B, A]];
}
#+END_SRC

****** RGB -> HSL

Getting RGB to an HSL output color is [[https://www.rapidtables.com/convert/color/rgb-to-hsl.html][handled by another RapidTables formula]].

#+BEGIN_SRC js
function calculateHue(R, G, B, cmax, delta) {
  return new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);
}

function calculateSaturation(delta, L) {
  return delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));
}

function calculateLightness(cmin, cmax) {
  return (cmax + cmin) / 2;
}

function hslFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const cmin = Math.min(R, G, B);
  const cmax = Math.max(R, G, B);
  const delta = cmax - cmin;

  const L = calculateLightness(cmin, cmax);
  const [H] = Array.from(calculateHue(R, G, B, cmax, delta)).find(
    ([, condition]) => condition,
  );
  const S = calculateSaturation(delta, L);

  return ["hsl", [H, S, L, A]];
}
#+END_SRC

****** RGB -> CMYK

Getting RGB to CMYK output [[https://www.rapidtables.com/convert/color/rgb-to-cmyk.html][requires yet another RapidTables formula]].

#+BEGIN_SRC js
function cmykFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const K = 1 - Math.max(R, G, B);
  const [C, M, Y] = [R, G, B].map((channel) => (1 - channel - K) / (1 - K));

  return ["cmyk", [C, M, Y, K, A]];
}
#+END_SRC

****** RGB -> HWB

The formula for converting RGB to HWB output is also [[https://www.w3.org/TR/css-color-4/#rgb-to-hwb][pulled from the spec]].

#+BEGIN_SRC js
function hwbFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const cmax = Math.max(R, G, B);
  const cmin = Math.min(R, G, B);
  const delta = cmax - cmin;

  const [H] = Array.from(calculateHue(R, G, B, cmax, delta)).find(
    ([, condition]) => condition,
  );

  const [W, BLK] = [cmin, 1 - cmax];

  return ["hwb", [H, W, BLK, A]];
}
#+END_SRC

****** RGB -> CIELAB

For getting CIELAB output from RGB, we'll be leaning on Bruce Lindbloom's equations again.

The process is as follows:

1. RGB to LRGB
2. LRGB to CIEXYZ
3. CIEXYZ to CIELAB

#+BEGIN_SRC js
function rgbToLrgb([R, G, B]) {
  return [R, G, B].map((V) =>
    V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4
  );
}

function lrgbToCiexyz([LR, LG, LB]) {
  const D65_REFERENCE_WHITE = [
    [0.4124564, 0.3575761, 0.1804375],
    [0.2126729, 0.7151522, 0.072175],
    [0.0193339, 0.119192, 0.9503041],
  ];

  const D50_CHROMATIC_ADAPTATION = [
    [1.0478112, 0.0228866, -0.050127],
    [0.0295424, 0.9904844, -0.0170491],
    [-0.0092345, 0.0150436, 0.7521316],
  ];

  const [x, y, z] = D65_REFERENCE_WHITE.map(
    ([V1, V2, V3]) => LR * V1 + LG * V2 + LB * V3,
  );

  const [X, Y, Z] = D50_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => x * V1 + y * V2 + z * V3,
  );

  return [X, Y, Z];
}

function ciexyzToCielab([X, Y, Z]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const D50_WHITE = [0.96422, 1.0, 0.82521];

  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z]
    .map((V, i) => V / D50_WHITE[i])
    .map((V) => (V > ε ? Math.cbrt(V) : (κ * V + 16) / 116));

  const [L, a, b] = [116 * FY - 16, 500 * (FX - FY), 200 * (FY - FZ)];

  return [L, a, b];
}

function cielabFromRgb([, rgbValues]) {
  const [r, g, $b, A] = rgbValues;

  const [R, G, B] = [r, g, $b].map((channel) => numberFromChannel(channel));
  const [L, a, b] = ciexyzToCielab(lrgbToCiexyz(rgbToLrgb([R, G, B])));

  return ["cielab", [L, a, b, A]];
}
#+END_SRC

****** RGB -> OKLAB

To get Oklab output from RGB, we're going to use the inversion also documented by its creator.

That process goes:

1. RGB to LRGB
2. LRGB to OKLAB

#+BEGIN_SRC js
function lrgbToOklab([LR, LG, LB]) {
  const NONLINEAR_LMS_CONE_ACTIVATIONS = [
    [0.4122214708, 0.5363325363, 0.0514459929],
    [0.2119034982, 0.6806995451, 0.1073969566],
    [0.0883024619, 0.2817188376, 0.6299787005],
  ];

  const RGB_OKLAB_MATRIX = [
    [0.2104542553, 0.793617785, 0.0040720468],
    [1.9779984951, 2.428592205, 0.4505937099],
    [0.0259040371, 0.7827717662, 0.808675766],
  ];

  const [L, M, S] = NONLINEAR_LMS_CONE_ACTIVATIONS.map(
    ([L, M, S]) => L * LR + M * LG + S * LB,
  ).map((V) => Math.cbrt(V));

  return RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return V1 * L + V2 * M - V3 * S;
    if (pos === 1) return V1 * L - V2 * M + V3 * S;
    return V1 * L + V2 * M - V3 * S;
  });
}

function oklabFromRgb([, rgbValues]) {
  const [r, g, $b, A] = rgbValues;

  const [R, G, B] = [r, g, $b].map((channel) => numberFromChannel(channel));
  const [L, a, b] = lrgbToOklab(rgbToLrgb([R, G, B]));

  return ["oklab", [L, a, b, A]];
}
#+END_SRC

***** SCALAR <-> POLAR

The last thing we need to do before wiring everything up is create a bridge to and from CIELAB & OKLab to their polar
coordinate alter-egos (CIELCH & OKLCH).

Since we already have a completed chain of =INPUT -> RGB -> OUTPUT= for both formats, we don't need to do much more.

The two basically [[https://www.w3.org/TR/css-color-4/#lab-to-lch][share formulas]], so I'm going to create the helpers =scalarToPolar()= and =scalarFromPolar=.

#+BEGIN_SRC js
function scalarToPolar([, scalarValues]) {
  const [L, a, b, A] = scalarValues;

  const C = Math.sqrt(a ** 2 + b ** 2);
  const H = Math.atan2(b, a);

  return [L, C, H, A];
}

function scalarFromPolar([, polarValues]) {
  const [L, C, H, A] = polarValues;

  const a = C * Math.cos(H);
  const b = C * Math.sin(H);

  return [L, a, b, A];
}
#+END_SRC

****** CIELAB <-> CIELCH

#+BEGIN_SRC js
function cielabToCielch([, cielabValues]) {
  return ["cielch", scalarToPolar(["cielab", cielabValues])];
}

function cielabFromCielch([, cielchValues]) {
  return ["cielab", scalarFromPolar(["cielch", cielchValues])];
}
#+END_SRC

****** OKLab <-> OKLCH

#+BEGIN_SRC js
function oklabToOklch([, oklabValues]) {
  return ["oklch", scalarToPolar(["oklab", oklabValues])];
}

function oklabFromOklch([, oklchValues]) {
  return ["oklab", scalarFromPolar(["oklch", oklchValues])];
}
#+END_SRC

***** Color Conversion Pipeline
**** Serialization

*** Modular Scale Internals

*** Design Token Internals
