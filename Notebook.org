#+TITLE: QuarkSuite Core (v2.0.0)
#+PROPERTY: header-args:shell :results output code

* Table of Contents :TOC@5:
- [[#summary][Summary]]
- [[#whats-new-in-v2][What's New in v2?]]
  - [[#workflows][Workflows]]
    - [[#core][Core]]
    - [[#dsl][DSL]]
  - [[#settled-types][Settled Types]]
  - [[#improved-performance][Improved Performance]]
  - [[#internal-simplicity][Internal Simplicity]]
  - [[#improved-modularity][Improved Modularity]]
- [[#spec][Spec]]
  - [[#api][API]]
    - [[#functional-utilities][Functional Utilities]]
      - [[#process][process]]
        - [[#process-examples][process Examples]]
        - [[#process-implementation][process Implementation]]
        - [[#process-tests][process Tests]]
      - [[#preset][preset]]
        - [[#preset-examples][preset Examples]]
        - [[#preset-implementation][preset Implementation]]
        - [[#preset-tests][preset Tests]]
      - [[#pipeline][pipeline]]
        - [[#pipeline-examples][pipeline Examples]]
        - [[#pipeline-implementation][pipeline Implementation]]
        - [[#pipeline-tests][pipeline Tests]]
      - [[#propagate][propagate]]
        - [[#propagate-examples][propagate Examples]]
        - [[#propagate-implementation][propagate Implementation]]
        - [[#propagate-tests][propagate Tests]]
      - [[#delegate][delegate]]
        - [[#delegate-examples][delegate Examples]]
        - [[#delegate-implementation][delegate Implementation]]
        - [[#delegate-tests][delegate Tests]]
    - [[#color][Color]]
      - [[#convert][convert]]
        - [[#convert-examples][convert Examples]]
        - [[#convert-implementation][convert Implementation]]
        - [[#convert-tests][convert Tests]]
      - [[#adjust][adjust]]
        - [[#adjust-examples][adjust Examples]]
        - [[#adjust-implementation][adjust Implementation]]
        - [[#adjust-tests][adjust Tests]]
      - [[#mix][mix]]
        - [[#mix-examples][mix Examples]]
        - [[#mix-implementation][mix Implementation]]
        - [[#mix-tests][mix Tests]]
      - [[#harmony][harmony]]
        - [[#harmony-examples][harmony Examples]]
        - [[#harmony-implementation][harmony Implementation]]
        - [[#harmony-tests][harmony Tests]]
      - [[#vision][vision]]
        - [[#vision-examples][vision Examples]]
        - [[#vision-implementation][vision Implementation]]
        - [[#vision-tests][vision Tests]]
      - [[#contrast][contrast]]
        - [[#contrast-examples][contrast Examples]]
        - [[#contrast-implementation][contrast Implementation]]
        - [[#contrast-tests][contrast Tests]]
      - [[#illuminant][illuminant]]
        - [[#illuminant-examples][illuminant Examples]]
        - [[#illuminant-implementation][illuminant Implementation]]
        - [[#illuminant-tests][illuminant Tests]]
      - [[#palette][palette]]
        - [[#palette-examples][palette Examples]]
        - [[#palette-implementation][palette Implementation]]
        - [[#palette-tests][palette Tests]]
      - [[#accessibility][accessibility]]
        - [[#accessibility-examples][accessibility Examples]]
        - [[#accessibility-implementation][accessibility Implementation]]
        - [[#accessibility-tests][accessibility Tests]]
      - [[#tokens][tokens]]
        - [[#tokens-examples][tokens Examples]]
        - [[#tokens-color-implementation][tokens (Color) Implementation]]
        - [[#tokens-color-tests][tokens (Color) Tests]]
    - [[#content][Content]]
      - [[#text][text]]
        - [[#text-examples][text Examples]]
        - [[#text-implementation][text Implementation]]
        - [[#text-tests][text Tests]]
      - [[#ms][ms]]
        - [[#ms-examples][ms Examples]]
        - [[#ms-implementation][ms Implementation]]
        - [[#ms-tests][ms Tests]]
      - [[#modify][modify]]
        - [[#modify-examples][modify Examples]]
        - [[#modify-implementation][modify Implementation]]
        - [[#modify-tests][modify Tests]]
      - [[#tokens-1][tokens]]
        - [[#tokens-examples-1][tokens Examples]]
        - [[#tokens-content-implementation][tokens (Content) Implementation]]
        - [[#tokens-content-tests][tokens (Content) Tests]]
  - [[#internals][Internals]]
    - [[#functional][Functional]]
      - [[#composition-internals][Composition Internals]]
    - [[#color-1][Color]]
      - [[#conversion][Conversion]]
        - [[#tokenization][Tokenization]]
        - [[#validation][Validation]]
        - [[#extraction][Extraction]]
        - [[#parsing][Parsing]]
        - [[#calculation][Calculation]]
        - [[#serialization][Serialization]]
      - [[#color-adjustment][Color Adjustment]]
        - [[#target-properties][Target Properties]]
        - [[#perceptually-uniform-color-adjustment][Perceptually Uniform Color Adjustment]]
        - [[#color-adjustment-through-oklch][Color Adjustment Through OKLCH]]
      - [[#color-mixture][Color Mixture]]
        - [[#perceptually-uniform-color-mixture][Perceptually Uniform Color Mixture]]
        - [[#color-mixture-through-oklab][Color Mixture Through OKLab]]
      - [[#color-perception][Color Perception]]
        - [[#color-vision-deficiency-colorblindness][Color Vision Deficiency (Colorblindness)]]
        - [[#contrast-sensitivity][Contrast Sensitivity]]
        - [[#correlated-color-temperature-cct][Correlated Color Temperature (CCT)]]
      - [[#color-interpolation][Color Interpolation]]
      - [[#color-harmonies][Color Harmonies]]
      - [[#palette-configurations][Palette Configurations]]
        - [[#material-configuration][Material Configuration]]
        - [[#artistic-configuration][Artistic Configuration]]
      - [[#palette-accessibility][Palette Accessibility]]
        - [[#wcag-color-contrast-ratios][WCAG Color Contrast Ratios]]
        - [[#colorimetric-contrast][Colorimetric Contrast]]
      - [[#palette-formatting][Palette Formatting]]
    - [[#content-1][Content]]
      - [[#modular-scales][Modular Scales]]
        - [[#creating-a-raw-modular-scale][Creating a Raw Modular Scale]]
        - [[#scale-modification][Scale Modification]]
        - [[#scale-configurations][Scale Configurations]]
        - [[#scale-units][Scale Units]]
      - [[#text-families][Text Families]]
      - [[#token-assembly][Token Assembly]]

* Summary

This document is my scratchpad/workspace as I further refine QuarkSuite. Literate programming gives me a clear space to
think, iterate, and speculate on different approaches to my ultimate goal of a more enjoyable, flexible, and powerful
design token development environment for web projects. It also allows me to automate my directory structure.

For incremental improvements and function documentation, I work directly with the source code. This document will not
stay current after everything is locked in.

* What's New in v2?

** Workflows

*** Core

v2 focuses *exclusively* on the relationship between types, their available actions, and output emitters. This means the
workflow has been refined and tightened for even greater functional flexibility and the object factory pattern is retired.

The API now follows a simple, explicit architecture:

+ =action(y, x)=: indicates that a function performs an action on type =x= with =y= modifying the output
+ =emitter(x)=: indicates that a function emits output /directly from/ =x=

The functional helpers provided are a small subset optimized for the values and collections generated by QuarkSuite. You
should absolutely not use them for general data handling.

*** DSL

QuarkSuite v2 provides a brand new DSL (domain specific language) around vanilla web components.

Rather than using them solely to /render/ data generated by the core library, they will instead /translate/ the
functions of the core as a declarative workflow embedded in your markup.

The reason why the DSL is built around web components is for the semantic benefits and the undeniable portability of
using HTML as the *entire workspace* of your design token development environment.

It means you can work with a technology that you or everyone on your team probably knows or uses. And because the DSL is
realized through your markup, it *doesn't change unless you change it*.

The available elements will match equivalent actions and emitters in the core. For example: the =vision= action of the =color=
module becomes the =<color-vision>= element used declaratively. Some

The other difference from the core workflow is that an =<x-define>= element is provided for each =x= type which translates
the initial value assignment. So =<color-define>= allows you to create an initial color declaratively.

As the DSL is derived from functions in the core, you can use their output interchangeably to translate or transmit as
needed. You'll end up with the same results regardless.

The DSL is a work in progress and being created in conjunction with Core v2. You can [[https://github.com/quarksuite/dsl][check out its repo]] if you want.

** Settled Types

+ =fn=: functional helpers
+ =color=: individual colors (of any valid CSS format)
+ =palette=: generated color palettes
+ =ms=: raw modular scales
+ =tokens=: token collections

** Improved Performance

The library is already pretty fast, but it could be faster. That in itself is enough for me to research ways to squeeze
a little more performance out of everything happening under the hood.

** Internal Simplicity

Up until now, QuarkSuite used some internal patterns and structure that at the time was some pretty clever code. At the
same time, this makes it a bit /too clever to debug effectively/. I'm being more judicious toward complexity and
limiting it to where it's needed.

** Improved Modularity

Where v1 kept its code in a single =mod.js= file, v2 splits the functionality into discrete modules associated with the
available types. This will make it easier to develop and debug while allowing more types to be added in the future.

In addition, the internal library has been expanded so that each utility exposed in the API is truly uncoupled from the
rest. This means that modern build tools, and environments that support tree shaking, will only pull in what's needed.

* Spec

The library begins with an entry point =mod.js= that aggregates all the functionality to make it easier to experiment
during development before you've settled on what you need. QuarkSuite v2 separates all functionality by its input type.

#+BEGIN_SRC js :tangle "./v2/mod.js" :comments link
export * as fn from "./fn.js";
export * as color from "./color.js";
export * as content from "./content.js";
#+END_SRC

** API

*** Functional Utilities
:PROPERTIES:
:header-args:js: :tangle "./v2/fn.js" :mkdirp yes :comments link
:END:

**** process

A functional utility that combines emitters into a process.

+ =process(...emitters) => (x)=
  - =emitters: Array<(x)>=: sequence of emitters to combine

***** process Examples

***** process Implementation

#+BEGIN_SRC js
export function process(...emitters) {
  return compose(...emitters);
}
#+END_SRC

***** process Tests

**** preset

A functional utility that accepts an action and its modifiers and converts it to an emitter.

+ =preset(action, y) => (x)=
  - =action: (y, x) => unknown=: the action to transform
  - =y: unknown=: the action's associated modifiers

***** preset Examples

***** preset Implementation

#+BEGIN_SRC js
export function preset(action, y) {
  return (x) => action(y, x);
}
#+END_SRC

***** preset Tests

**** pipeline

A functional utility that shuttles data =x= through a process pipeline.

+ =pipeline(x, ...processes) => unknown=
  + =x: unknown=: data to pipe
  + =processes: Array<(x)>=: sequence of processes to transform data

***** pipeline Examples

***** pipeline Implementation

#+BEGIN_SRC js
export function pipeline(x, ...processes) {
  return compose(...processes)(x);
}
#+END_SRC

***** pipeline Tests

**** propagate

A functional utility that allows an =emitter= to propagate over a collection of =xs=.

+ =propagate(emitter, xs) => unknown=
  - =emitter: (x) => unknown=: the emitter to use
  - =xs: unknown[]=: the data collection to map over

***** propagate Examples

***** propagate Implementation

#+BEGIN_SRC js
export function propagate(emitter, xs) {
  return xs.map((x) => emitter(x));
}
#+END_SRC

***** propagate Tests

**** delegate

A functional utility that maps a collection of =emitters= to a collection of =xs= inputs.

As a rule, only delegations that match to an input will return output. This means you can /assign/ your delegations
directly to the inputs in =xs= you actually want to transform. Any unmatched inputs will simply be left out.

+ =delegate(emitters, xs) => unknown[]=
  - =emitters: Array<(x)>=: the collection of emitters to assign
  - =xs: unknown[]=: the data collection of delegation targets

***** delegate Examples

***** delegate Implementation

#+BEGIN_SRC js
export function delegate(emitters, xs) {
  return emitters
    .map((f, pos) => (xs[pos] ? f(xs[pos]) : undefined))
    .filter((result) => result !== undefined);
}
#+END_SRC

***** delegate Tests

*** Color
:PROPERTIES:
:header-args:js: :tangle "./v2/color.js" :mkdirp yes :comments link
:END:

**** convert

An action that converts a given valid CSS =color= =to= another valid CSS color
format.

+ =convert(to, color) => string=
  - =to: string | "hex" | "rgb" | "hsl" | "cmyk" | "hwb" | "cielab" | "cielch" | "oklab" | "oklch"=: the target color
    format
  - =color: string=: the color to convert

***** convert Examples

***** convert Implementation

#+BEGIN_SRC js
export function convert(to, color) {
  if (to === "lab") {
    return serialize(_convert(color, "cielab"));
  }

  if (to === "lch") {
    return serialize(_convert(color, "cielch"));
  }

  return serialize(_convert(color, to));
}
#+END_SRC

***** convert Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/convert_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { convert } from "../../color.js";

describe("convert(to, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => convert("hex", "invalid")).toThrow();
  });

  const conversions = {
    hex: [
      ["black", "#000000"],
      ["gray", "#808080"],
      ["white", "#ffffff"],
      ["red", "#ff0000"],
      ["orange", "#ffa500"],
      ["yellow", "#ffff00"],
      ["lime", "#00ff00"],
      ["cyan", "#00ffff"],
      ["blue", "#0000ff"],
      ["purple", "#800080"],
      ["magenta", "#ff00ff"],
    ],
    rgb: [
      ["black", "rgb(0, 0, 0)"],
      ["gray", "rgb(128, 128, 128)"],
      ["white", "rgb(255, 255, 255)"],
      ["red", "rgb(255, 0, 0)"],
      ["orange", "rgb(255, 165, 0)"],
      ["yellow", "rgb(255, 255, 0)"],
      ["lime", "rgb(0, 255, 0)"],
      ["cyan", "rgb(0, 255, 255)"],
      ["blue", "rgb(0, 0, 255)"],
      ["purple", "rgb(128, 0, 128)"],
      ["magenta", "rgb(255, 0, 255)"],
    ],
    hsl: [
      ["black", "hsl(0, 0%, 0%)"],
      ["gray", "hsl(0, 0%, 50.196%)"],
      ["white", "hsl(0, 0%, 100%)"],
      ["red", "hsl(0, 100%, 50%)"],
      ["orange", "hsl(38.824, 100%, 50%)"],
      ["yellow", "hsl(60, 100%, 50%)"],
      ["lime", "hsl(120, 100%, 50%)"],
      ["cyan", "hsl(180, 100%, 50%)"],
      ["blue", "hsl(240, 100%, 50%)"],
      ["purple", "hsl(300, 100%, 25.098%)"],
      ["magenta", "hsl(300, 100%, 50%)"],
    ],
    cmyk: [
      ["black", "device-cmyk(0% 0% 0% 100%)"],
      ["gray", "device-cmyk(0% 0% 0% 49.804%)"],
      ["white", "device-cmyk(0% 0% 0% 0%)"],
      ["red", "device-cmyk(0% 100% 100% 0%)"],
      ["orange", "device-cmyk(0% 35.294% 100% 0%)"],
      ["yellow", "device-cmyk(0% 0% 100% 0%)"],
      ["lime", "device-cmyk(100% 0% 100% 0%)"],
      ["cyan", "device-cmyk(100% 0% 0% 0%)"],
      ["blue", "device-cmyk(100% 100% 0% 0%)"],
      ["purple", "device-cmyk(0% 100% 0% 49.804%)"],
      ["magenta", "device-cmyk(0% 100% 0% 0%)"],
    ],
    hwb: [
      ["black", "hwb(0 0% 100%)"],
      ["gray", "hwb(0 50.196% 49.804%)"],
      ["white", "hwb(0 100% 0%)"],
      ["red", "hwb(0 0% 0%)"],
      ["orange", "hwb(38.824 0% 0%)"],
      ["yellow", "hwb(60 0% 0%)"],
      ["lime", "hwb(120 0% 0%)"],
      ["cyan", "hwb(180 0% 0%)"],
      ["blue", "hwb(240 0% 0%)"],
      ["purple", "hwb(300 0% 49.804%)"],
      ["magenta", "hwb(300 0% 0%)"],
    ],
    lab: [
      ["black", "lab(0% 0 0)"],
      ["gray", "lab(53.585% 0 0)"],
      ["white", "lab(100% 0 0)"],
      ["red", "lab(54.292% 80.812 69.885)"],
      ["orange", "lab(75.59% 27.519 79.116)"],
      ["yellow", "lab(97.607% -15.753 93.388)"],
      ["lime", "lab(87.818% -79.287 80.99)"],
      ["cyan", "lab(90.665% -50.665 -14.962)"],
      ["blue", "lab(29.568% 68.299 -112.029)"],
      ["purple", "lab(29.692% 56.118 -36.291)"],
      ["magenta", "lab(60.17% 93.55 -60.499)"],
    ],
    lch: [
      ["black", "lch(0% 0 0)"],
      ["gray", "lch(53.585% 0 0)"],
      ["white", "lch(100% 0 0)"],
      ["red", "lch(54.292% 106.839 40.853)"],
      ["orange", "lch(75.59% 83.766 70.821)"],
      ["yellow", "lch(97.607% 94.708 99.575)"],
      ["lime", "lch(87.818% 113.34 134.391)"],
      ["cyan", "lch(90.665% 52.828 196.452)"],
      ["blue", "lch(29.568% 131.207 301.369)"],
      ["purple", "lch(29.692% 66.83 327.109)"],
      ["magenta", "lch(60.17% 111.408 327.109)"],
    ],
    oklab: [
      ["black", "oklab(0% 0 0)"],
      ["gray", "oklab(59.987% 0 0)"],
      ["white", "oklab(100% 0 0)"],
      ["red", "oklab(62.796% 0.22486 0.12585)"],
      ["orange", "oklab(79.269% 0.05661 0.16138)"],
      ["yellow", "oklab(96.798% -0.07137 0.19857)"],
      ["lime", "oklab(86.644% -0.23389 0.1795)"],
      ["cyan", "oklab(90.54% -0.14944 -0.0394)"],
      ["blue", "oklab(45.201% -0.03246 -0.31153)"],
      ["purple", "oklab(42.091% 0.1647 -0.10147)"],
      ["magenta", "oklab(70.167% 0.27457 -0.16916)"],
    ],
    oklch: [
      ["black", "oklch(0% 0 0)"],
      ["gray", "oklch(59.987% 0 0)"],
      ["white", "oklch(100% 0 0)"],
      ["red", "oklch(62.796% 0.25768 29.234)"],
      ["orange", "oklch(79.269% 0.17103 70.67)"],
      ["yellow", "oklch(96.798% 0.21101 109.769)"],
      ["lime", "oklch(86.644% 0.29483 142.495)"],
      ["cyan", "oklch(90.54% 0.15455 194.769)"],
      ["blue", "oklch(45.201% 0.31321 264.052)"],
      ["purple", "oklch(42.091% 0.19345 328.363)"],
      ["magenta", "oklch(70.167% 0.32249 328.363)"],
    ],
  };

  Object.entries(conversions).forEach(([format, samples]) => {
    describe(`to = '${format}'`, () => {
      it("should correctly convert all color samples", () => {
        samples.forEach(([input, output]) => {
          expect(convert(format, input)).toBe(output);
        });
      });
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/convert_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  convert(to, color)
  • should reject invalid colors
    to = 'hex'
    • should correctly convert all color samples
    to = 'rgb'
    • should correctly convert all color samples
    to = 'hsl'
    • should correctly convert all color samples
    to = 'cmyk'
    • should correctly convert all color samples
    to = 'hwb'
    • should correctly convert all color samples
    to = 'lab'
    • should correctly convert all color samples
    to = 'lch'
    • should correctly convert all color samples
    to = 'oklab'
    • should correctly convert all color samples
    to = 'oklch'
    • should correctly convert all color samples

running 10 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/convert_test.js
test convert(to, color) > should reject invalid colors ... ok (15ms)
test convert(to, color) > to = 'hex' > should correctly convert all color samples ... ok (22ms)
test convert(to, color) > to = 'rgb' > should correctly convert all color samples ... ok (11ms)
test convert(to, color) > to = 'hsl' > should correctly convert all color samples ... ok (9ms)
test convert(to, color) > to = 'cmyk' > should correctly convert all color samples ... ok (8ms)
test convert(to, color) > to = 'hwb' > should correctly convert all color samples ... ok (11ms)
test convert(to, color) > to = 'lab' > should correctly convert all color samples ... ok (8ms)
test convert(to, color) > to = 'lch' > should correctly convert all color samples ... ok (9ms)
test convert(to, color) > to = 'oklab' > should correctly convert all color samples ... ok (8ms)
test convert(to, color) > to = 'oklch' > should correctly convert all color samples ... ok (10ms)

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (159ms)

#+end_src

**** adjust

An action that adjusts the =properties= of a given valid CSS =color=. Positive property values will increase while
negative values will decrease.

If =steps= is defined, this triggers the interpolation behavior where the action will instead return the unique
results of adjusting the defined =properties= color in /sequence/ up to the set number of =steps=.

+ =adjust(properties, color) => string | string[]=
  - =properties: {}=: the color properties to adjust
    * =properties.lightness = 0: number=: adjust the color's lightness (as a percentage)
    * =properties.chroma = 0: number=: adjust the color's chroma (as a percentage)
    * =properties.hue = 0: number=: adjust the color's hue (in degrees)
    * =properties.alpha = 0: number=: adjust the color's transparency (as a percentage)
    * =properties.steps = 0: number=: triggers color interpolation mode (if greater than 0)
  - =color: string=: the color to adjust

***** adjust Examples

***** adjust Implementation

#+BEGIN_SRC js
export function adjust(settings, color) {
  // Do nothing by default
  const { lightness = 0, chroma = 0, hue = 0, alpha = 0, steps } = settings;

  if (steps) {
    return colorInterpolation(
      colorAdjustment,
      {
        lightness,
        chroma,
        hue,
        alpha,
        steps,
      },
      color,
    );
  }

  return colorAdjustment({ lightness, chroma, hue, alpha }, color);
}
#+END_SRC

***** adjust Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/adjust_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { adjust } from "../../color.js";

describe("adjust(settings, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => adjust({}, "invalid")).toThrow();
  });

  it("should correctly adjust lightness of samples", () => {
    expect(adjust({ lightness: -25 }, "white")).toBe("#aeaeae");
    expect(adjust({ lightness: 25 }, "gray")).toBe("#cdcdcd");
    expect(adjust({ lightness: 50 }, "black")).toBe("#636363");
    expect(adjust({ lightness: -25 }, "red")).toBe("#a10000");
    expect(adjust({ lightness: 10 }, "orange")).toBe("#ffc644");
    expect(adjust({ lightness: -16 }, "yellow")).toBe("#cbc900");
    expect(adjust({ lightness: -32 }, "lime")).toBe("#009300");
    expect(adjust({ lightness: 16 }, "cyan")).toBe("#54ffff");
    expect(adjust({ lightness: 32 }, "blue")).toBe("#479dff");
    expect(adjust({ lightness: 24 }, "purple")).toBe("#cf5fcc");
    expect(adjust({ lightness: -24 }, "magenta")).toBe("#a900ad");
  });

  it("should correctly adjust chroma of samples", () => {
    expect(adjust({ chroma: 50 }, "white")).toBe("#ffdbfc");
    expect(adjust({ chroma: 50 }, "gray")).toBe("#bb5d7d");
    expect(adjust({ chroma: 75 }, "black")).toBe("#060000");
    expect(adjust({ chroma: -25 }, "red")).toBe("#e64a3b");
    expect(adjust({ chroma: -10 }, "orange")).toBe("#f6a941");
    expect(adjust({ chroma: -16 }, "yellow")).toBe("#fcfe66");
    expect(adjust({ chroma: -32 }, "lime")).toBe("#71f56a");
    expect(adjust({ chroma: -75 }, "cyan")).toBe("#e0e0e0");
    expect(adjust({ chroma: 32 }, "blue")).toBe("#1e00ff");
    expect(adjust({ chroma: 24 }, "purple")).toBe("#8d008f");
    expect(adjust({ chroma: -24 }, "magenta")).toBe("#f04bee");
  });

  it("should correctly adjust hue of samples", () => {
    expect(adjust({ hue: 30 }, "white")).toBe("#ffffff");
    expect(adjust({ hue: 60 }, "gray")).toBe("#808080");
    expect(adjust({ hue: 90 }, "black")).toBe("#000000");
    expect(adjust({ hue: 150 }, "red")).toBe("#00b48c");
    expect(adjust({ hue: 180 }, "orange")).toBe("#5bc0ff");
    expect(adjust({ hue: 210 }, "yellow")).toBe("#ffc2ff");
    expect(adjust({ hue: 240 }, "lime")).toBe("#ff6072");
    expect(adjust({ hue: 270 }, "cyan")).toBe("#f0e55d");
    expect(adjust({ hue: 300 }, "blue")).toBe("#0075a4");
    expect(adjust({ hue: 330 }, "purple")).toBe("#5e21a6");
    expect(adjust({ hue: 360 }, "magenta")).toBe("#ff00ff");
  });

  it("should correctly adjust alpha of samples", () => {
    expect(adjust({ alpha: -10 }, "white")).toBe("#ffffffe6");
    expect(adjust({ alpha: -20 }, "gray")).toBe("#808080cc");
    expect(adjust({ alpha: -30 }, "black")).toBe("#000000b3");
    expect(adjust({ alpha: -40 }, "red")).toBe("#ff000099");
    expect(adjust({ alpha: -50 }, "orange")).toBe("#ffa50080");
    expect(adjust({ alpha: -60 }, "yellow")).toBe("#ffff0066");
    expect(adjust({ alpha: -70 }, "lime")).toBe("#00ff004d");
    expect(adjust({ alpha: -80 }, "cyan")).toBe("#00ffff33");
    expect(adjust({ alpha: -90 }, "blue")).toBe("#0000ff1a");
    expect(adjust({ alpha: -100 }, "purple")).toBe("#80008000");
    expect(adjust({ alpha: -110 }, "magenta")).toBe("#ff00ff00");
  });

  it("should allow interpolation when settings.steps is defined", () => {
    expect(
      adjust({ lightness: -25, chroma: 50, steps: 10 }, "white"),
    ).toEqual([
      "#fff3f6",
      "#fee8ee",
      "#fddce5",
      "#fcd1dc",
      "#fac5d4",
      "#f8bacc",
      "#f6aec3",
      "#f3a3bb",
      "#f197b3",
      "#ee8bab",
    ]);
    expect(
      adjust({ lightness: 25, chroma: 50, steps: 10 }, "gray"),
    ).toEqual([
      "#8e8587",
      "#9d898e",
      "#ab8e96",
      "#ba929d",
      "#c896a4",
      "#d69aac",
      "#e59eb3",
      "#f3a3bb",
      "#ffa7c3",
      "#ffaaca",
    ]);
    expect(
      adjust({ lightness: 50, chroma: 75, steps: 10 }, "black"),
    ).toEqual([
      "#010000",
      "#0b0003",
      "#1c010a",
      "#2e0215",
      "#420420",
      "#56072b",
      "#6b0b38",
      "#811044",
      "#981551",
      "#b01a5f",
    ]);
    expect(
      adjust({ lightness: -25, chroma: -25, hue: 150, steps: 10 }, "red"),
    ).toEqual([
      "#ef2200",
      "#d93900",
      "#bf4c00",
      "#a05a00",
      "#7c6300",
      "#536900",
      "#066b00",
      "#006a00",
      "#006527",
      "#005d44",
    ]);
    expect(
      adjust(
        { lightness: 10, chroma: -10, hue: 180, steps: 10 },
        "orange",
      ),
    ).toEqual([
      "#ebb700",
      "#cfc824",
      "#aed754",
      "#85e27f",
      "#55eba9",
      "#01efd0",
      "#00f0f4",
      "#1bedff",
      "#5ee8ff",
      "#8ee2ff",
    ]);
    expect(
      adjust(
        { lightness: -16, chroma: -16, hue: 210, steps: 10 },
        "yellow",
      ),
    ).toEqual([
      "#beff67",
      "#69ffa3",
      "#00ffd7",
      "#00ffff",
      "#00f8ff",
      "#00e5ff",
      "#7cd1ff",
      "#b0bcff",
      "#d5a9ff",
      "#f099ff",
    ]);
    expect(
      adjust(
        { lightness: -32, chroma: -32, hue: 240, steps: 10 },
        "lime",
      ),
    ).toEqual([
      "#00fe9e",
      "#00f0e8",
      "#00d7ff",
      "#00b6ff",
      "#4192ff",
      "#9270ff",
      "#ba52f5",
      "#cf36ba",
      "#d71b78",
      "#d10f2f",
    ]);
    expect(
      adjust({ lightness: 16, chroma: -75, hue: 270, steps: 10 }, "cyan"),
    ).toEqual([
      "#6af9ff",
      "#abf1ff",
      "#ddebff",
      "#ffe9ff",
      "#ffecff",
      "#fff4ff",
      "#fff9f8",
      "#fffefc",
      "#ffffff",
    ]);
    expect(
      adjust({ lightness: 32, chroma: 32, hue: 300, steps: 10 }, "blue"),
    ).toEqual([
      "#7700fc",
      "#b700cd",
      "#eb007e",
      "#ff0000",
      "#ee5b00",
      "#9ea300",
      "#00d200",
      "#00eb98",
      "#00eaff",
    ]);
    expect(
      adjust(
        { lightness: 24, chroma: 24, hue: 330, steps: 10 },
        "purple",
      ),
    ).toEqual([
      "#a1004d",
      "#b10000",
      "#aa3700",
      "#876400",
      "#2d8600",
      "#009b55",
      "#009fb2",
      "#0092f9",
      "#4179ff",
      "#aa5eff",
    ]);
    expect(
      adjust(
        { lightness: -24, chroma: -24, hue: 360, steps: 10 },
        "magenta",
      ),
    ).toEqual([
      "#ff0080",
      "#ff0000",
      "#e95500",
      "#8c8a00",
      "#00a200",
      "#009f88",
      "#0082da",
      "#0050fd",
      "#6e05e5",
      "#9c009e",
    ]);
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/adjust_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  adjust(settings, color)
  • should reject invalid colors
  • should correctly adjust lightness of samples
  • should correctly adjust chroma of samples
  • should correctly adjust hue of samples
  • should correctly adjust alpha of samples
  • should allow interpolation when settings.steps is defined

running 6 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/adjust_test.js
test adjust(settings, color) > should reject invalid colors ... ok (14ms)
test adjust(settings, color) > should correctly adjust lightness of samples ... ok (30ms)
test adjust(settings, color) > should correctly adjust chroma of samples ... ok (14ms)
test adjust(settings, color) > should correctly adjust hue of samples ... ok (15ms)
test adjust(settings, color) > should correctly adjust alpha of samples ... ok (14ms)
test adjust(settings, color) > should allow interpolation when settings.steps is defined ... ok (102ms)

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (239ms)

#+end_src

**** mix

An action that mixes an input =color= and a =target= color with a set level of =strength=.

If steps is defined, this triggers the blending behavior where the action will instead return the unique results of
mixing the colors in /sequence/ up to the set number of =steps=.

+ =mix(settings, color) => string | string[]=
  - =settings: {}=: the mixture options to set
    * =settings.target = color: string=: set the target (any valid CSS color)
    * =settings.strength = 0: number=: set the strength (as a percentage, negative values reverse the direction)
    * =properties.steps = 0: number=: triggers color blending mode (if greater than 0)
  - =color: string=: the color to mix

***** mix Examples

***** mix Implementation

#+BEGIN_SRC js
export function mix(settings, color) {
  // Do nothing by default
  const { target = color, strength = 0, steps } = settings;

  if (steps) {
    return colorInterpolation(colorMix, { target, strength, steps }, color);
  }

  return colorMix({ target, strength }, color);
}
#+END_SRC

***** mix Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/mix_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { adjust, mix } from "../../color.js";

describe("mix(settings, color)", () => {
  const samples = [
    ["red", ["#ff0000", "#ff4b00", "#ff6e00", "#ff8b00", "#ffa500"], "orange"],
    [
      "orange",
      ["#ffa500", "#ffbc00", "#ffd200", "#ffe900", "#ffff00"],
      "yellow",
    ],
    ["yellow", ["#ffff00", "#daff00", "#b0ff00", "#7cff00", "#00ff00"], "lime"],
    ["lime", ["#00ff00", "#00ff74", "#00ffa9", "#00ffd6", "#00ffff"], "cyan"],
    ["cyan", ["#00ffff", "#00d1ff", "#00a0ff", "#006aff", "#0000ff"], "blue"],
    ["blue", ["#0000ff", "#381fde", "#5424be", "#6b1e9f", "#800080"], "purple"],
    [
      "purple",
      ["#800080", "#9e009e", "#bd00bd", "#de00de", "#ff00ff"],
      "magenta",
    ],
  ];

  const negations = [
    [
      "red",
      ["#ff0000", "#de5e58", "#b78087", "#8497b2", "#00a9db"],
      adjust({ hue: 180 }, "red"),
    ],
    [
      "orange",
      ["#ffa500", "#dfb172", "#bbb9a7", "#92bed4", "#5bc0ff"],
      adjust({ hue: 180 }, "orange"),
    ],
    [
      "yellow",
      ["#ffff00", "#fbf77c", "#f8eeb0", "#f6e4da", "#f4d8ff"],
      adjust({ hue: 180 }, "yellow"),
    ],
    [
      "lime",
      ["#00ff00", "#8ce77c", "#becbb0", "#e2aada", "#ff7dff"],
      adjust({ hue: 180 }, "lime"),
    ],
    [
      "cyan",
      ["#00ffff", "#8beeef", "#bddcdf", "#e2c9cf", "#ffb3bf"],
      adjust({ hue: 180 }, "cyan"),
    ],
    [
      "blue",
      ["#0000ff", "#383cc8", "#5e4592", "#803e5a", "#a02000"],
      adjust({ hue: 180 }, "blue"),
    ],
    [
      "purple",
      ["#800080", "#6f366a", "#5a4b52", "#3f5a37", "#006600"],
      adjust({ hue: 180 }, "purple"),
    ],
    [
      "magenta",
      ["#ff00ff", "#de72d5", "#b79ba9", "#85b774", "#00cd00"],
      adjust({ hue: 180 }, "magenta"),
    ],
  ];

  const blends = [
    ["red", ["#f2674f", "#df957e", "#c3bca9", "#94ded4", "#00ffff"], "cyan"],
    ["orange", ["#ca9b75", "#978ca2", "#6377c5", "#2e57e3", "#0000ff"], "blue"],
    [
      "yellow",
      ["#e6d25a", "#cda673", "#b47a7e", "#9a4c82", "#800080"],
      "purple",
    ],
    [
      "lime",
      ["#87e374", "#b5c4a2", "#d4a1c5", "#ec73e4", "#ff00ff"],
      "magenta",
    ],
    ["cyan", ["#94ded4", "#c3bca9", "#df957e", "#f2674f", "#ff0000"], "red"],
    ["blue", ["#2e57e3", "#6377c5", "#978ca2", "#ca9b75", "#ffa500"], "orange"],
    [
      "purple",
      ["#9a4c82", "#b47a7e", "#cda673", "#e6d25a", "#ffff00"],
      "yellow",
    ],
    [
      "magenta",
      ["#ec73e4", "#d4a1c5", "#b5c4a2", "#87e374", "#00ff00"],
      "lime",
    ],
  ];

  it("should reject an invalid color", () => {
    expect(() => mix({ target: "blue" }, "invalid")).toThrow();
  });

  it("should reject an invalid target", () => {
    expect(() => mix({ target: "invalid" }, "red")).toThrow();
  });

  it("should correctly mix samples", () => {
    samples.forEach(([color, results, target]) => {
      results.forEach((output, index) => {
        expect(mix({ target, strength: index * 25 }, color)).toBe(output);
      });
    });
  });

  it("should correctly negate opposites", () => {
    negations.forEach(([color, results, target]) => {
      results.forEach((output, index) => {
        expect(mix({ target, strength: index * 25 }, color)).toBe(output);
      });
    });
  });

  it("should allow blending when settings.steps is defined", () => {
    blends.forEach(([color, results, target]) => {
      expect(mix({ target, strength: 100, steps: 5 }, color)).toEqual(
        results,
      );
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/mix_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  mix(settings, color)
  • should reject an invalid color
  • should reject an invalid target
  • should correctly mix samples
  • should correctly negate opposites
  • should allow blending when settings.steps is defined

running 5 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/mix_test.js
test mix(settings, color) > should reject an invalid color ... ok (11ms)
test mix(settings, color) > should reject an invalid target ... ok (8ms)
test mix(settings, color) > should correctly mix samples ... ok (48ms)
test mix(settings, color) > should correctly negate opposites ... ok (56ms)
test mix(settings, color) > should allow blending when settings.steps is defined ... ok (63ms)

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (261ms)

#+end_src

**** harmony

An action for creating conventional color harmonies from any valid CSS =color=. This action will generate a harmony
based on its =configuration= and you can create =accented= versions that include the complement as well.

+ =harmony(settings, color) => string[]=
  - =settings: {}=: color harmony settings
    * =settings.configuration = "complementary": "dyadic" | "complementary" | "analogous" | "split" | "triadic" |
      "clash" | "double" | "tetradic" | "square"=: the color harmony configuration
    * =settings.accented = false: boolean=: do you want to use the accented form (where applicable)?
  - =color: string=: the color to harmony

***** harmony Examples

***** harmony Implementation

#+BEGIN_SRC js
export function harmony(settings, color) {
  // Set defaults
  const { configuration = "complementary", accented = false } = settings;

  return colorHarmonies({ type: configuration, accented }, color);
}
#+END_SRC

***** harmony Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/harmony_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { harmony } from "../../color.js";

describe("harmony(settings, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => harmony({}, "invalid")).toThrow();
  });

  const harmonies = {
    dyadic: [
      ["red", ["#ff0000", "#ef4600"]],
      ["orange", ["#ffa500", "#d4bd00"]],
      ["yellow", ["#ffff00", "#a2ff86"]],
      ["lime", ["#00ff00", "#00ffbe"]],
      ["cyan", ["#00ffff", "#48f5ff"]],
      ["blue", ["#0000ff", "#6e00ec"]],
      ["purple", ["#800080", "#95004c"]],
      ["magenta", ["#ff00ff", "#ff009d"]],
    ],
    complementary: [
      ["red", ["#ff0000", "#00a9db"]],
      ["orange", ["#ffa500", "#5bc0ff"]],
      ["yellow", ["#ffff00", "#f4d8ff"]],
      ["lime", ["#00ff00", "#ff7dff"]],
      ["cyan", ["#00ffff", "#ffb3bf"]],
      ["blue", ["#0000ff", "#a02000"]],
      ["purple", ["#800080", "#006600"]],
      ["magenta", ["#ff00ff", "#00cd00"]],
    ],
    analogous: [
      ["red", ["#ff0000", "#ef4600", "#c57500"]],
      ["orange", ["#ffa500", "#d4bd00", "#95d150"]],
      ["yellow", ["#ffff00", "#a2ff86", "#00ffde"]],
      ["lime", ["#00ff00", "#00ffbe", "#00ffff"]],
      ["cyan", ["#00ffff", "#48f5ff", "#96e3ff"]],
      ["blue", ["#0000ff", "#6e00ec", "#9e00b2"]],
      ["purple", ["#800080", "#95004c", "#9c0000"]],
      ["magenta", ["#ff00ff", "#ff009d", "#ff0000"]],
    ],
    split: [
      ["red", ["#ff0000", "#00b48c", "#0090ff"]],
      ["orange", ["#ffa500", "#00d2ff", "#a9acff"]],
      ["yellow", ["#ffff00", "#9cf3ff", "#ffc2ff"]],
      ["lime", ["#00ff00", "#df9eff", "#ff62e5"]],
      ["cyan", ["#00ffff", "#ffb4f8", "#ffbd87"]],
      ["blue", ["#0000ff", "#c50000", "#5d5c00"]],
      ["purple", ["#800080", "#475700", "#006a4e"]],
      ["magenta", ["#ff00ff", "#92b100", "#00d5a0"]],
    ],
    triadic: [
      ["red", ["#ff0000", "#00ae00", "#4f6fff"]],
      ["orange", ["#ffa500", "#00dcd5", "#de99ff"]],
      ["yellow", ["#ffff00", "#00ffff", "#ffb3ff"]],
      ["lime", ["#00ff00", "#61c4ff", "#ff6072"]],
      ["cyan", ["#00ffff", "#ffbfff", "#ffd05c"]],
      ["blue", ["#0000ff", "#ce0000", "#007700"]],
      ["purple", ["#800080", "#773e00", "#006384"]],
      ["magenta", ["#ff00ff", "#ef8200", "#00c8ff"]],
    ],
    clash: [
      ["red", ["#ff0000", "#7b9900", "#a34fff"]],
      ["orange", ["#ffa500", "#23dc96", "#ff8cdc"]],
      ["yellow", ["#ffff00", "#00ffff", "#ffb3b9"]],
      ["lime", ["#00ff00", "#00e9ff", "#ff8300"]],
      ["cyan", ["#00ffff", "#d5d0ff", "#f0e55d"]],
      ["blue", ["#0000ff", "#c00061", "#008048"]],
      ["purple", ["#800080", "#931700", "#0051a8"]],
      ["magenta", ["#ff00ff", "#ff3800", "#00a6ff"]],
    ],
    double: [
      ["red", ["#ff0000", "#ef4600", "#00a9db", "#0090ff"]],
      ["orange", ["#ffa500", "#d4bd00", "#5bc0ff", "#a9acff"]],
      ["yellow", ["#ffff00", "#a2ff86", "#f4d8ff", "#ffc2ff"]],
      ["lime", ["#00ff00", "#00ffbe", "#ff7dff", "#ff62e5"]],
      ["cyan", ["#00ffff", "#48f5ff", "#ffb3bf", "#ffbd87"]],
      ["blue", ["#0000ff", "#6e00ec", "#a02000", "#5d5c00"]],
      ["purple", ["#800080", "#95004c", "#006600", "#006a4e"]],
      ["magenta", ["#ff00ff", "#ff009d", "#00cd00", "#00d5a0"]],
    ],
    tetradic: [
      ["red", ["#ff0000", "#de5f00", "#00a9db", "#0080ff"]],
      ["orange", ["#ffa500", "#b7c826", "#5bc0ff", "#c5a2ff"]],
      ["yellow", ["#ffff00", "#5bffb3", "#f4d8ff", "#ffb9ff"]],
      ["lime", ["#00ff00", "#00fff5", "#ff7dff", "#ff5cb0"]],
      ["cyan", ["#00ffff", "#72edff", "#ffb3bf", "#ffc56e"]],
      ["blue", ["#0000ff", "#8800d3", "#a02000", "#016c00"]],
      ["purple", ["#800080", "#9b002d", "#006600", "#00686b"]],
      ["magenta", ["#ff00ff", "#ff0061", "#00cd00", "#00d1d7"]],
    ],
    square: [
      ["red", ["#ff0000", "#7b9900", "#00a9db", "#a34fff"]],
      ["orange", ["#ffa500", "#23dc96", "#5bc0ff", "#ff8cdc"]],
      ["yellow", ["#ffff00", "#00ffff", "#f4d8ff", "#ffb3b9"]],
      ["lime", ["#00ff00", "#00e9ff", "#ff7dff", "#ff8300"]],
      ["cyan", ["#00ffff", "#d5d0ff", "#ffb3bf", "#f0e55d"]],
      ["blue", ["#0000ff", "#c00061", "#a02000", "#008048"]],
      ["purple", ["#800080", "#931700", "#006600", "#0051a8"]],
      ["magenta", ["#ff00ff", "#ff3800", "#00cd00", "#00a6ff"]],
    ],
  };

  Object.entries(harmonies).forEach(([configuration, samples]) => {
    describe(`settings.configuration = '${configuration}'`, () => {
      it(`should correctly generate a ${configuration} color harmony from samples`, () => {
        samples.forEach(([input, output]) => {
          expect(harmony({ configuration }, input)).toEqual(output);
        });
      });
    });
  });

  const harmoniesAccented = {
    dyadic: [
      ["red", ["#ff0000", "#ef4600", "#00a9db"]],
      ["orange", ["#ffa500", "#d4bd00", "#5bc0ff"]],
      ["yellow", ["#ffff00", "#a2ff86", "#f4d8ff"]],
      ["lime", ["#00ff00", "#00ffbe", "#ff7dff"]],
      ["cyan", ["#00ffff", "#48f5ff", "#ffb3bf"]],
      ["blue", ["#0000ff", "#6e00ec", "#a02000"]],
      ["purple", ["#800080", "#95004c", "#006600"]],
      ["magenta", ["#ff00ff", "#ff009d", "#00cd00"]],
    ],
    analogous: [
      ["red", ["#ff0000", "#ef4600", "#c57500", "#00a9db"]],
      ["orange", ["#ffa500", "#d4bd00", "#95d150", "#5bc0ff"]],
      ["yellow", ["#ffff00", "#a2ff86", "#00ffde", "#f4d8ff"]],
      ["lime", ["#00ff00", "#00ffbe", "#00ffff", "#ff7dff"]],
      ["cyan", ["#00ffff", "#48f5ff", "#96e3ff", "#ffb3bf"]],
      ["blue", ["#0000ff", "#6e00ec", "#9e00b2", "#a02000"]],
      ["purple", ["#800080", "#95004c", "#9c0000", "#006600"]],
      ["magenta", ["#ff00ff", "#ff009d", "#ff0000", "#00cd00"]],
    ],
    split: [
      ["red", ["#ff0000", "#00b48c", "#00a9db", "#0090ff"]],
      ["orange", ["#ffa500", "#00d2ff", "#5bc0ff", "#a9acff"]],
      ["yellow", ["#ffff00", "#9cf3ff", "#f4d8ff", "#ffc2ff"]],
      ["lime", ["#00ff00", "#df9eff", "#ff7dff", "#ff62e5"]],
      ["cyan", ["#00ffff", "#ffb4f8", "#ffb3bf", "#ffbd87"]],
      ["blue", ["#0000ff", "#c50000", "#a02000", "#5d5c00"]],
      ["purple", ["#800080", "#475700", "#006600", "#006a4e"]],
      ["magenta", ["#ff00ff", "#92b100", "#00cd00", "#00d5a0"]],
    ],
    triadic: [
      ["red", ["#ff0000", "#00ae00", "#00a9db", "#4f6fff"]],
      ["orange", ["#ffa500", "#00dcd5", "#5bc0ff", "#de99ff"]],
      ["yellow", ["#ffff00", "#00ffff", "#f4d8ff", "#ffb3ff"]],
      ["lime", ["#00ff00", "#61c4ff", "#ff7dff", "#ff6072"]],
      ["cyan", ["#00ffff", "#ffbfff", "#ffb3bf", "#ffd05c"]],
      ["blue", ["#0000ff", "#ce0000", "#a02000", "#007700"]],
      ["purple", ["#800080", "#773e00", "#006600", "#006384"]],
      ["magenta", ["#ff00ff", "#ef8200", "#00cd00", "#00c8ff"]],
    ],
  };

  Object.entries(harmoniesAccented).forEach(([configuration, samples]) => {
    describe(`settings.configuration = '${configuration}'`, () => {
      it(`should correctly generate an accented ${configuration} color harmony from samples`, () => {
        samples.forEach(([input, output]) => {
          expect(harmony({ configuration, accented: true }, input)).toEqual(output);
        });
      });
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/harmony_test.js
#+END_SRC

**** vision

A perception checking color action that simulates the influence of color vision deficiency (or colorblindness) on a
=color=.

The available =methods= are =brettel= and =vienot= and you can set the =severity= when simulating an anomalous
trichromacy =type= (=protanomaly=, =deuteranonmaly=, =tritanomaly=).

In addition, severity is /deactivated/ when =type= simulates dichromacy (=protanopia=, =deuteranopia=, =tritanopia=) or
=achromatopsia=.

If =steps= is >0 this activates an interpolated simulation sequence. This is useful for observing multiple simulation
conditions at once.

+ =vision(settings, color) => string | string[]=
  - =settings: {}=: color vision simulation settings
    * =settings.as = "protanopia": "achromatopsia" | "protanomaly" | "protanopia" | "deuteranomaly" | "deuteranopia" |
      "tritanomaly" | "tritanopia"=: set the type of colorblindness to simulate
    * =settings.method = "brettel": "brettel" | "vienot"=: selects the simulation method (~"brettel"~ is active for
      ~tritanomaly~, ~tritanopia~ regardless of method because it's the only known accurate method for those.
    * =settings.severity = 50: number=: set the severity for anomalous
      trichromacy types (as a percentage)
    * =settings.steps = 0: number=: activates interpolated simulation when >0
  - =color: string=: the color to influence

***** vision Examples

***** vision Implementation

#+BEGIN_SRC js
export function vision(settings, color) {
  // Set defaults
  const { as = "protanopia", method = "brettel", steps = 0 } = settings;

  // Achromatopsia through reducing the chroma to zero
  if (as === "achromatopsia") {
    const chroma = -100;

    if (steps) {
      return colorInterpolation(colorAdjustment, { chroma, steps }, color);
    }

    return colorAdjustment({ chroma }, color);
  }

  // Protanomaly, Deuteranomaly, and Tritanomaly have a severity setting
  if (as.endsWith("anomaly")) {
    let type = as.replace(/anomaly/g, "anope");
    const { severity = 50 } = settings;

    if (steps) {
      return colorInterpolation(
        checkColorblindness,
        { method, type, strength: severity, steps },
        color,
      );
    }

    return checkColorblindness(
      { method, type, strength: severity, steps },
      color,
    );
  }

  // Protanopia, Deuteranopia, Tritanopia by definition do not
  const type = as.replace(/anopia/g, "anope");

  if (steps) {
    return colorInterpolation(
      checkColorblindness,
      { method, type, strength: 100, steps },
      color,
    );
  }

  return checkColorblindness({ method, type, strength: 100 }, color);
}
#+END_SRC

***** vision Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/vision_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { vision } from "../../color.js";

describe("vision(settings, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => vision({}, "invalid")).toThrow();
  });

  const [red, green, blue, purple] = [
    "crimson",
    "chartreuse",
    "dodgerblue",
    "rebeccapurple",
  ];

  const visionSamples = {
    achromatopsia: {
      red: [red, "#787878"],
      green: [green, "#d6ddd4"],
      blue: [blue, "#909090"],
      purple: [purple, "#525252"],
    },
    protanomaly: {
      brettel: {
        red: [red, ["#dc143c", "#c62d3c", "#ab3d3d", "#8a483d"]],
        green: [green, ["#7fff00", "#b6fb00", "#ddf800", "#fcf400"]],
        blue: [blue, ["#1e90ff", "#2090ff", "#2290ff", "#2390ff"]],
        purple: [purple, ["#663399", "#543799", "#3d3b99", "#0a3f99"]],
      },
      vienot: {
        red: [red, ["#dc143c", "#c52e3c", "#aa3d3d", "#87493d"]],
        green: [green, ["#7fff00", "#a7fd00", "#c6fa00", "#dff700"]],
        blue: [blue, ["#1e90ff", "#4c8eff", "#658cff", "#798bff"]],
        purple: [purple, ["#663399", "#5e3599", "#543799", "#493999"]],
      },
    },
    protanopia: {
      brettel: {
        red: [red, ["#59523e"]],
        green: [green, ["#fff000"]],
        blue: [blue, ["#2590ff"]],
        purple: [purple, ["#004299"]],
      },
      vienot: {
        red: [red, ["#53533e"]],
        green: [green, ["#f5f500"]],
        blue: [blue, ["#8989ff"]],
        purple: [purple, ["#3b3b99"]],
      },
    },
    deuteranomaly: {
      brettel: {
        red: [red, ["#dc143c", "#cc4239", "#ba5937", "#a56b34"]],
        green: [green, ["#7fff00", "#aaf612", "#c9ed1c", "#e4e324"]],
        blue: [blue, ["#1e90ff", "#1f90ff", "#2190ff", "#2290ff"]],
        purple: [purple, ["#663399", "#593d99", "#4a4599", "#364c98"]],
      },
      vienot: {
        red: [red, ["#dc143c", "#ca4539", "#b65e36", "#9e7033"]],
        green: [green, ["#7fff00", "#a0f80e", "#baf217", "#d0eb1e"]],
        blue: [blue, ["#1e90ff", "#458bff", "#5c86ff", "#6d81ff"]],
        purple: [purple, ["#663399", "#5f3999", "#583e99", "#504299"]],
      },
    },
    deuteranopia: {
      brettel: {
        red: [red, ["#8c7a31"]],
        green: [green, ["#fbd82a"]],
        blue: [blue, ["#2390ff"]],
        purple: [purple, ["#0e5398"]],
      },
      vienot: {
        red: [red, ["#808030"]],
        green: [green, ["#e3e324"]],
        blue: [blue, ["#7c7cff"]],
        purple: [purple, ["#474799"]],
      },
    },
    // Brettel 1997 is the only known accurate tritanope simulating algorithm, so both
    // methods use it by default.
    tritanomaly: {
      brettel: {
        red: [red, ["#dc143c", "#dc123f", "#dc1042", "#dc0e45"]],
        green: [green, ["#7fff00", "#8bfa8c", "#95f5bf", "#9ff0e5"]],
        blue: [blue, ["#1e90ff", "#0094f2", "#0098e4", "#009cd5"]],
        purple: [purple, ["#663399", "#623b8b", "#5e417b", "#5a4767"]],
      },
      vienot: {
        red: [red, ["#dc143c", "#dc123f", "#dc1042", "#dc0e45"]],
        green: [green, ["#7fff00", "#8bfa8c", "#95f5bf", "#9ff0e5"]],
        blue: [blue, ["#1e90ff", "#0094f2", "#0098e4", "#009cd5"]],
        purple: [purple, ["#663399", "#623b8b", "#5e417b", "#5a4767"]],
      },
    },
    tritanopia: {
      brettel: {
        red: [red, ["#dc0c48"]],
        green: [green, ["#a7ebff"]],
        blue: [blue, ["#00a0c5"]],
        purple: [purple, ["#554c4d"]],
      },
      vienot: {
        red: [red, ["#dc0c48"]],
        green: [green, ["#a7ebff"]],
        blue: [blue, ["#00a0c5"]],
        purple: [purple, ["#554c4d"]],
      },
    },
  };

  describe("settings.as = 'achromatopsia'", () => {
    it("should correctly simulate achromatopsia", () => {
      Object.values(visionSamples.achromatopsia).forEach(([input, output]) => {
        expect(
          vision(
            {
              as: "achromatopsia",
            },
            input,
          ),
        ).toBe(output);
      });
    });
  });

  Object.entries(visionSamples)
    .filter(([category]) => category !== "achromatopsia")
    .forEach(([as, data]) => {
      describe(`settings.as = '${as}'`, () => {
        Object.entries(data).forEach(([method, $data]) => {
          it(`should correctly simulate ${as} with ${method} method on samples`, () => {
            Object.values($data).forEach(([input, results]) => {
              results.forEach((output, pos) => {
                expect(
                  vision(
                    {
                      method,
                      as,
                      severity: 25 * pos,
                    },
                    input,
                  ),
                ).toBe(output);
              });
            });
          });
        });
      });
    });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/vision_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  vision(settings, color)
  • should reject invalid colors
    settings.as = 'achromatopsia'
    • should correctly simulate achromatopsia
    settings.as = 'protanomaly'
    • should correctly simulate protanomaly with brettel method on samples
    • should correctly simulate protanomaly with vienot method on samples
    settings.as = 'protanopia'
    • should correctly simulate protanopia with brettel method on samples
    • should correctly simulate protanopia with vienot method on samples
    settings.as = 'deuteranomaly'
    • should correctly simulate deuteranomaly with brettel method on samples
    • should correctly simulate deuteranomaly with vienot method on samples
    settings.as = 'deuteranopia'
    • should correctly simulate deuteranopia with brettel method on samples
    • should correctly simulate deuteranopia with vienot method on samples
    settings.as = 'tritanomaly'
    • should correctly simulate tritanomaly with brettel method on samples
    • should correctly simulate tritanomaly with vienot method on samples
    settings.as = 'tritanopia'
    • should correctly simulate tritanopia with brettel method on samples
    • should correctly simulate tritanopia with vienot method on samples

running 14 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/vision_test.js
test vision(settings, color) > should reject invalid colors ... ok (22ms)
test vision(settings, color) > settings.as = 'achromatopsia' > should correctly simulate achromatopsia ... ok (27ms)
test vision(settings, color) > settings.as = 'protanomaly' > should correctly simulate protanomaly with brettel method on samples ... ok (32ms)
test vision(settings, color) > settings.as = 'protanomaly' > should correctly simulate protanomaly with vienot method on samples ... ok (27ms)
test vision(settings, color) > settings.as = 'protanopia' > should correctly simulate protanopia with brettel method on samples ... ok (10ms)
test vision(settings, color) > settings.as = 'protanopia' > should correctly simulate protanopia with vienot method on samples ... ok (12ms)
test vision(settings, color) > settings.as = 'deuteranomaly' > should correctly simulate deuteranomaly with brettel method on samples ... ok (27ms)
test vision(settings, color) > settings.as = 'deuteranomaly' > should correctly simulate deuteranomaly with vienot method on samples ... ok (26ms)
test vision(settings, color) > settings.as = 'deuteranopia' > should correctly simulate deuteranopia with brettel method on samples ... ok (10ms)
test vision(settings, color) > settings.as = 'deuteranopia' > should correctly simulate deuteranopia with vienot method on samples ... ok (12ms)
test vision(settings, color) > settings.as = 'tritanomaly' > should correctly simulate tritanomaly with brettel method on samples ... ok (27ms)
test vision(settings, color) > settings.as = 'tritanomaly' > should correctly simulate tritanomaly with vienot method on samples ... ok (33ms)
test vision(settings, color) > settings.as = 'tritanopia' > should correctly simulate tritanopia with brettel method on samples ... ok (11ms)
test vision(settings, color) > settings.as = 'tritanopia' > should correctly simulate tritanopia with vienot method on samples ... ok (23ms)

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (388ms)

#+end_src

**** contrast

A perception checking color action that simulates the influence of contrast sensitivity on a =color=.

You can set a contrast =factor= as a percentage (with ~0~ translating to pure black, ~50~ to pure gray, and ~100~ to
pure white) as well as the =severity=.

If =steps= is >0 this activates an interpolated simulation sequence. This is useful for observing multiple simulation
conditions at once.

+ =contrast(settings, color)=
  - =settings: {}=: contrast sensitivity settings
    * =settings.factor = 0: number=: set the contrast factor to simulate (as a percentage from black to gray to white)
    * =settings.severity = 50: number=: set the severity of the contrast loss
    * =settings.steps = 0: number=: activates interpolated simulation when >0
  - =color: string=: the color to influence

***** contrast Examples

***** contrast Implementation

#+BEGIN_SRC js
export function contrast(settings, color) {
  // Set defaults
  const { factor = 0, severity = 50, steps = 0 } = settings;

  if (steps) {
    return colorInterpolation(
      checkSensitivity,
      {
        contrast: factor,
        strength: severity,
        steps,
      },
      color,
    );
  }

  return checkSensitivity(
    { contrast: factor, strength: severity, steps },
    color,
  );
}
#+END_SRC

***** contrast Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/contrast_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { contrast } from "../../color.js";

describe("contrast(settings, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => contrast({}, "invalid")).toThrow();
  });

  const [red, green, blue, purple] = [
    "crimson",
    "chartreuse",
    "dodgerblue",
    "rebeccapurple",
  ];

  const contrastSamples = {
    0: {
      red: [red, ["#dc143c", "#950a26", "#540311", "#1b0002", "#000000"]],
      green: [green, ["#7fff00", "#54ae00", "#2d6300", "#0b2200", "#000000"]],
      blue: [blue, ["#1e90ff", "#1160ae", "#053463", "#010e22", "#000000"]],
    },
    25: {
      red: [red, ["#dc143c", "#ab2837", "#7c2c31", "#4f2a2a", "#222222"]],
      green: [green, ["#7fff00", "#68c22c", "#518933", "#3a532e", "#222222"]],
      blue: [blue, ["#1e90ff", "#2973c2", "#2c5789", "#293c53", "#222222"]],
    },
    50: {
      red: [red, ["#dc143c", "#c03e48", "#a45052", "#855c5b", "#636363"]],
      green: [green, ["#7fff00", "#7cd746", "#76af59", "#6e8961", "#636363"]],
      blue: [blue, ["#1e90ff", "#3e86d7", "#4f7cb0", "#5b7089", "#636363"]],
    },
    75: {
      red: [red, ["#dc143c", "#d6525a", "#ce7576", "#c19392", "#aeaeae"]],
      green: [green, ["#7fff00", "#90ec5d", "#9dd880", "#a6c399", "#aeaeae"]],
      blue: [blue, ["#1e90ff", "#529aec", "#74a2d9", "#92a9c4", "#aeaeae"]],
    },
    100: {
      red: [red, ["#dc143c", "#ec666c", "#f89c9b", "#ffcecc", "#ffffff"]],
      green: [green, ["#7fff00", "#a4ff72", "#c4ffa7", "#e2ffd5", "#ffffff"]],
      blue: [blue, ["#1e90ff", "#65aeff", "#9acaff", "#cde5ff", "#ffffff"]],
    },
  };

  it("should correctly simulate contrast sensitivity on sample data set", () => {
    Object.entries(contrastSamples).forEach(([factor, data]) => {
      Object.values(data).forEach(([input, results]) => {
        results.forEach((output, pos) => {
          expect(contrast({ factor, severity: 25 * pos }, input)).toBe(output);
        });
      });
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/contrast_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  contrast(settings, color)
  • should reject invalid colors
  • should correctly simulate contrast sensitivity on sample data set

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/contrast_test.js
test contrast(settings, color) > should reject invalid colors ... ok (37ms)
test contrast(settings, color) > should correctly simulate contrast sensitivity on sample data set ... ok (311ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (415ms)

#+end_src

**** illuminant

A perception checking color action that simulates the influence of an illuminant (or light source) on a =color=.

You can set the temperature (=K=) of your target light source as well as the =intensity= of its effect.

If =steps= is >0 this activates an interpolated simulation sequence. This is useful for observing multiple simulation
conditions at once.

+ =illuminant(settings, color)=
  - =settings: {}= illuminant settings
    * =settings.K = 1850: number=: the temperature of the light source in kelvin (candlelight at ~1850~ by default)
    * =settings.intensity = 50: number=: the intensity of the light source
    * =settings.steps = 0: number=: activates interpolated simulation when >0
  - =color: string=: the color to influence

***** illuminant Examples

***** illuminant Implementation

#+BEGIN_SRC js
export function illuminant(settings, color) {
  // Set defaults
  const { K = 1850, intensity = 50, steps = 0 } = settings;

  const { temperature = 1000 } = settings;

  if (steps) {
    return colorInterpolation(
      checkIlluminant,
      {
        temperature: K,
        strength: intensity,
        steps,
      },
      color,
    );
  }

  return checkIlluminant({ temperature: K, strength: intensity, steps }, color);
}
#+END_SRC

***** illuminant Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/illuminant_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { illuminant } from "../../color.js";

describe("illuminant(settings, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => illuminant({}, "invalid")).toThrow();
  });

  const [red, green, blue, purple] = [
    "crimson",
    "chartreuse",
    "dodgerblue",
    "rebeccapurple",
  ];

  const illuminantSamples = {
    1000: {
      red: [red, ["#dc143c", "#e52435", "#ed302c", "#f63a1e", "#ff4400"]],
      green: [green, ["#7fff00", "#bbd900", "#dcb000", "#f18200", "#ff4400"]],
      blue: [blue, ["#1e90ff", "#7c8cd0", "#af809f", "#d96b69", "#ff4400"]],
    },
    2400: {
      red: [red, ["#dc143c", "#e6463e", "#ef653e", "#f8813e", "#ff9b3d"]],
      green: [green, ["#7fff00", "#b1e820", "#d2d02e", "#ebb737", "#ff9b3d"]],
      blue: [blue, ["#1e90ff", "#719bda", "#a5a0b1", "#d3a083", "#ff9b3d"]],
    },
    4800: {
      red: [red, ["#dc143c", "#ea5d5e", "#f58b80", "#fcb6a3", "#ffe0c7"]],
      green: [green, ["#7fff00", "#a8f95f", "#c8f288", "#e5eaa9", "#ffe0c7"]],
      blue: [blue, ["#1e90ff", "#68a8f5", "#9dbce9", "#cfcfda", "#ffe0c7"]],
    },
    6400: {
      red: [red, ["#dc143c", "#ec656a", "#f89b98", "#feccc7", "#fffdf8"]],
      green: [green, ["#7fff00", "#a4ff70", "#c5ffa3", "#e3ffcf", "#fffdf8"]],
      blue: [blue, ["#1e90ff", "#65aeff", "#9ac9ff", "#cde4fd", "#fffdf8"]],
    },
    12800: {
      red: [red, ["#dc143c", "#dd5d6e", "#d9889e", "#ceaece", "#bcd2ff"]],
      green: [green, ["#7fff00", "#90f679", "#9fecad", "#aee0d8", "#bcd2ff"]],
      blue: [blue, ["#1e90ff", "#53a2ff", "#79b2ff", "#9bc3ff", "#bcd2ff"]],
    },
  };

  it("should correctly simulate the effects of various light sources on sample data", () => {
    Object.entries(illuminantSamples).forEach(([K, data]) => {
      Object.values(data).forEach(([input, results]) => {
        results.forEach((output, pos) => {
          expect(illuminant({ K, intensity: 25 * pos }, input)).toBe(output);
        });
      });
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/illuminant_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  illuminant(settings, color)
  • should reject invalid colors
  • should correctly simulate the effects of various light sources on sample data

running 2 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/illuminant_test.js
test illuminant(settings, color) > should reject invalid colors ... ok (24ms)
test illuminant(settings, color) > should correctly simulate the effects of various light sources on sample data ... ok (162ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (252ms)

#+end_src

**** palette

An action that accepts a =color= and creates a palette based on the given =configuration=.

The defined configurations are =material= and =artistic=. They have their own settings.

+ =palette(settings, color) => string[][]=
  - =settings: {}=: palette creation settings
    * =settings.configuration = "material": "material" | "artistic"=: the palette configuration configuration (exposes different settings)
    * =settings.accented = false: boolean=: include accented variants? (active with =material=)
    * =settings.tints = 3: number=: total number of tints to generate (active with =artistic=)
    * =settings.tones = 3: number=: total number of tones to generate (active with =artistic=)
    * =settings.shades = 3: number=: total number of shades to generate (active with =artistic=)
    * =settings.contrast = 100: number=: overall palette contrast (active with both configurations)
    * =settings.stated = false: boolean=: include interface states? (active with both configurations)
  - =color: string=: any valid CSS color

***** palette Examples

***** palette Implementation

#+BEGIN_SRC js
export function palette(settings, color) {
  // Set default configuration and settings and exclude interface states until requested
  const {
    configuration = "material",
    contrast = 100,
    accented = false,
    stated = false,
  } = settings;

  // Generate from material-esque or artistic configuration depending on configuration
  if (configuration === "artistic") {
    const { tints = 3, tones = 3, shades = 3 } = settings;

    return artisticConfiguration(
      { contrast, tints, tones, shades, stated },
      color,
    );
  }

  return materialConfiguration({ contrast, accented, stated }, color);
}
#+END_SRC

***** palette Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/palette_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { palette } from "../../color.js";

describe("palette(settings, color)", () => {
  it("should reject invalid colors", () => {
    expect(() => palette({}, "invalid")).toThrow();
  });

  const [red, green, blue] = ["crimson", "chartreuse", "dodgerblue"];

  describe("settings.configuration = 'material'", () => {
    it("should activate settings.accented", () => {
      expect(palette({ accented: true }, red)).toEqual([
        ["#ffffff", "#111111"],
        [
          [
            "#ffebeb",
            "#ffcecc",
            "#fbb0af",
            "#f69292",
            "#ef7175",
            "#e64d59",
            "#aa2033",
            "#7a2229",
            "#4d1e20",
            "#231616",
          ],
          ["#fbaabc", "#c0466b", "#ff00a6", "#a40000"],
        ],
        [],
      ]);
      expect(palette({ accented: true }, green)).toEqual([
        ["#ffffff", "#111111"],
        [
          [
            "#f4ffee",
            "#e2ffd5",
            "#d1ffba",
            "#beff9e",
            "#abff7e",
            "#96ff57",
            "#65c322",
            "#4c8a27",
            "#345422",
            "#1c2418",
          ],
          ["#f1ff9f", "#c8ee2e", "#ddff00", "#00c100"],
        ],
        [],
      ]);
      expect(palette({ accented: true }, blue)).toEqual([
        ["#ffffff", "#111111"],
        [
          [
            "#ebf5ff",
            "#cde5ff",
            "#aed5ff",
            "#90c4ff",
            "#70b4ff",
            "#4da2ff",
            "#2371c3",
            "#22538a",
            "#1d3755",
            "#161c25",
          ],
          ["#b7e6ff", "#309ad4", "#00eeff", "#2500ee"],
        ],
        [],
      ]);
    });
  });

  describe("settings.configuration = 'artistic'", () => {
    it("should activate settings.tints", () => {
      expect(palette({ configuration: "artistic", tints: 6 }, red)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#e64d59", "#ef7175", "#f69292", "#fbb0af", "#ffcecc", "#ffebeb"],
          ["#d4595e", "#c67f7f", "#b3a09f"],
          ["#9a2130", "#5c2023", "#231616"],
        ],
        [],
      ]);
      expect(palette({ configuration: "artistic", tints: 0 }, red)).toEqual([
        ["#ffffff", "#111111"],
        [
          [],
          ["#d4595e", "#c67f7f", "#b3a09f"],
          ["#9a2130", "#5c2023", "#231616"],
        ],
        [],
      ]);
    });
    it("should activate settings.tones", () => {
      expect(palette({ configuration: "artistic", tones: 6 }, green)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#abff7e", "#d1ffba", "#f4ffee"],
          ["#89f348", "#91e664", "#98da78", "#9ecd88", "#a3c096", "#a8b3a3"],
          ["#5daf25", "#3c6625", "#1c2418"],
        ],
        [],
      ]);
      expect(palette({ configuration: "artistic", tones: 0 }, green)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#abff7e", "#d1ffba", "#f4ffee"],
          [],
          ["#5daf25", "#3c6625", "#1c2418"],
        ],
        [],
      ]);
    });
    it("should activate settings.shades", () => {
      expect(palette({ configuration: "artistic", shades: 6 }, blue)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#70b4ff", "#aed5ff", "#ebf5ff"],
          ["#589be7", "#7ea3ce", "#9fa8b4"],
          ["#227bd7", "#2367af", "#22538a", "#1f4066", "#1b2e44", "#161c25"],
        ],
        [],
      ]);
      expect(palette({ configuration: "artistic", shades: 0 }, blue)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#70b4ff", "#aed5ff", "#ebf5ff"],
          ["#589be7", "#7ea3ce", "#9fa8b4"],
          [],
        ],
        [],
      ]);
    });
  });

  describe("settings.contrast", () => {
    it("should be active with either configuration", () => {
      expect(palette({ contrast: 90 }, red)).toEqual([
        ["#ffebeb", "#231616"],
        [
          [
            "#ffdad8",
            "#fdbfbe",
            "#faa4a3",
            "#f48889",
            "#ee6b70",
            "#e54956",
            "#af1f34",
            "#84222b",
            "#5b1f23",
            "#34191a",
          ],
          [],
        ],
        [],
      ]);
      expect(palette({ configuration: "artistic", contrast: 80 }, green)).toEqual(
        [
          ["#e8ffdd", "#26391d"],
          [
            ["#a3ff70", "#c2ffa4", "#dfffd0"],
            ["#8eeb5a", "#9ad77c", "#a2c394"],
            ["#63bf23", "#498227", "#2f4a21"],
          ],
          [],
        ],
      );
      expect(palette({ contrast: 70 }, blue)).toEqual([
        ["#c3e0ff", "#1d344f"],
        [
          [
            "#b5d8ff",
            "#9fcdff",
            "#8ac1ff",
            "#73b5ff",
            "#5ca9ff",
            "#429dff",
            "#227ad5",
            "#2365ac",
            "#225084",
            "#1f3d5f",
          ],
          [],
        ],
        [],
      ]);
    });
  });

  describe("settings.stated", () => {
    it("should be active with either configuration", () => {
      expect(palette({ configuration: "artistic", stated: true }, red)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#ef7175", "#fbb0af", "#ffebeb"],
          ["#d4595e", "#c67f7f", "#b3a09f"],
          ["#9a2130", "#5c2023", "#231616"],
        ],
        ["#e0cccc", "#4c8625", "#dc9a26", "#b62125"],
      ]);
      expect(palette({ stated: true }, green)).toEqual([
        ["#ffffff", "#111111"],
        [
          [
            "#f4ffee",
            "#e2ffd5",
            "#d1ffba",
            "#beff9e",
            "#abff7e",
            "#96ff57",
            "#65c322",
            "#4c8a27",
            "#345422",
            "#1c2418",
          ],
          [],
        ],
        ["#d4e0cf", "#2c9622", "#d5af1f", "#b54323"],
      ]);
      expect(palette({ configuration: "artistic", stated: true }, blue)).toEqual([
        ["#ffffff", "#111111"],
        [
          ["#70b4ff", "#aed5ff", "#ebf5ff"],
          ["#589be7", "#7ea3ce", "#9fa8b4"],
          ["#2367af", "#1f4066", "#161c25"],
        ],
        ["#ccd5e1", "#1b8d44", "#cba650", "#ac393f"],
      ]);
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/palette_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  palette(settings, color)
  • should reject invalid colors
    settings.configuration = 'material'
    • should activate settings.accented
    settings.configuration = 'artistic'
    • should activate settings.tints
    • should activate settings.tones
    • should activate settings.shades
    settings.contrast
    • should be active with either configuration
    settings.stated
    • should be active with either configuration

running 7 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/palette_test.js
test palette(settings, color) > should reject invalid colors ... ok (24ms)
test palette(settings, color) > settings.configuration = 'material' > should activate settings.accented ... ok (117ms)
test palette(settings, color) > settings.configuration = 'artistic' > should activate settings.tints ... ok (46ms)
test palette(settings, color) > settings.configuration = 'artistic' > should activate settings.tones ... ok (78ms)
test palette(settings, color) > settings.configuration = 'artistic' > should activate settings.shades ... ok (114ms)
test palette(settings, color) > settings.contrast > should be active with either configuration ... ok (150ms)
test palette(settings, color) > settings.stated > should be active with either configuration ... ok (167ms)

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (772ms)

#+end_src

**** accessibility

An action that accepts a =palette= and filters its variants based on how much they contrast from the background
context. The two accessibility =modes= are =standard= and =custom= with their own settings.

The modes share a =dark= toggle that will check the accessibility against a dark theme (through inverting the UI colors).

+ =accessibility(settings, palette)=
  - =settings: {}=: palette accessibility settings
    * =settings.mode = "standard": "standard" | "custom"=: set the accessibility calculation mode
    * =settings.rating = "AA": "AA" | "AAA"= : set the desired WCAG contrast rating (active with =standard=)
    * =settings.large = false: boolean=: the palette will be used with large text? (active with =standard=)
    * =settings.min = 85: number=: the minimum perceptual difference from background (active with =custom=)
    * =settings.max = undefined: number=: optionally set maximum perceptual difference from background (active with =custom=)
    * =settings.dark = false: boolean=: will the accessibility be checked for a dark theme? (active with both modes)
  - =palette: string[][]=: the palette to use

***** accessibility Examples

***** accessibility Implementation

#+BEGIN_SRC js
export function accessibility(settings, palette) {
  // Set action defaults
  const {
    mode = "standard",
    rating = "AA",
    large = false,
    dark = false,
  } = settings;

  // If mode is custom
  if (mode === "custom") {
    const { min = 85, max } = settings;

    return paletteColorimetricContrast({ min, max, dark }, palette);
  }

  return paletteWcagContrast({ rating, large, dark }, palette);
}
#+END_SRC

***** accessibility Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/accessibility_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { accessibility, palette } from "../../color.js";

describe("accessibility(settings, palette)", () => {
  it("should reject invalid colors", () => {
    expect(() => accessibility({}, palette({}, "invalid"))).toThrow();
  });

  const [red, green, blue] = ["crimson", "chartreuse", "dodgerblue"];

  describe("settings.mode = 'standard'", () => {
    it("should work with default settings", () => {
      expect(accessibility({}, palette({}, red))).toEqual([
        ["#ffffff", "#111111"],
        [["#aa2033", "#7a2229", "#4d1e20", "#231616"], []],
        [],
      ]);
      expect(
        accessibility({}, palette({ configuration: "artistic" }, green)),
      ).toEqual([["#ffffff", "#111111"], [[], [], ["#3c6625", "#1c2418"]], []]);
      expect(accessibility({}, palette({}, blue))).toEqual([
        ["#ffffff", "#111111"],
        [["#2371c3", "#22538a", "#1d3755", "#161c25"], []],
        [],
      ]);
    });

    it("should activate settings.rating", () => {
      expect(
        accessibility(
          { rating: "AAA" },
          palette(
            { configuration: "artistic", tints: 15, tones: 8, shades: 15 },
            red,
          ),
        ),
      ).toEqual([
        ["#ffffff", "#111111"],
        [
          [],
          [],
          [
            "#a72032",
            "#9a2130",
            "#8d222d",
            "#81222b",
            "#742128",
            "#682125",
            "#5c2023",
            "#501e20",
            "#451d1e",
            "#391b1b",
            "#2e1818",
            "#231616",
          ],
        ],
        [],
      ]);
      expect(accessibility({ rating: "AA" }, palette({}, green))).toEqual([
        ["#ffffff", "#111111"],
        [["#345422", "#1c2418"], []],
        [],
      ]);
      expect(
        accessibility(
          { rating: "AAA" },
          palette(
            { configuration: "artistic", tints: 16, tones: 8, shades: 8 },
            blue,
          ),
        ),
      ).toEqual([
        ["#ffffff", "#111111"],
        [[], [], ["#22538a", "#20456f", "#1d3755", "#1a2a3c", "#161c25"]],
        [],
      ]);
    });
    it("should activate settings.large", () => {
      expect(
        accessibility({ large: true }, palette({ contrast: 90 }, red)),
      ).toEqual([
        ["#ffebeb", "#231616"],
        [["#e54956", "#af1f34", "#84222b", "#5b1f23", "#34191a"], []],
        [],
      ]);
      expect(
        accessibility(
          { large: true },
          palette({ configuration: "artistic", contrast: 85 }, green),
        ),
      ).toEqual([["#eeffe6", "#212f1a"], [[], [], ["#467b26", "#2a411f"]], []]);
      expect(
        accessibility({ large: true }, palette({ contrast: 80 }, blue)),
      ).toEqual([
        ["#d7eaff", "#192839"],
        [["#2277cf", "#235fa0", "#214874", "#1c324b"], []],
        [],
      ]);
    });
  });
  describe("settings.mode = 'custom'", () => {
    it("should activate settings.min", () => {
      expect(
        accessibility({ mode: "custom", min: 50 }, palette({}, red)),
      ).toEqual([
        ["#ffffff", "#111111"],
        [["#aa2033", "#7a2229", "#4d1e20", "#231616"], []],
        [],
      ]);
      expect(
        accessibility(
          { mode: "custom", min: 64 },
          palette({ configuration: "artistic" }, green),
        ),
      ).toEqual([["#ffffff", "#111111"], [[], [], ["#1c2418"]], []]);
      expect(
        accessibility({ mode: "custom", min: 80 }, palette({}, blue)),
      ).toEqual([["#ffffff", "#111111"], [[], []], []]);
    });
    it("should activate settings.max", () => {
      expect(
        accessibility({ mode: "custom", min: 50, max: 70 }, palette({}, red)),
      ).toEqual([
        ["#ffffff", "#111111"],
        [["#aa2033", "#7a2229", "#4d1e20"], []],
        [],
      ]);
      expect(
        accessibility(
          { mode: "custom", min: 50, max: 75 },
          palette({ configuration: "artistic" }, green),
        ),
      ).toEqual([["#ffffff", "#111111"], [[], [], ["#3c6625"]], []]);
      expect(
        accessibility({ mode: "custom", min: 50, max: 80 }, palette({}, blue)),
      ).toEqual([
        ["#ffffff", "#111111"],
        [["#22538a", "#1d3755", "#161c25"], []],
        [],
      ]);
    });
  });
  it("settings.dark active for both modes", () => {
    expect(accessibility({ dark: true }, palette({}, red))).toEqual([
      ["#111111", "#ffffff"],
      [["#ffebeb", "#ffcecc", "#fbb0af", "#f69292", "#ef7175", "#e64d59"], []],
      [],
    ]);
    expect(
      accessibility(
        { mode: "custom", min: 64, dark: true },
        palette({ configuration: "artistic" }, green),
      ),
    ).toEqual([
      ["#111111", "#ffffff"],
      [["#abff7e", "#d1ffba", "#f4ffee"], ["#91e664"], []],
      [],
    ]);
    expect(accessibility({ dark: true }, palette({}, blue))).toEqual([
      ["#111111", "#ffffff"],
      [["#ebf5ff", "#cde5ff", "#aed5ff", "#90c4ff", "#70b4ff", "#4da2ff"], []],
      [],
    ]);
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/accessibility_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  accessibility(settings, palette)
  • should reject invalid colors
    settings.mode = 'standard'
    • should work with default settings
    • should activate settings.rating
    • should activate settings.large
    settings.mode = 'custom'
    • should activate settings.min
    • should activate settings.max
  • settings.dark active for both modes

running 7 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/accessibility_test.js
test accessibility(settings, palette) > should reject invalid colors ... ok (22ms)
test accessibility(settings, palette) > settings.mode = 'standard' > should work with default settings ... ok (150ms)
test accessibility(settings, palette) > settings.mode = 'standard' > should activate settings.rating ... ok (497ms)
test accessibility(settings, palette) > settings.mode = 'standard' > should activate settings.large ... ok (195ms)
test accessibility(settings, palette) > settings.mode = 'custom' > should activate settings.min ... ok (190ms)
test accessibility(settings, palette) > settings.mode = 'custom' > should activate settings.max ... ok (209ms)
test accessibility(settings, palette) > settings.dark active for both modes ... ok (194ms)

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (1s)

#+end_src

**** tokens

An emitter that accepts a =palette= and assembles it into a dictionary of color tokens.

+ =tokens(palette) => object=
  - =palette: string[][]=: the generated palette to assemble

***** tokens Examples

***** tokens (Color) Implementation

#+BEGIN_SRC js
export function tokens(palette) {
  return tokenizePalette(palette);
}
#+END_SRC

***** tokens (Color) Tests

#+BEGIN_SRC js :tangle "./v2/tests/color/tokens_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { tokens, palette } from "../../color.js";

describe("tokens(palette)", () => {
  it("should reject an invalid color", () => {
    expect(() => tokens(palette({}, "invalid"))).toThrow();
  });

  const [red, green, blue] = ["crimson", "chartreuse", "dodgerblue"];

  describe("material palette configuration", () => {
    it("should work with default settings", () => {
      expect(tokens(palette({}, red))).toEqual({
        50: "#ffebeb",
        100: "#ffcecc",
        200: "#fbb0af",
        300: "#f69292",
        400: "#ef7175",
        500: "#e64d59",
        600: "#aa2033",
        700: "#7a2229",
        800: "#4d1e20",
        900: "#231616",
        bg: "#ffffff",
        fg: "#111111",
      });
      expect(tokens(palette({}, green))).toEqual({
        50: "#f4ffee",
        100: "#e2ffd5",
        200: "#d1ffba",
        300: "#beff9e",
        400: "#abff7e",
        500: "#96ff57",
        600: "#65c322",
        700: "#4c8a27",
        800: "#345422",
        900: "#1c2418",
        bg: "#ffffff",
        fg: "#111111",
      });
      expect(tokens(palette({}, blue))).toEqual({
        50: "#ebf5ff",
        100: "#cde5ff",
        200: "#aed5ff",
        300: "#90c4ff",
        400: "#70b4ff",
        500: "#4da2ff",
        600: "#2371c3",
        700: "#22538a",
        800: "#1d3755",
        900: "#161c25",
        bg: "#ffffff",
        fg: "#111111",
      });
    });
    it("should append accents when toggled", () => {
      expect(
        tokens(palette({ accented: true }, red)),
      ).toEqual({
        50: "#ffebeb",
        100: "#ffcecc",
        200: "#fbb0af",
        300: "#f69292",
        400: "#ef7175",
        500: "#e64d59",
        600: "#aa2033",
        700: "#7a2229",
        800: "#4d1e20",
        900: "#231616",
        bg: "#ffffff",
        fg: "#111111",
        a100: "#fbaabc",
        a200: "#c0466b",
        a300: "#ff00a6",
        a400: "#a40000",
      });
      expect(
        tokens(palette({ accented: true }, green)),
      ).toEqual({
        50: "#f4ffee",
        100: "#e2ffd5",
        200: "#d1ffba",
        300: "#beff9e",
        400: "#abff7e",
        500: "#96ff57",
        600: "#65c322",
        700: "#4c8a27",
        800: "#345422",
        900: "#1c2418",
        bg: "#ffffff",
        fg: "#111111",
        a100: "#f1ff9f",
        a200: "#c8ee2e",
        a300: "#ddff00",
        a400: "#00c100",
      });
      expect(
        tokens(palette({ accented: true }, blue)),
      ).toEqual({
        50: "#ebf5ff",
        100: "#cde5ff",
        200: "#aed5ff",
        300: "#90c4ff",
        400: "#70b4ff",
        500: "#4da2ff",
        600: "#2371c3",
        700: "#22538a",
        800: "#1d3755",
        900: "#161c25",
        bg: "#ffffff",
        fg: "#111111",
        a100: "#b7e6ff",
        a200: "#309ad4",
        a300: "#00eeff",
        a400: "#2500ee",
      });
    });
  });
  describe("artistic palette configuration", () => {
    it("should work with default settings", () => {
      expect(
        tokens(palette({ configuration: "artistic" }, red)),
      ).toEqual({
        bg: "#ffffff",
        fg: "#111111",
        light: { 100: "#ef7175", 200: "#fbb0af", 300: "#ffebeb" },
        muted: { 100: "#d4595e", 200: "#c67f7f", 300: "#b3a09f" },
        dark: { 100: "#9a2130", 200: "#5c2023", 300: "#231616" },
      });
      expect(
        tokens(palette({ configuration: "artistic" }, green)),
      ).toEqual({
        bg: "#ffffff",
        fg: "#111111",
        light: { 100: "#abff7e", 200: "#d1ffba", 300: "#f4ffee" },
        muted: { 100: "#91e664", 200: "#9ecd88", 300: "#a8b3a3" },
        dark: { 100: "#5daf25", 200: "#3c6625", 300: "#1c2418" },
      });
      expect(
        tokens(palette({ configuration: "artistic" }, blue)),
      ).toEqual({
        bg: "#ffffff",
        fg: "#111111",
        light: { 100: "#70b4ff", 200: "#aed5ff", 300: "#ebf5ff" },
        muted: { 100: "#589be7", 200: "#7ea3ce", 300: "#9fa8b4" },
        dark: { 100: "#2367af", 200: "#1f4066", 300: "#161c25" },
      });
    });
    it("should add and remove variants based on tints/tones/shades settings", () => {
      expect(
        tokens(
          palette(
            { configuration: "artistic", tints: 6, tones: 0, shades: 3 },
            red,
          ),
        ),
      ).toEqual({
        bg: "#ffffff",
        fg: "#111111",
        light: {
          100: "#e64d59",
          200: "#ef7175",
          300: "#f69292",
          400: "#fbb0af",
          500: "#ffcecc",
          600: "#ffebeb",
        },
        dark: { 100: "#9a2130", 200: "#5c2023", 300: "#231616" },
      });
      expect(
        tokens(
          palette(
            { configuration: "artistic", tints: 4, tones: 2, shades: 3 },
            green,
          ),
        ),
      ).toEqual({
        bg: "#ffffff",
        fg: "#111111",
        light: {
          100: "#a1ff6c",
          200: "#beff9e",
          300: "#daffc8",
          400: "#f4ffee",
        },
        muted: { 100: "#98da78", 200: "#a8b3a3" },
        dark: { 100: "#5daf25", 200: "#3c6625", 300: "#1c2418" },
      });
      expect(
        tokens(
          palette(
            { configuration: "artistic", tints: 0, tones: 0, shades: 9 },
            blue,
          ),
        ),
      ).toEqual({
        bg: "#ffffff",
        fg: "#111111",
        dark: {
          100: "#2182e4",
          200: "#2274c9",
          300: "#2367af",
          400: "#225a96",
          500: "#214d7e",
          600: "#1f4066",
          700: "#1d344f",
          800: "#192839",
          900: "#161c25",
        },
      });
    });
  });

  it("should respond to contrast setting for either configuration", () => {
    expect(tokens(palette({ contrast: 95 }, red))).toEqual({
      50: "#ffe2e2",
      100: "#fec6c5",
      200: "#fbaaa9",
      300: "#f58d8e",
      400: "#ee6e72",
      500: "#e64b57",
      600: "#ac2033",
      700: "#7f222a",
      800: "#541f21",
      900: "#2c1818",
      bg: "#fff5f5",
      fg: "#1a1313",
    });
    expect(
      tokens(
        palette({ configuration: "artistic", contrast: 85 }, green),
      ),
    ).toEqual({
      bg: "#eeffe6",
      fg: "#212f1a",
      light: { 100: "#a5ff74", 200: "#c6ffa9", 300: "#e4ffd7" },
      muted: { 100: "#8fea5c", 200: "#9bd57f", 300: "#a4bf98" },
      dark: { 100: "#62bb23", 200: "#467b26", 300: "#2a411f" },
    });
    expect(tokens(palette({ contrast: 95 }, blue))).toEqual({
      50: "#e2f0ff",
      100: "#c5e1ff",
      200: "#a8d2ff",
      300: "#8bc2ff",
      400: "#6db2ff",
      500: "#4ba1ff",
      600: "#2373c6",
      700: "#22568f",
      800: "#1e3b5c",
      900: "#17222e",
      bg: "#f5faff",
      fg: "#13171b",
    });
  });

  it("should append interface states when defined for either configuration", () => {
    expect(tokens(palette({ stated: true }, red))).toEqual({
      50: "#ffebeb",
      100: "#ffcecc",
      200: "#fbb0af",
      300: "#f69292",
      400: "#ef7175",
      500: "#e64d59",
      600: "#aa2033",
      700: "#7a2229",
      800: "#4d1e20",
      900: "#231616",
      bg: "#ffffff",
      fg: "#111111",
      state: {
        pending: "#e0cccc",
        success: "#4c8625",
        warning: "#dc9a26",
        error: "#b62125",
      },
    });
    expect(
      tokens(
        palette({ configuration: "artistic", stated: true }, green),
      ),
    ).toEqual({
      bg: "#ffffff",
      fg: "#111111",
      light: { 100: "#abff7e", 200: "#d1ffba", 300: "#f4ffee" },
      muted: { 100: "#91e664", 200: "#9ecd88", 300: "#a8b3a3" },
      dark: { 100: "#5daf25", 200: "#3c6625", 300: "#1c2418" },
      state: {
        pending: "#d4e0cf",
        success: "#2c9622",
        warning: "#d5af1f",
        error: "#b54323",
      },
    });
    expect(tokens(palette({ stated: true }, blue))).toEqual({
      50: "#ebf5ff",
      100: "#cde5ff",
      200: "#aed5ff",
      300: "#90c4ff",
      400: "#70b4ff",
      500: "#4da2ff",
      600: "#2371c3",
      700: "#22538a",
      800: "#1d3755",
      900: "#161c25",
      bg: "#ffffff",
      fg: "#111111",
      state: {
        pending: "#ccd5e1",
        success: "#1b8d44",
        warning: "#cba650",
        error: "#ac393f",
      },
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/color/tokens_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  tokens(palette)
  • should reject an invalid color
    material palette configuration
    • should work with default settings
    • should append accents when toggled
    artistic palette configuration
    • should work with default settings
    • should add and remove variants based on tints/tones/shades settings
  • should respond to contrast setting for either type
  • should append interface states when defined for either type

running 7 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/color/tokens_test.js
test tokens(palette) > should reject an invalid color ... ok (14ms)
test tokens(palette) > material palette configuration > should work with default settings ... ok (63ms)
test tokens(palette) > material palette configuration > should append accents when toggled ... ok (59ms)
test tokens(palette) > artistic palette configuration > should work with default settings ... ok (50ms)
test tokens(palette) > artistic palette configuration > should add and remove variants based on tints/tones/shades settings ... ok (55ms)
test tokens(palette) > should respond to contrast setting for either type ... ok (55ms)
test tokens(palette) > should append interface states when defined for either type ... ok (116ms)

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (488ms)

#+end_src

*** Content
:PROPERTIES:
:header-args:js: :tangle "./v2/content.js" :mkdirp yes :comments link
:END:

**** text

A special action for generating font stack and weight tokens.

+ =text(settings, font)=
  - =settings: {}=: text settings
    * =settings.system = "sans": "sans" | "serif" | "monospace"=: system font stack to append
    * =settings.weights = ["regular", "bold"]: Array<"thin" | "extralight" | "light" | "regular" | "medium" |
      "semibold" | "bold" | "extrabold" | "black">=: weights to generate
  - =font: string=: the lead font in the stack (passing ~""~ will only generate a system font stack)

***** text Examples

***** text Implementation

#+BEGIN_SRC js
export function text(settings, font) {
  // Set defaults
  const { system = "sans", weights = ["regular", "bold"] } = settings;

  return textFamily({ system, weights }, font);
}
#+END_SRC

***** text Tests

#+BEGIN_SRC js :tangle "./v2/tests/content/text_test.js"
import { describe, expect, it, run } from "https://deno.land/x/tincan/mod.ts";
import { text } from "../../content.js";

describe("text(settings, font)", () => {
  it("should work with default settings", () => {
    expect(text({}, "")).toEqual({
      family:
        "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
      regular: 400,
      bold: 700,
    });
  });

  describe("settings.system", () => {
    it("system = 'sans'", () =>
      expect(text({ system: "sans" }, "")).toEqual({
        family:
          "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
        regular: 400,
        bold: 700,
      }));
    it("system = 'serif'", () =>
      expect(text({ system: "serif" }, "")).toEqual({
        family:
          "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
        regular: 400,
        bold: 700,
      }));
    it("system = 'monospace'", () =>
      expect(text({ system: "monospace" }, "")).toEqual({
        family:
          "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
        regular: 400,
        bold: 700,
      }));
  });

  describe("settings.weights", () => {
    it("should map weight keys to corresponding weight values", () => {
      expect(text({ weights: ["light", "regular", "bold"] }, "")).toEqual({
        family:
          "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
        light: 300,
        regular: 400,
        bold: 700,
      });
      expect(text({ weights: ["thin", "black"] }, "")).toEqual({
        family:
          "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
        thin: 100,
        black: 900,
      });
      expect(
        text(
          {
            weights: [
              "thin",
              "extralight",
              "light",
              "regular",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
            ],
          },
          ""
        )
      ).toEqual({
        family:
          "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
        thin: 100,
        extralight: 200,
        light: 300,
        regular: 400,
        medium: 500,
        semibold: 600,
        bold: 700,
        extrabold: 800,
        black: 900,
      });
    });
  });

  it("should allow setting a custom lead font", () => {
    expect(text({}, "Mozilla Slab")).toEqual({
      family:
        "Mozilla Slab, -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
      regular: 400,
      bold: 700,
    });
    expect(text({}, "Work Sans")).toEqual({
      family:
        "Work Sans, -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
      regular: 400,
      bold: 700,
    });
  });
});

run();
#+END_SRC

#+BEGIN_SRC shell
NO_COLOR=1 deno test v2/tests/content/text_test.js
#+END_SRC

#+RESULTS:
#+begin_src shell

  text(settings, font)
  • should work with default settings
    settings.system
    • system = 'sans'
    • system = 'serif'
    • system = 'monospace'
    settings.weights
    • should map weight keys to corresponding weight values
  • should allow setting a custom lead font

running 6 tests from file:///home/cr-jr/Code/quarksuite:core/v2/tests/content/text_test.js
test text(settings, font) > should work with default settings ... ok (10ms)
test text(settings, font) > settings.system > system = 'sans' ... ok (5ms)
test text(settings, font) > settings.system > system = 'serif' ... ok (6ms)
test text(settings, font) > settings.system > system = 'monospace' ... ok (6ms)
test text(settings, font) > settings.weights > should map weight keys to corresponding weight values ... ok (5ms)
test text(settings, font) > should allow setting a custom lead font ... ok (6ms)

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (118ms)

#+end_src

**** ms

***** ms Examples

***** ms Implementation

#+BEGIN_SRC js
export function ms(settings, base) {
  // Set defaults
  const { ratio = 1.5, values = 6 } = settings;

  return create({ ratio, values }, base);
}
#+END_SRC

***** ms Tests

**** modify

***** modify Examples

***** modify Implementation

#+BEGIN_SRC js
export function modify(calc, ms) {
  return update(calc, ms);
}
#+END_SRC

***** modify Tests

**** tokens

***** tokens Examples

***** tokens (Content) Implementation

#+BEGIN_SRC js
export function tokens(settings, ms) {
  // Set defaults
  const { type = "bidirectional", unit = "rem", inversion = "em" } = settings;

  return assemble({ ...settings, type, unit, inversion }, ms);
}
#+END_SRC

***** tokens (Content) Tests

** Internals
*** Functional
:PROPERTIES:
:header-args:js: :tangle "./v2/fn.js" :mkdirp yes :comments link
:END:

**** Composition Internals

#+BEGIN_SRC js :tangle "./v2/fn.js"
function compose(...fns) {
  return (x) => fns.reduce((g, f) => f(g), x);
}
#+END_SRC

*** Color
:PROPERTIES:
:header-args:js: :tangle "./v2/color.js" :mkdirp yes :comments link
:END:

QuarkSuite accepts and processes most valid CSS color formats defined in [[https://www.w3.org/TR/css-color-4/][CSS Color Module Level 4]]. There are no color objects
to pass around, you just use the colors themselves and get colors back.

**** Conversion

Under the hood, a sequence of tokenization, validation, extraction, parsing, conversion, and serialization (mostly)
guarantees correct color input /and/ output. So wield those colors with confidence.

***** Tokenization

Color format tokenization follows the spec as closely as possible.

Then we have basic =NUMBER_TOKENS=, a =PERCENTAGE_TOKEN=, tokens for the legacy and modern =DELIMITERS=, a
=COMPONENT_TOKEN= combining the first two, and a =HUE_TOKEN=. That's all that's needed to account for every format
QuarkSuite supports.

#+BEGIN_SRC js
const NUMBER_TOKEN = /(?:-?(?!0\d)\d+(?:\.\d+)?)/;
const PERCENTAGE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "%)"].join(""),
);

const LEGACY_DELIMITER = /(?:[\s,]+)/;
const LEGACY_ALPHA_DELIMITER = new RegExp(
  LEGACY_DELIMITER.source.replace(",", ",/"),
);
const MODERN_DELIMITER = new RegExp(LEGACY_DELIMITER.source.replace(",", ""));
const MODERN_ALPHA_DELIMITER = new RegExp(
  LEGACY_ALPHA_DELIMITER.source.replace(",", ""),
);

const COMPONENT_TOKEN = new RegExp(
  ["(?:", PERCENTAGE_TOKEN.source, "|", NUMBER_TOKEN.source, ")"].join(""),
);
const HUE_TOKEN = new RegExp(
  ["(?:", NUMBER_TOKEN.source, "(?:deg|g?rad|turn)?)"].join(""),
);
#+END_SRC

***** Validation

Defining tokens will make validation of the functional color formats incredibly simple as the tokens can be combined
with the correct format prefix to create a full color string.

****** Named Color Validation

QuarkSuite supports CSS named colors through to CSS Color Module 4 using an object query.

#+BEGIN_SRC js
const NAMED_COLOR_KEYWORDS = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};

function namedValidator(color) {
  return Boolean(NAMED_COLOR_KEYWORDS[color]);
}
#+END_SRC

****** RGB Hex Validation

This can be done with a regular expression.

#+BEGIN_SRC js
function hexValidator(color) {
  return /^#([\da-f]{3,4}){1,2}$/i.test(color);
}
#+END_SRC

****** Validating Functional Formats

The functional formats require a bit of extra processing. Good thing we created those tokens earlier. Functional formats
always have an optional alpha component, so we tack that onto the end. If =legacy= is =true=, then we use the legacy
delimiters. Otherwise, we know it's a modern format.

Each format has varying components, so we map over the tokens we plug in and link them with delimiters.

#+BEGIN_SRC js
function matchFunctionalFormat({ prefix, legacy = true }, tokens) {
  const VALUES = tokens.map((token) => token.source);

  const DELIMITER = legacy ? LEGACY_DELIMITER.source : MODERN_DELIMITER.source;
  const ALPHA_DELIMITER = legacy
    ? LEGACY_ALPHA_DELIMITER.source
    : MODERN_ALPHA_DELIMITER.source;

  return new RegExp(
    `(?:^${prefix}\\(`.concat(
      VALUES.join(DELIMITER),
      `(?:${[ALPHA_DELIMITER, COMPONENT_TOKEN.source].join("")})?\\))`,
    ),
  );
}
#+END_SRC

******* RGB Validation

=matchFunctionalFormats= makes validating the remaining CSS formats a matter of slotting in tokens with the right
prefix. As you'll see, some tokens repeat and others have to be slotted individually.

#+BEGIN_SRC js
function rgbValidator(color) {
  return matchFunctionalFormat(
    { prefix: "rgba?" },
    Array(3).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

******* HSL Validation

#+BEGIN_SRC js
function hslValidator(color) {
  return matchFunctionalFormat({ prefix: "hsla?" }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENTAGE_TOKEN),
  ]).test(color);
}
#+END_SRC

******* CMYK Validation

=device-cmyk= is the first modern format, so the legacy flag will have to be disabled. It's also technically been moved
to CSS Color Module 5, but I implemented it before I found that out.

#+BEGIN_SRC js
function cmykValidator(color) {
  return matchFunctionalFormat(
    { prefix: "device-cmyk", legacy: false },
    Array(4).fill(COMPONENT_TOKEN),
  ).test(color);
}
#+END_SRC

******* HWB Validation

#+BEGIN_SRC js
function hwbValidator(color) {
  return matchFunctionalFormat({ prefix: "hwb", legacy: false }, [
    HUE_TOKEN,
    ...Array(2).fill(PERCENTAGE_TOKEN),
  ]).test(color);
}
#+END_SRC

******* CIELAB/CIELCH Validation

These two formats are scalar and polar variants of the same color space, so I'll combine their validators.

#+BEGIN_SRC js
function cielabValidator(color) {
  return matchFunctionalFormat({ prefix: "lab", legacy: false }, [
    PERCENTAGE_TOKEN,
    ...Array(2).fill(NUMBER_TOKEN),
  ]).test(color);
}

function cielchValidator(color) {
  return matchFunctionalFormat({ prefix: "lch", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

******* OKLab/OKLCH Validation

Same with OKLab/OKLCH, which recently became standard so I reimplemented them according to the spec.

#+BEGIN_SRC js
function oklabValidator(color) {
  return matchFunctionalFormat({ prefix: "oklab", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    NUMBER_TOKEN,
  ]).test(color);
}

function oklchValidator(color) {
  return matchFunctionalFormat({ prefix: "oklch", legacy: false }, [
    PERCENTAGE_TOKEN,
    NUMBER_TOKEN,
    HUE_TOKEN,
  ]).test(color);
}
#+END_SRC

****** Preparing Validation

From here, we'll implement a =validator()= that accepts input and checks it against all of the available formats. A valid
color will match /one of/ the available formats and get slotted in a =[format, color]= tuple.

#+BEGIN_SRC js
function validator(input) {
  const SUPPORTED_FORMATS = {
    named: namedValidator,
    hex: hexValidator,
    rgb: rgbValidator,
    hsl: hslValidator,
    cmyk: cmykValidator,
    hwb: hwbValidator,
    cielab: cielabValidator,
    cielch: cielchValidator,
    oklab: oklabValidator,
    oklch: oklchValidator,
  };

  return (
    Object.entries(SUPPORTED_FORMATS)
      .map(([format, test]) => [format, test(input) && input])
      .find(([, color]) => color) || InvalidColorError(input)
  );
}
#+END_SRC

****** Invalid Color Handling

Otherwise, the input does not match any of the available formats and throws a useful error.

#+BEGIN_SRC js
class InvalidColor extends Error {
  constructor(input, ...params) {
    super(...params);

    // Stack trace (for v8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, InvalidColor);
    }

    this.name = "Invalid Color Format";
    this.message = `
${"-".repeat(100)}
"${input}" is not a valid color.
${"-".repeat(100)}

Supported color formats:

- Named colors
- RGB Hex
- Functional RGB
- Functional HSL
- Functional CMYK
- Functional HWB
- Functional CIELAB/CIELCH
- Functional OKLab/OKLCH

Read more about these formats at: https://www.w3.org/TR/css-color-4/
${"=".repeat(100)}
`;
  }
}

function InvalidColorError(input) {
  return new InvalidColor(input);
}
#+END_SRC

***** Extraction

Once we're sure we have a valid color, we need to extract its components. Since CSS color formats really have just two
forms (hexadecimal and functional), that's how many extractors we need.

****** RGB Hex Extractor

For RGB Hex extraction, we need to consider that RGB colors can also come in the form =#RGB(A)=. So we'll use =expandHex()= to expand
those to a full =#RRGGBB(AA)=. And then we have =hexExtractor()= to do the extraction proper.

#+BEGIN_SRC js
function hexExtractor(color) {
  return expandHex(color).match(/[\da-f]{2}/gi);
}

function expandHex(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

****** Functional Format Extractor

Extracting from functional formats requires that the values be picked /with their units attached/. We'll need this
information for parsing them prior to format conversion.

This is done with =componentExtractor()=.

#+BEGIN_SRC js
function componentExtractor(color) {
  return color.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
}
#+END_SRC

****** Extraction Preparation

Now with all the parts in place, we'll create a general =extractor()= that consumes a valid color tuple. If the =format=
is =hex=, we'll call =hexExtractor()=, otherwise it's a functional format and must be handled by =componentExtractor()=.

We also need to do additional work if the =format= is =named=, so we pass its value in =NAMED_COLOR_KEYWORDS= through
=hexExtractor()=.

Note that we're also passing the extraction along in the =[format, components]= tuple form for additional parsing.

#+BEGIN_SRC js
function extractor(validated) {
  const [format, color] = validated;

  if (format === "named") {
    return ["hex", hexExtractor(NAMED_COLOR_KEYWORDS[color])];
  }

  if (format === "hex") {
    return ["hex", hexExtractor(color)];
  }

  return [format, componentExtractor(color)];
}
#+END_SRC

***** Parsing

Before we get into actual color conversion, we're going to parse the extracted values according to their format. In
other words, we're going break them down into a calculable state that we can pass along to each conversion function.

We're going to use the extraction tuple and create a parser for each format so there are no false positives.

But first...

****** Math

We're going to prepare some helpers for the necessary value conversions we'll need to perform.

******* Clamping Values

Before anything else, we'll need a helper to =clamp()= values between a =min= and =max=. Some values in functional
formats are capped, and others are not. We'll see which when we implement the serializer.

#+BEGIN_SRC js
function clamp(x, a, b) {
  if (x < a) {
    return a;
  }

  if (x > b) {
    return b;
  }

  return x;
}
#+END_SRC

******* Hex Fragment <-> Channel

Now, we're going to need to convert hex fragments to and from their RGB channel equivalents.

=16= is the /radix/ (or base) of hexadecimal, so we use =parseInt()= to convert the hex value to a decimal and
=toString()= to convert a decimal to hexadecimal.

#+BEGIN_SRC js
function hexFragmentToChannel(hex) {
  return parseInt(hex, 16);
}

function hexFragmentFromChannel(channel) {
  return clamp(channel, 0, 255).toString(16).padStart(2, "0");
}
#+END_SRC

******* Number <-> Percentage

Some functional formats will need to have their numbers converted to percentages or the reverse.

#+BEGIN_SRC js
function numberToPercentage(n) {
  return n * 100;
}

function numberFromPercentage(percentage) {
  return percentage / 100;
}
#+END_SRC

******* Number <-> Channel

RGB channels need to be converted to a =0-1= range to be useful in calculation. And then they need to be converted back
to channels later.

#+BEGIN_SRC js
function numberToChannel(n) {
  return Math.round(n * 255);
}

function numberFromChannel(channel) {
  return channel / 255;
}
#+END_SRC

******* Hue Component

Some of the color conversions require the [[https://www.rapidtables.com/convert/number/how-degrees-to-radians.html][hue as radians]]. And then we need to be able to [[https://www.rapidtables.com/convert/number/how-radians-to-degrees.html][convert back]].

The hue component also supports gradians and rotations, so we'll have to account for those as well to stay true to the
spec.

#+BEGIN_SRC js
function radiansToDegrees(radians) {
  return (radians * 180) / Math.PI;
}

function radiansFromDegrees(degrees) {
  return (degrees * Math.PI) / 180;
}

function gradiansToDegrees(gradians) {
  return gradians * (180 / 200);
}

function turnsToDegrees(turns) {
  return turns * 360;
}
#+END_SRC

******* Hue Correction

A stipulation of the hue component in the spec is that it must support hue values greater than a single revolution.

However, if it's to be useful in calculation, we must then /correct/ the value to a range =-360-360= or one full
rotation clockwise and counterclockwise. Our implmentation of =hueCorrection()= takes care of that.

#+BEGIN_SRC js
function hueCorrection(hue) {
  let h = hue;

  if (Math.sign(hue) === -1) {
    h = Math.abs(hue + 360);
  }

  if (hue > 360) {
    h = hue % 360;
  }

  return clamp(h, -360, 360);
}
#+END_SRC

****** Parsing RGB Hex

RGB Hex must be parsed as RGB channels to be mathematically useful. That's what =parseHex()= does.

If =A= is missing, then we attach it to ensure uniformity. Finally, we convert the hex fragments to RGB. The alpha
component needs additional handling.

#+BEGIN_SRC js
function parseHex([format, components]) {
  const [r, g, b, A] = components;

  const [R, G, B] = [r, g, b].map((fragment) => hexFragmentToChannel(fragment));

  if (A) {
    return [format, [R, G, B, numberFromChannel(hexFragmentToChannel(A))]];
  }

  return [format, [R, G, B, 1]];
}
#+END_SRC

****** Parsing Functional RGB

As stated above, RGB must be converted to a =0-1= range to be mathematically useful. This is a straightforward
conversion because of our =numberFromChannel()= helper. Meanwhile, percentage values are valid for =a=.

We check to see if =a= is a percentage value and convert it or leave it alone.

This is an operation we'll repeat multiple times during parsing, so it's captured in a =parsePercentage()= helper.

#+BEGIN_SRC js
function parsePercentage(component) {
  if (component.endsWith("%")) {
    return numberFromPercentage(parseFloat(component));
  }
  return parseFloat(component);
}

function parseRgb([format, components]) {
  const [r, g, b, A] = components;

  const [R, G, B] = [r, g, b].map((channel) => {
    if (channel.endsWith("%")) return parsePercentage(channel);
    return numberFromChannel(parseFloat(channel));
  });

  if (A) {
    return [format, [R, G, B, parsePercentage(A)]];
  }

  return [format, [R, G, B, 1]];
}
#+END_SRC

****** Parsing Functional HSL

The =h= component will need special processing depending on its units. And our conversion goal is /degrees/. Other than
that, =s= and =l= need conversion to a =0-1= range, and =A= is handled as usual.

Several formats beyond this point have a hue value, so we'll create a =parseHue()= helper to capture that logic.

#+BEGIN_SRC js
function parseHue(hue) {
  let HUE = parseFloat(hue);

  if (hue.endsWith("rad")) {
    HUE = radiansToDegrees(HUE);
  }

  if (hue.endsWith("grad")) {
    HUE = gradiansToDegrees(HUE);
  }

  if (hue.endsWith("turn")) {
    HUE = turnsToDegrees(HUE);
  }

  return hueCorrection(HUE);
}

function parseHsl([format, components]) {
  const [h, s, l, A] = components;

  let H = parseHue(h);

  const [S, L] = [s, l].map((percentage) =>
    numberFromPercentage(parseFloat(percentage))
  );

  if (A) {
    return [format, [H, S, L, parsePercentage(A)]];
  }

  return [format, [H, S, L, 1]];
}
#+END_SRC

****** Parsing Functional CMYK

Functional CMYK is dead simple to parse. We check to see if the components are percentages and convert them. Otherwise,
we coerce them to numbers with no additional processing.

#+BEGIN_SRC js
function parseCMYK([format, components]) {
  const [C, M, Y, K, A] = components.map((V) => {
    if (V.endsWith("%")) return parsePercentage(V);
    return parseFloat(V);
  });

  if (A) {
    return [format, [C, M, Y, K, A]];
  }

  return [format, [C, M, Y, K, 1]];
}
#+END_SRC

****** Parsing Functional HWB

Parsing functional HWB simply reuses =parseHSL()= because in this area they are /identical/.

****** Parsing Functional CIELAB/CIELCH

Of these two, the only one that requires any special attention is CIELCH because of that hue component. CIELAB just
passes its values through number coercion.

#+BEGIN_SRC js
function parseCielab([format, components]) {
  const [$L, $a, $b, A] = components;

  const [L, a, b] = [$L, $a, $b].map((component) => parseFloat(component));

  if (A) {
    return [format, [L, a, b, parsePercentage(A)]];
  }

  return [format, [L, a, b, 1]];
}

function parseCielch([format, components]) {
  const [$L, c, h, A] = components;

  const [L, C] = [$L, c].map((component) => parseFloat(component));
  const H = parseHue(h);

  if (A) {
    return [format, [L, C, H, parsePercentage(A)]];
  }

  return [format, [L, C, H, 1]];
}
#+END_SRC

****** Parsing OKLab/OKLCH

Parsing OKLab/OKLCH is similar to the above section, but it's important to note that OKLCH calculations expect the hue
in /radians/. =L= is also converted to a =0-1= range.

#+BEGIN_SRC js
function parseOklab([format, components]) {
  const [$L, $a, $b, A] = components;

  const L = parsePercentage($L);
  const [a, b] = [$a, $b].map((component) => parseFloat(component));

  if (A) {
    return [format, [L, a, b, parsePercentage(A)]];
  }

  return [format, [L, a, b, 1]];
}

function parseOklch([format, components]) {
  const [$L, c, h, A] = components;

  const L = parsePercentage($L);
  const C = parseFloat(c);
  const H = radiansFromDegrees(parseHue(h));

  if (A) {
    return [format, [L, C, H, parsePercentage(A)]];
  }

  return [format, [L, C, H, 1]];
}
#+END_SRC

****** Parsing Preparation

Similar to the validator and extractor, the =parser()= will read a color tuple and execute the correct parsing function
for a matched format. And then it throws back a transformed tuple of =[format, values]=.

#+BEGIN_SRC js
function parser(extracted) {
  const [format] = extracted;

  const FORMAT_PARSERS = {
    hex: parseHex,
    rgb: parseRgb,
    hsl: parseHsl,
    cmyk: parseCMYK,
    hwb: parseHsl, // identical to HSL
    cielab: parseCielab,
    cielch: parseCielch,
    oklab: parseOklab,
    oklch: parseOklch,
  };

  return FORMAT_PARSERS[format](extracted);
}
#+END_SRC

***** Calculation

Having completed our necessary preparations, we can finally move on to color conversion. QuarkSuite handles conversion
with a very precise method.

The idea: as a tool created for the web, and therefore largely for screens, every color used will eventually have to
pass through the sRGB gamut. This means that sRGB is our given /conversion anchor/.

With this in mind we can say color conversion is best structured as a pipeline where =INPUT -> RGB -> OUTPUT= routes
every input format to its targeted output format.

Some formats need to be linked into the pipeline. Specifically =Scalar <-> Polar= formats.

****** Preamble

To keep things simple, I'll keep using the color tuple data structure up until the point it's actually time to hand a
color back to the user. This is a *major* change from v1, where I attempted to reassemble the color within each conversion
function which sometimes led to wonky behavior from the pipeline.

It makes far more sense to keep passing along the raw conversions to the color tuple for serialization and make
reassembly an explicit, predictable step.

By this point, we're assuming the color has been validated, extracted, and correctly parsed. So we'll be passing along
the result of parsing as the color tuple =[format, values]=.

In the color conversion functions themselves, we'll be passing the results along as the =[format, results]= tuple.

****** RGB <-> RGB

Yes, we do have to account for RGB converting to and from itself, because the parsed RGB can't be serialized.

#+BEGIN_SRC js
function rgbInputIdentity([, values]) {
  const [r, g, b, A] = values;

  const [R, G, B] = [r, g, b].map((channel) => numberToChannel(channel));

  return ["rgb", [R, G, B, A]];
}

function rgbOutputIdentity([, rgbValues]) {
  return ["rgb", rgbValues];
}
#+END_SRC

****** INPUT -> RGB

The first process in the conversion pipeline is to take the =INPUT= format and convert it to =RGB=.

******* Hex -> RGB

If you remember from =parseHex()=, a parsed hexadecimal color is already a valid RGB result. So we mark it as such and pass it
through.

#+BEGIN_SRC js
function hexToRgb([, values]) {
  return ["rgb", values];
}
#+END_SRC

******* HSL -> RGB

To convert HSL to RGB, we use [[https://www.rapidtables.com/convert/color/hsl-to-rgb.html][this conversion formula from RapidTables]].

#+BEGIN_SRC js
function calculateRgb(C, X, H) {
  return new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);
}

function hslToRgb([, values]) {
  const [H, S, L, A] = values;

  // Calculate chroma
  const C = (1 - Math.abs(2 * L - 1)) * S;
  const X = C * (1 - Math.abs(((H / 60) % 2) - 1));
  const m = L - C / 2;

  const [R, G, B] = Array.from(calculateRgb(C, X, H))
    .find(([, condition]) => condition)
    .flatMap((result) => result)
    .map((n) => numberToChannel(n + m));

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* CMYK -> RGB

#+BEGIN_QUOTE
IMPORTANT: CSS Color Module 5 will use a device-independent conversion of CMYK through the CIELAB space. This means the
below approach is outdated. For practicality and compatibility's sake, I still use the old conversion method through
sRGB. Which works today.
#+END_QUOTE

#+BEGIN_QUOTE
UPDATE: The below approach is not outdated in CSS Color Module 5, but it is considered a /naive/ conversion. It works
well enough for the purposes of this library either way.
#+END_QUOTE

Conversion of CMYK to RGB is [[https://www.rapidtables.com/convert/color/cmyk-to-rgb.html][covered by another RapidTables formula]].

#+BEGIN_SRC js
function cmykToRgb([, values]) {
  const [C, M, Y, K, A] = values;

  const [R, G, B] = [C, M, Y].map((V) => numberToChannel((1 - V) * (1 - K)));

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* HWB -> RGB

The formula for conversion of HWB to RGB is [[https://www.w3.org/TR/css-color-4/#hwb-to-rgb][adapted from the spec itself]].

#+BEGIN_SRC js
function hwbToRgb([, values]) {
  const [H, W, BLK, A] = values;

  // Achromacity
  if (W + BLK >= 1) {
    let GRAY = numberToChannel(W / (W + BLK));

    return ["rgb", [Array(3).fill(GRAY), A]];
  }

  // Conversion
  const [, [r, g, b]] = hslToRgb(["hsl", [H, 1, 0.5, 1]]);
  const [R, G, B] = [r, g, b].map((channel) =>
    numberToChannel(numberFromChannel(channel) * (1 - W - BLK) + W)
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* CIELAB -> RGB

The steps for the CIELAB to RGB conversion are as follows:

1. Convert CIELAB to CIEXYZ
2. Convert CIEXYZ to LRGB
3. Convert LRGB to RGB

The actual equations are helpfully [[http://www.brucelindbloom.com/index.html?Math.html][provided by Bruce Lindbloom]].

#+BEGIN_SRC js
function cielabToCiexyz([L, a, b]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const WHITE = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const FY = (L + 16) / 116;
  const FX = a / 500 + FY;
  const FZ = FY - b / 200;

  // Calculate xyz
  const [X, Y, Z] = [
    FX ** 3 > ε ? FX ** 3 : (116 * FX - 16) / κ,
    L > κ * ε ? FY ** 3 : L / κ,
    FZ ** 3 > ε ? FZ ** 3 : (116 * FZ - 16) / κ,
  ].map((V, i) => V * WHITE[i]);

  return [X, Y, Z];
}

function ciexyzToLrgb([X, Y, Z]) {
  const D65_CHROMATIC_ADAPTATION = [
    [0.9555766, -0.0230393, 0.0631636],
    [-0.0282895, 1.0099416, 0.0210077],
    [0.0122982, -0.020483, 1.3299098],
  ];

  const LINEAR_RGB_TRANSFORMATION_MATRIX = [
    [3.2404542, -1.5371385, -0.4985314],
    [-0.969266, 1.8760108, 0.041556],
    [0.0556434, -0.2040259, 1.0572252],
  ];

  const [CX, CY, CZ] = D65_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => X * V1 + Y * V2 + Z * V3,
  );

  const [LR, LG, LB] = LINEAR_RGB_TRANSFORMATION_MATRIX.map(
    ([V1, V2, V3]) => CX * V1 + CY * V2 + CZ * V3,
  );

  return [LR, LG, LB];
}

function lrgbToRgb([LR, LG, LB]) {
  return [LR, LG, LB].map((V) =>
    V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055
  );
}

function cielabToRgb([, values]) {
  const [L, a, b, A] = values;

  const [R, G, B] = lrgbToRgb(ciexyzToLrgb(cielabToCiexyz([L, a, b]))).map(
    (n) => numberToChannel(n),
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

******* OKLAB -> RGB

The OKLab to RGB conversion steps are adapted from the creator, Björn Ottosson's, [[https://bottosson.github.io/posts/oklab/][original post about it]].

The process breaks down to:

1. Convert OKLab to LRGB
2. Convert LRGB to RGB

Simple and direct.

#+BEGIN_SRC js
function oklabToLrgb([L, a, b]) {
  const LINEAR_LMS_CONE_ACTIVATIONS = [
    [0.3963377774, 0.2158037573],
    [0.1055613458, 0.0638541728],
    [0.0894841775, 1.291485548],
  ];

  const OKLAB_TO_LRGB_MATRIX = [
    [4.076416621, 3.3077115913, 0.2309699292],
    [-1.2684380046, 2.6097574011, 0.3413193965],
    [-0.0041960863, 0.7034186147, 1.707614701],
  ];

  const [LONG, M, S] = LINEAR_LMS_CONE_ACTIVATIONS.map(([V1, V2], pos) => {
    if (pos === 0) return L + a * V1 + b * V2;
    if (pos === 1) return L - a * V1 - b * V2;
    return L - a * V1 - b * V2;
  }).map((V) => V ** 3);

  const [LR, LG, LB] = OKLAB_TO_LRGB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return LONG * V1 - M * V2 + S * V3;
    if (pos === 1) return LONG * V1 + M * V2 - S * V3;
    return LONG * V1 - M * V2 + S * V3;
  });

  return [LR, LG, LB];
}

function oklabToRgb([, values]) {
  const [L, a, b, A] = values;

  const [R, G, B] = lrgbToRgb(oklabToLrgb([L, a, b])).map((n) =>
    numberToChannel(n)
  );

  return ["rgb", [R, G, B, A]];
}
#+END_SRC

****** RGB -> OUTPUT

The next stage is to get the output format /from/ the RGB.

******* RGB -> Hex

Getting RGB to hexadecimal color output is a similarly stratightforward implementation.

Rounding the results is necessary because hexadecimal format expects integers. Having reached our target output, we can
now forward the result for serializing.

#+BEGIN_SRC js
function hexFromRgb([, rgbValues]) {
  const [r, g, b, a] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => hexFragmentFromChannel(channel));
  const A = hexFragmentFromChannel(numberToChannel(a));

  return ["hex", [R, G, B, A]];
}
#+END_SRC

******* RGB -> HSL

Getting RGB to an HSL output color is [[https://www.rapidtables.com/convert/color/rgb-to-hsl.html][handled by another RapidTables formula]].

#+BEGIN_SRC js
function calculateHue(R, G, B, cmax, delta) {
  return new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);
}

function calculateSaturation(delta, L) {
  return delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));
}

function calculateLightness(cmin, cmax) {
  return (cmax + cmin) / 2;
}

function hslFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const cmin = Math.min(R, G, B);
  const cmax = Math.max(R, G, B);
  const delta = cmax - cmin;

  const L = calculateLightness(cmin, cmax);
  const [H] = Array.from(calculateHue(R, G, B, cmax, delta)).find(
    ([, condition]) => condition,
  );
  const S = calculateSaturation(delta, L);

  return ["hsl", [H, S, L, A]];
}
#+END_SRC

******* RGB -> CMYK

Getting RGB to CMYK output [[https://www.rapidtables.com/convert/color/rgb-to-cmyk.html][requires yet another RapidTables formula]].

#+BEGIN_SRC js
function cmykFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const K = 1 - Math.max(R, G, B);
  const [C, M, Y] = [R, G, B].map((channel) => (1 - channel - K) / (1 - K));

  return ["cmyk", [C, M, Y, K, A]];
}
#+END_SRC

******* RGB -> HWB

The formula for converting RGB to HWB output is also [[https://www.w3.org/TR/css-color-4/#rgb-to-hwb][pulled from the spec]].

#+BEGIN_SRC js
function hwbFromRgb([, rgbValues]) {
  const [r, g, b, A] = rgbValues;

  const [R, G, B] = [r, g, b].map((channel) => numberFromChannel(channel));

  const cmax = Math.max(R, G, B);
  const cmin = Math.min(R, G, B);
  const delta = cmax - cmin;

  const [H] = Array.from(calculateHue(R, G, B, cmax, delta)).find(
    ([, condition]) => condition,
  );

  const [W, BLK] = [cmin, 1 - cmax];

  return ["hwb", [H, W, BLK, A]];
}
#+END_SRC

******* RGB -> CIELAB

For getting CIELAB output from RGB, we'll be leaning on Bruce Lindbloom's equations again.

The process is as follows:

1. RGB to LRGB
2. LRGB to CIEXYZ
3. CIEXYZ to CIELAB

#+BEGIN_SRC js
function rgbToLrgb([R, G, B]) {
  return [R, G, B].map((V) =>
    V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4
  );
}

function lrgbToCiexyz([LR, LG, LB]) {
  const D65_REFERENCE_WHITE = [
    [0.4124564, 0.3575761, 0.1804375],
    [0.2126729, 0.7151522, 0.072175],
    [0.0193339, 0.119192, 0.9503041],
  ];

  const D50_CHROMATIC_ADAPTATION = [
    [1.0478112, 0.0228866, -0.050127],
    [0.0295424, 0.9904844, -0.0170491],
    [-0.0092345, 0.0150436, 0.7521316],
  ];

  const [x, y, z] = D65_REFERENCE_WHITE.map(
    ([V1, V2, V3]) => LR * V1 + LG * V2 + LB * V3,
  );

  const [X, Y, Z] = D50_CHROMATIC_ADAPTATION.map(
    ([V1, V2, V3]) => x * V1 + y * V2 + z * V3,
  );

  return [X, Y, Z];
}

function ciexyzToCielab([X, Y, Z]) {
  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const D50_WHITE = [0.96422, 1.0, 0.82521];

  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z]
    .map((V, i) => V / D50_WHITE[i])
    .map((V) => (V > ε ? Math.cbrt(V) : (κ * V + 16) / 116));

  const [L, a, b] = [116 * FY - 16, 500 * (FX - FY), 200 * (FY - FZ)];

  return [L, a, b];
}

function cielabFromRgb([, rgbValues]) {
  const [r, g, $b, A] = rgbValues;

  const [R, G, B] = [r, g, $b].map((channel) => numberFromChannel(channel));
  const [L, a, b] = ciexyzToCielab(lrgbToCiexyz(rgbToLrgb([R, G, B])));

  return ["cielab", [L, a, b, A]];
}
#+END_SRC

******* RGB -> OKLAB

To get Oklab output from RGB, we're going to use the inversion also documented by its creator.

That process goes:

1. RGB to LRGB
2. LRGB to OKLAB

#+BEGIN_SRC js
function lrgbToOklab([LR, LG, LB]) {
  const NONLINEAR_LMS_CONE_ACTIVATIONS = [
    [0.4122214708, 0.5363325363, 0.0514459929],
    [0.2119034982, 0.6806995451, 0.1073969566],
    [0.0883024619, 0.2817188376, 0.6299787005],
  ];

  const RGB_OKLAB_MATRIX = [
    [0.2104542553, 0.793617785, 0.0040720468],
    [1.9779984951, 2.428592205, 0.4505937099],
    [0.0259040371, 0.7827717662, 0.808675766],
  ];

  const [L, M, S] = NONLINEAR_LMS_CONE_ACTIVATIONS.map(
    ([L, M, S]) => L * LR + M * LG + S * LB,
  ).map((V) => Math.cbrt(V));

  return RGB_OKLAB_MATRIX.map(([V1, V2, V3], pos) => {
    if (pos === 0) return V1 * L + V2 * M - V3 * S;
    if (pos === 1) return V1 * L - V2 * M + V3 * S;
    return V1 * L + V2 * M - V3 * S;
  });
}

function oklabFromRgb([, rgbValues]) {
  const [r, g, $b, A] = rgbValues;

  const [R, G, B] = [r, g, $b].map((channel) => numberFromChannel(channel));
  const [L, a, b] = lrgbToOklab(rgbToLrgb([R, G, B]));

  return ["oklab", [L, a, b, A]];
}
#+END_SRC

****** SCALAR <-> POLAR

The last thing we need to do before wiring everything up is create a bridge to and from CIELAB & OKLab to their polar
coordinate alter-egos (CIELCH & OKLCH).

Since we already have a completed chain of =INPUT -> RGB -> OUTPUT= for both formats, we don't need to do much more.

The two basically [[https://www.w3.org/TR/css-color-4/#lab-to-lch][share formulas]], so I'm going to create the helpers =scalarToPolar()= and =scalarFromPolar=.

#+BEGIN_SRC js
function scalarToPolar([, scalarValues]) {
  const [L, a, b, A] = scalarValues;

  const C = Math.sqrt(a ** 2 + b ** 2);
  const H = Math.atan2(b, a);

  return [L, C, H, A];
}

function scalarFromPolar([, polarValues]) {
  const [L, C, H, A] = polarValues;

  const a = C * Math.cos(H);
  const b = C * Math.sin(H);

  return [L, a, b, A];
}
#+END_SRC

******* CIELAB <-> CIELCH

#+BEGIN_SRC js
function cielabToCielch([, cielabValues]) {
  return ["cielch", scalarToPolar(["cielab", cielabValues])];
}

function cielabFromCielch([, cielchValues]) {
  return ["cielab", scalarFromPolar(["cielch", cielchValues])];
}
#+END_SRC

******* OKLab <-> OKLCH

#+BEGIN_SRC js
function oklabToOklch([, oklabValues]) {
  return ["oklch", scalarToPolar(["oklab", oklabValues])];
}

function oklabFromOklch([, oklchValues]) {
  return ["oklab", scalarFromPolar(["oklch", oklchValues])];
}
#+END_SRC

****** Color Conversion Pipeline

Phew, now that we've prepared each individual format, it's time to construct the color conversion pipeline.

This will essentially be composed of two objects: =INPUT_TO_RGB= and =RGB_TO_OUTPUT= inside our main color =format()=
function. You give it a color as input which then gets validated, has its components, extracted, and then parsed. The
parsed values are then passed along and converted to a specified output format.

#+BEGIN_SRC js
function _convert(color, to) {
  // Let's make the pathway explicit
  const valid = validator(color);
  const extraction = extractor(valid);
  const [format, values] = parser(extraction);

  // Takes the input and formats it to RGB depending on format
  const INPUT_TO_RGB = (input) => ({
    named: hexToRgb(input),
    hex: hexToRgb(input),
    rgb: rgbInputIdentity(input), // identity
    hsl: hslToRgb(input),
    cmyk: cmykToRgb(input),
    hwb: hwbToRgb(input),
    cielab: cielabToRgb(input),
    cielch: cielabToRgb(cielabFromCielch(input)),
    oklab: oklabToRgb(input),
    oklch: oklabToRgb(oklabFromOklch(input)),
  });

  // Takes the RGB and formats to output target
  const RGB_TO_OUTPUT = (rgb) => ({
    hex: hexFromRgb(rgb),
    rgb: rgbOutputIdentity(rgb), // identity
    hsl: hslFromRgb(rgb),
    cmyk: cmykFromRgb(rgb),
    hwb: hwbFromRgb(rgb),
    cielab: cielabFromRgb(rgb),
    cielch: cielabToCielch(cielabFromRgb(rgb)),
    oklab: oklabFromRgb(rgb),
    oklch: oklabToOklch(oklabFromRgb(rgb)),
  });

  // Construct the pipeline
  const OUTPUT = RGB_TO_OUTPUT(INPUT_TO_RGB([format, values])[format])[to];

  return OUTPUT;
}
#+END_SRC

***** Serialization

All of that is well and good, but this leaves the converted color in a state that the user doesn't expect, and the
browser can't make any use of. That's why we have to /serialize/ the result.

Serialization is basically validation in reverse. We take the conversion data, perform the final bits of modification,
and then put it back into a color string and give it to the user. We want a different serialization method based on the
format, but we already have that information.

Now let's create the serialization functions.

****** Serializing RGB Hex

Concatenate the =hexResult= with a =#=. If the alpha channel is =ff=, the color is opaque and alpha should be removed.

#+BEGIN_SRC js
function serializeHex([, hexResult]) {
  const [R, G, B, A] = hexResult;

  if (A === "ff") {
    return "#".concat(R, G, B);
  }
  return "#".concat(R, G, B, A);
}
#+END_SRC

****** Serializing Functional Formats

Functional color formats have an incredibly uniform syntax, so let's create a helper =serializeFunctionalFormat()= to
logically assemble the data. It needs to be generic enough for us to simply attach a prefix and plug in values; similar
to =matchFunctionalFormat()= above.

#+BEGIN_SRC js
function serializeFunctional_Convert({ prefix, legacy = true }, components) {
  const DELIMITER = legacy ? ", " : " ";
  const ALPHA_DELIMITER = legacy ? ", " : " / ";

  // Coercing the result of toFixed() to a number preserves precision while removing trailing zeroes.
  const isOpaque = components[components.length - 1] === 1;
  const values = components.slice(0, components.length - 1);
  const alpha = (+components.slice(-1)).toFixed(3);

  return (legacy && !isOpaque ? `${prefix}a(` : `${prefix}(`).concat(
    values.join(DELIMITER),
    isOpaque ? "" : ALPHA_DELIMITER.concat(alpha),
    ")",
  );
}
#+END_SRC

******* Serializing RGB

#+BEGIN_SRC js
function serializeRgb([, rgbResult]) {
  const [r, g, b, A] = rgbResult;

  // Clamp RGB channels 0-255
  const [R, G, B] = [r, g, b].map(
    (component) => +clamp(component, 0, 255).toFixed(3),
  );

  return serializeFunctional_Convert({ prefix: "rgb" }, [R, G, B, A]);
}
#+END_SRC

******* Serializing HSL

#+BEGIN_SRC js
function serializeHsl([, hslResult]) {
  const [h, s, l, A] = hslResult;

  // Correct the hue result
  const H = hueCorrection(+h.toFixed(3));

  // format saturation, lightness to percentages
  const [S, L] = [s, l].map((n) => `${+numberToPercentage(n).toFixed(3)}%`);

  return serializeFunctional_Convert({ prefix: "hsl" }, [H, S, L, A]);
}
#+END_SRC

******* Serializing CMYK

#+BEGIN_SRC js
function serializeCmyk([, cmykResult]) {
  const [c, m, y, k, A] = cmykResult;

  // Format to percentage, cap at 0-100
  const [C, M, Y, K] = [c, m, y, k].map(
    (n) =>
      `${+clamp(numberToPercentage(isNaN(n) ? 0 : n), 0, 100).toFixed(3)}%`,
  );

  return serializeFunctional_Convert({ prefix: "device-cmyk", legacy: false }, [
    C,
    M,
    Y,
    K,
    A,
  ]);
}
#+END_SRC

******* Serializing HWB

#+BEGIN_SRC js
function serializeHwb([, hslResult]) {
  const [h, w, blk, A] = hslResult;

  // Correct the hue result
  const H = hueCorrection(+h.toFixed(3));

  // format white, black to percentages
  const [W, BLK] = [w, blk].map((n) => `${+numberToPercentage(n).toFixed(3)}%`);

  return serializeFunctional_Convert({ prefix: "hwb", legacy: false }, [
    H,
    W,
    BLK,
    A,
  ]);
}
#+END_SRC

******* Serializing CIELAB/CIELCH

#+BEGIN_SRC js
function serializeCielab([, cielabValues]) {
  const [$L, $a, $b, A] = cielabValues;

  // Clamp lightness at 0-100
  const L = `${+clamp($L, 0, 100).toFixed(3)}%`;

  // Clamp a, b at ±127
  const [a, b] = [$a, $b].map((n) => +clamp(n, -127, 127).toFixed(3));

  return serializeFunctional_Convert({ prefix: "lab", legacy: false }, [
    L,
    a,
    b,
    A,
  ]);
}

function serializeCielch([, cielchValues]) {
  const [$L, c, h, A] = cielchValues;

  // Clamp lightness at 0-100
  const L = `${+clamp($L, 0, 100).toFixed(3)}%`;

  // Clamp chroma at 0-132
  const C = +clamp(c, 0, 132).toFixed(3);

  let H = h;

  // Hue is powerless if chroma is 0
  if (C === 0) {
    H = 0;
  } else {
    // Otherwise, format hue to degrees, correct hue
    H = +hueCorrection(radiansToDegrees(h)).toFixed(3);
  }

  return serializeFunctional_Convert({ prefix: "lch", legacy: false }, [
    L,
    C,
    H,
    A,
  ]);
}
#+END_SRC

******* Serializing OKLab/OKLCH

#+BEGIN_SRC js
function serializeOklab([, oklabValues]) {
  const [$L, $a, $b, A] = oklabValues;

  // Format number to percentage, clamp at 0-100
  const L = `${+clamp(numberToPercentage($L), 0, 100).toFixed(3)}%`;

  // Clamp a, b at ±0.5
  const [a, b] = [$a, $b].map((n) => +clamp(n, -0.5, 0.5).toFixed(5));

  return serializeFunctional_Convert({ prefix: "oklab", legacy: false }, [
    L,
    a,
    b,
    A,
  ]);
}

function serializeOklch([, oklchValues]) {
  const [$L, c, h, A] = oklchValues;

  // Format lightness to percentage, clamp at 0-100
  const L = `${+clamp(numberToPercentage($L), 0, 100).toFixed(3)}%`;

  // Clamp chroma at 0-0.5
  const C = +clamp(c, 0, 0.5).toFixed(5);

  let H = h;

  // Hue is powerless if chroma is 0
  if (C === 0) {
    H = 0;
  } else {
    // Otherwise, format hue to degrees, correct hue
    H = +hueCorrection(radiansToDegrees(h)).toFixed(3);
  }

  return serializeFunctional_Convert({ prefix: "oklch", legacy: false }, [
    L,
    C,
    H,
    A,
  ]);
}
#+END_SRC

****** Serialization Interface

To clean things up, we'll create a direct interface for serialization. The =serialize()= function will check the format
of the incoming color calculation results and execute its corresponding serialization function.

#+BEGIN_SRC js
function serialize([format, results]) {
  const serializers = {
    hex: serializeHex,
    rgb: serializeRgb,
    hsl: serializeHsl,
    cmyk: serializeCmyk,
    hwb: serializeHwb,
    cielab: serializeCielab,
    cielch: serializeCielch,
    oklab: serializeOklab,
    oklch: serializeOklch,
  };

  return serializers[format]([format, results]);
}
#+END_SRC

**** Color Adjustment

Now that color conversion is handled, we can move on to color actions. The first necessary action we can perform on a
color is /adjustment/.

***** Target Properties

The properties we can adjust include:

+ Lightness/Luminance: The amount of light a color reflects or absorbs relative to its illuminant (light source). Though
  it's easier to think of it as how light or dark a given color is (with amounts >50 trending toward white and <50
  trending toward black).
+ Chroma/Saturation: A measure of a color's chromatic purity. Generally, a measure of color /intensity/ (with amounts
  >50 trending toward vivid and <50 trending toward subtle). An achromatic color will thereby be some shade of gray.
+ Hue: This can be thought of as a color's inherent quality. When we say light blue or muted yellow, the hue describes
  the way our eyes /perceive/ a given color. Hue is adjusted in terms of a wheel (where ±360 changes nothing and 180
  shifts hue to its opposite).
+ Alpha: A measure of how much light a color allows to pass through it (with amounts >50 trending toward solid and <50
  trending toward total transparency).

***** Perceptually Uniform Color Adjustment

Many color libraries allow you to choose the color space you want to adjust colors through or otherwise default to sRGB
as it's the most familiar to developers and digital designers.

This is the point where I emphasize that QuarkSuite is not a general purpose color manipulation library. QuarkSuite
allows color manipulation /only to the extent needed/ for practical color palette creation and modification. The sRGB
color space has some quirks that made it unreliable for sequential, predictable palette building.

Color properties in the sRGB space are not /orthogonal/. That is, a hue shift is also a lightness shift. Adjusting
lightness sometimes influences hue. Adjusting chroma sometimes made a color darker.

It's one of those things that didn't bother me much as a designer but became an immediate problem when developing a
tool; these small, subtle shifts led to weird behavior when replicated at scale. It also made predictable color blending
an exercise in frustration.

***** Color Adjustment Through OKLCH

OKLab solved the above issues. As an offshoot of CIELAB, perceptual uniformity is baked into its calculations. As an
/improvement/ on CIELAB, these calculations were adjusted for increased practicality and predictability. In short, it
made sequential palette building both possible and simpler.

Its OKLCH polar form is also vastly more intuitive for color property adjustment than its raw OKLab scalar form.

The approach in steps:

1. Convert the input color to OKLCH equivalent
2. Adjust its target properties
3. Convert result back to its input format

#+BEGIN_SRC js
function extractOklchValues(color) {
  const formatedOklch = serializeOklch(_convert(color, "oklch"));
  const [, components] = extractor(["oklch", formatedOklch]);

  return components.map((V) => parseFloat(V));
}

function adjustColorProperties(
  { lightness, chroma, hue, alpha },
  [l, c, h, a],
) {
  // Adjust properties only if defined, make values parseable
  let L = numberFromPercentage(lightness ? l + lightness : l);
  let C = chroma ? c + numberFromPercentage(chroma) * 0.5 * 0.5 : c;
  let H = radiansFromDegrees(hue ? hueCorrection(h + hue) : h);
  let A = alpha ? (a ?? 1) + numberFromPercentage(alpha) : a ?? 1;

  // Return adjusted values
  return [L, C, H, A];
}

function serializeInput([format, values]) {
  const SERIALIZATION_TARGETS = {
    hex: serializeHex,
    rgb: serializeRgb,
    hsl: serializeHsl,
    cmyk: serializeCmyk,
    hwb: serializeHwb,
    cielab: serializeCielab,
    cielch: serializeCielch,
    oklab: serializeOklab,
    oklch: serializeOklch,
  };

  return SERIALIZATION_TARGETS[format]([format, values]);
}

function colorAdjustment(
  { lightness = 0, chroma = 0, hue = 0, alpha = 0 },
  color,
) {
  // Ensure color is valid and store its format
  const [format] = validator(color);

  // Extract its OKLCH values
  const values = extractOklchValues(color);

  // Adjust target properties
  const [L, C, H, A] = adjustColorProperties(
    { lightness, chroma, hue, alpha },
    values,
  );

  // Serialize oklch result
  const oklch = serializeOklch(["oklch", [L, C, H, A]]);

  // If input format is named, format to hex
  if (format === "named") {
    return serializeInput(_convert(oklch, "hex"));
  }

  // Otherwise use input format
  return serializeInput(_convert(oklch, format));
}
#+END_SRC

**** Color Mixture

The second important color action is mixture (or blending). This is when we take a color and, well, mix it with another
color. This allows us to create colors for serving as natural gradient stops or to create /true/ tints, tones, and
shades from a color.

***** Perceptually Uniform Color Mixture

Similar to color adjustment, all color mixture happens through the OKLab space. The main advantage of using OKLab in
this area is that it yields smooth, even blending. This is most evident when blending blue with white.

When I attempted color mixing through the sRGB space, I wouldn't always get the expected results. Especially when mixing
colors of high chroma with those of low. This often resulted in the high chroma color looking slightly washed out or
(depending on the strength of the mixture) the low chroma color overwriting the high chroma.

Either way, the results didn't seem like true blends to my eyes (even if they were mathematically correct).

***** Color Mixture Through OKLab

In the area of color mixture, raw scalar OKLab is the ideal tool. This is because when we talk about color blending,
we're actually talking about /color difference/.

A color blend is what you get when you calculate the difference of a blending =target= from an input =color= adjusted for the =strength=
of the mixture. Returning the difference gives you the point of intersection, which is also the blend result.

The process goes:

1. Convert the blend target and input color to OKLab
2. Parse the OKLab values
3. Calculate the blend result (as =X + (Y - X) * strength=) for the individual components
4. Revert the result to the input color format and return it

Note that we also added a condition to reverse the mixture direction if =strength= is negative.

#+BEGIN_SRC js
function getOklabValues(color) {
  return _convert(color, "oklab");
}

function calculateMixture(color, target, strength) {
  // format blend target and input color to OKLab
  const [, [$L, $a, $b, $A]] = getOklabValues(color);
  const [, [$$L, $$a, $$b, $$A]] = getOklabValues(target);

  // calculate the blend result
  const [L, a, b, A] = [
    [$L, $$L],
    [$a, $$a],
    [$b, $$b],
    [$A, $$A],
  ].map(([X, Y]) => {
    // if -strength, blend FROM target
    // --------------------------------------------------------------
    // Note: Object.is() is a handy way to explicitly check for a strength of -0, which
    // should also trigger a blend inversion. This is not caught by Math.sign() alone,
    // because the way JS treats signed zeroes is identical.
    //
    // Which also means `Math.sign(strength) === -0` didn't work either.
    if (Math.sign(strength) === -1 || Object.is(strength, -0)) {
      return Y + (X - Y) * Math.abs(strength);
    }

    // Otherwise, blend TO target
    return X + (Y - X) * strength;
  });

  return [L, a, b, A];
}

function colorMix({ target, strength = 0 }, color) {
  // Validate input color and store its format
  const [format] = validator(color);

  // Calculate blend
  const [L, a, b, A] = calculateMixture(
    color,
    target,
    numberFromPercentage(strength),
  );

  // Serialize the blend result
  const oklab = serializeOklab(["oklab", [L, a, b, A]]);

  if (format === "named") {
    return serializeInput(_convert(oklab, "hex"));
  }

  return serializeInput(_convert(oklab, format));
}
#+END_SRC

**** Color Perception

Recently, I decided it would be a great idea to implement ways to simulate conditions under which a person's /perception/
of colors may change. Specifically the conditions of:

+ Color Vision Deficiency (Colorblindness)
+ Contrast Sensitivity
+ Correlated color temperature (CCT)

Once the simulation details are implemented, I believe every practical sense of using color is then covered by
QuarkSuite's color API.

***** Color Vision Deficiency (Colorblindness)

If you want a full introduction to what color vision deficiency is and why it's important, [[http://www.color-blindness.com/what-is-color-blindness/][this article on the
phenomenon]] will get you caught up.

What I want to focus on is the technical details of simulating colorblindness (or daltonization) so we can troubleshoot
and analyze the viability of the colors we use.

****** On CVD Algorithms

For this, I was originally going to use Daltonize's [[http://www.daltonize.org/2010/05/lms-daltonization-algorithm.html][daltonization algorithm]] because it's widely available and already
has a JavaScript implementation. That wide availability can be double-edged, however, so I slept on it.

After some additional research, I eventually landed on this DaltonLens article [[https://daltonlens.org/opensource-cvd-simulation/][assessing the different approaches]] to
color vision deficiency simulation.

Now I know that Brettel 1997 and Vienot 1999 are the most accurate for calculating protan and deuteran deficiency. Vienot has
a slight performance benefit over Brettel—which is slightly more accurate. I'm not sure how much difference that will
make in a browser environment, so I'll do some profiling.

There is also the Machado 2009 algorithm, but I left it out because the consensus [[https://www.reddit.com/r/ColorBlind/comments/qzkl7h/lets_collectively_determine_the_best_color/][among some actually dichromatic folks]]
is that it's not quite as accurate in most cases. I'll implement it in the future if needed, though.

I also know now that Brettel 1997 is the /only accurate/ known method for simulating tritan deficiency, so that's locked
in for the implementation.

The other important bit: both algorithms were written with the gamut allowed for CRT monitors in mind, so they'll need
to be adapted for sRGB.

****** CVD Simulation Process

The actual process we'll be using is [[https://github.com/DaltonLens/libDaltonLens][adapted from libDaltonLens]]: a C library that's not too painless to translate to
JavaScript. It takes care of the aforementioned sRGB adaptation as well.

******* CVD Brettel Simulation

#+BEGIN_SRC js
function cvdBrettelSimulation({ type, strength = 100 }, color) {
  // Parse values from RGB
  const [, [r, g, b, A]] = parser(
    extractor(["rgb", serializeRgb(_convert(color, "rgb"))]),
  );

  // Format RGB to linear RGB
  const [LR, LG, LB] = rgbToLrgb([r, g, b]);

  // Set up the Brettel simulation matrices
  const brettel = {
    protanope: {
      a: [
        0.1498,
        1.19548,
        -0.34528,
        0.10764,
        0.84864,
        0.04372,
        0.00384,
        -0.0054,
        1.00156,
      ],
      b: [
        0.1457,
        1.16172,
        -0.30742,
        0.10816,
        0.85291,
        0.03892,
        0.00386,
        -0.00524,
        1.00139,
      ],
      n: [0.00048, 0.00393, -0.00441],
    },
    deuteranope: {
      a: [
        0.36477,
        0.86381,
        -0.22858,
        0.26294,
        0.64245,
        0.09462,
        -0.02006,
        0.02728,
        0.99278,
      ],
      b: [
        0.37298,
        0.88166,
        -0.25464,
        0.25954,
        0.63506,
        0.1054,
        -0.0198,
        0.02784,
        0.99196,
      ],
      n: [-0.00281, -0.00611, 0.00892],
    },
    tritanope: {
      a: [
        1.01277,
        0.13548,
        -0.14826,
        -0.01243,
        0.86812,
        0.14431,
        0.07589,
        0.805,
        0.11911,
      ],
      b: [
        0.93678,
        0.18979,
        -0.12657,
        0.06154,
        0.81526,
        0.1232,
        -0.37562,
        1.12767,
        0.24796,
      ],
      n: [0.03901, -0.02788, -0.01113],
    },
  };

  // Determine which plane to use
  const { a: $a, b: $b, n } = brettel[type];
  const dotWithSepPlane = LR * n[0] + LG * n[1] + LB * n[2];
  const p = dotWithSepPlane >= 0 ? $a : $b;

  // Apply the dichromatic confusion line adjusted for severity,
  // then format back to sRGB
  const [R, G, B] = lrgbToRgb(
    [
      [p[0] * LR + p[1] * LG + p[2] * LB, LR],
      [p[3] * LR + p[4] * LG + p[5] * LB, LG],
      [p[6] * LR + p[7] * LG + p[8] * LB, LB],
    ].map(([cvdComponent, component]) => {
      const severity = numberFromPercentage(strength);

      return cvdComponent * severity + component * (1 - severity);
    }),
  );

  return [R, G, B, A];
}
#+END_SRC

******* CVD Vienot Simulation

#+BEGIN_SRC js
function cvdVienotSimulation({ type, strength = 100 }, color) {
  // Parse values from RGB
  const [, [r, g, b, A]] = parser(
    extractor(["rgb", serializeRgb(_convert(color, "rgb"))]),
  );

  // Format RGB to linear RGB
  const [LR, LG, LB] = rgbToLrgb([r, g, b]);

  // Right off the bat, if the type is "tritanope", use the Brettel method
  if (type === "tritanope") {
    return cvdBrettelSimulation({ type, strength }, color);
  }

  // Otherwise use the correct transformation matrix

  const vienot = {
    protanope: [
      0.11238,
      0.88762,
      0.0,
      0.11238,
      0.88762,
      -0.0,
      0.00401,
      -0.00401,
      1.0,
    ],
    deuteranope: [
      0.29275,
      0.70725,
      0.0,
      0.29275,
      0.70725,
      -0.0,
      -0.02234,
      0.02234,
      1.0,
    ],
  };

  // Vienot 1999 uses a single plane
  const p = vienot[type];

  // Apply the dichromatic confusion line adjusted for severity,
  // then format back to sRGB
  const [R, G, B] = lrgbToRgb(
    [
      [p[0] * LR + p[1] * LG + p[2] * LB, LR],
      [p[3] * LR + p[4] * LG + p[5] * LB, LG],
      [p[6] * LR + p[7] * LG + p[8] * LB, LB],
    ].map(([cvdComponent, component]) => {
      const severity = numberFromPercentage(strength);

      return cvdComponent * severity + component * (1 - severity);
    }),
  );

  return [R, G, B, A];
}
#+END_SRC

****** Color Vision Deficiency Interface

The interface exposes the two =methods= and allows us to define the =type= and =strength= of the simulation. Color
perception is incredibly subjective even without considering dichromacy, so we should adjust the simulation according to
our audience.

The main purpose of it in this library, however, is to help designers and developers create relatively safe and
/inclusive/ color schemes.

#+BEGIN_SRC js
function checkColorblindness(
  { method = "brettel", type, strength = 0 },
  color,
) {
  // Validate input color and store result
  const [format] = validator(color);

  let values = [];

  // Prefer the "brettel" method for accuracy
  if (method === "brettel") {
    values = cvdBrettelSimulation({ type, strength }, color);
  }

  // Prefer "vienot" under special cases and for performance
  if (method === "vienot") {
    values = cvdVienotSimulation({ type, strength }, color);
  }

  // Serialize RGB, but leave the alpha alone
  const rgb = serializeRgb([
    "rgb",
    values.map((component, index) =>
      index !== 3 ? numberToChannel(component) : component
    ),
  ]);

  if (format === "named") {
    return serializeInput(_convert(rgb, "hex"));
  }

  return serializeInput(_convert(rgb, format));
}
#+END_SRC

***** Contrast Sensitivity

After all that, simulating [[https://www.vision-and-eye-health.com/contrast-sensitivity.html][contrast sensitivity]] is mercifully simple.

As the linked article notes: maximum contrast is a comparison between black and white. Shades of gray by definition
reduce our ability to discern contrast. And so gray is the anchor of our simulation.

This leads to the following process:

1. Mix black and white together with a user defined =contrast= setting
2. Take the resulting gray, mix in the input color with a given =strength=

That's all.

#+BEGIN_SRC js
function checkSensitivity({ contrast = 0, strength = 0 }, color) {
  // Derive contrast from a shade of gray
  const GRAY = colorMix(
    {
      target: "white",
      strength: 100 * numberFromPercentage(contrast),
    },
    "black",
  );

  // Mix resultant gray with input color
  return colorMix(
    {
      target: GRAY,
      strength: 100 * numberFromPercentage(strength),
    },
    color,
  );
}
#+END_SRC

***** Correlated Color Temperature (CCT)

Correlated color temperature, without getting too technical: a translation of an absolute temperature (expressed in
Kelvin) to the /matched chromacity/ of, for example, cooking a black pot. You can [[https://www.olympus-lifescience.com/en/microscope-resource/primer/lightandcolor/colortemp/][read more if you want]] to dig into the
meat of it.

For our purposes, the steps boil down to:

1. Convert a temperature (in Kelvin) to RGB
2. Blend the result and the input color with user-defined strength

Thanks to Tanner Helland, we have a [[https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html][nice and clean algorithm at the ready]]. I'm gonna adapt the code itself from a [[https://github.com/m-lima/temperagb][Rust
implementation for this]], because it's clear, concise, and the tests are right there for comparison.

#+BEGIN_SRC js
function kelvinToRgb(temperature) {
  // The accurate range for this algorithm is 1000-40000K
  // and K / 100 is required
  const K = clamp(temperature, 1000, 40000) / 100;

  // Initialize RGB
  let R = 0;
  let G = 0;
  let B = 0;

  // If K <66, R locks at 255
  if (K <= 66) {
    R = 255;
    G = 99.4708025861 * Math.log(K) - 161.1195681661;

    // B locks at 0 when K <19
    if (K <= 19) {
      B = 0;
    } else {
      B = 138.577412231 * Math.log(K - 10) - 305.0447927307;
    }
  } else {
    // Otherwise K >66
    R = 329.698727446 * (K - 60) ** -0.1332047592;
    G = 288.1221695283 * (K - 60) ** -0.0755148492;
    B = 255;
  }

  // Serialize RGB
  return serializeRgb(["rgb", [R, G, B, 1]]);
}

function checkIlluminant({ temperature = 1000, strength = 0 }, color) {
  const target = kelvinToRgb(temperature);

  return colorMix({ target, strength }, color);
}
#+END_SRC

**** Color Interpolation

Now that the main color actions are defined and implemented, we have almost all the tools required to generate full
palettes. The missing ingredient is interpolation. QuarkSuite supports three kinds of interpolation:

+ Interpolating over properties
+ Interpolating over a mixture
+ Interpolating over perception checks

From this, we'll a helper for actions to generate tints, tones, and shades as well as blends and a few extras. The two
action helpers we created so far have a similar call structure with only slight differences in the behavior, so we'll create
=colorInterpolation()= as a /higher-order function/.

Without getting too deeply into it, a higher-order function (or HOF) is a function that accepts another function as one
of its arguments. It's a good tool to use in situations where you have related functions with similar call structure but
differing internal behavior. Such as this one.

#+BEGIN_SRC js
function colorInterpolation(action, settings, input) {
  // Set default for shared step property
  const { steps = 1 } = settings;

  // Fill an array with a length of steps with the input color
  return [
    ...new Set(
      Array(steps)
        .fill(input)
        .map((color, pos) => {
          // General interpolation formula
          const interpolate = (property, index) =>
            property - (property / steps) * index;

          // Store result
          let result = "";

          // Now, we vary the behavior here based on the name of the action
          if (action.name === "colorAdjustment") {
            // Destructure unique properties
            const { lightness = 0, chroma = 0, hue = 0, alpha = 0 } = settings;

            result = colorAdjustment(
              {
                lightness: interpolate(lightness, pos),
                chroma: interpolate(chroma, pos),
                hue: interpolate(hue, pos),
                alpha: interpolate(alpha, pos),
              },
              color,
            );
          }

          if (action.name === "colorMix") {
            // Destructure unique properties
            const { strength = 0, target = color } = settings;

            result = colorMix(
              { strength: interpolate(strength, pos), target },
              color,
            );
          }

          if (action.name === "checkColorblindness") {
            const { method = "brettel", type, strength = 0 } = settings;

            result = checkColorblindness(
              {
                method,
                type,
                strength: interpolate(strength, pos),
              },
              color,
            );
          }

          if (action.name === "checkSensitivity") {
            const { contrast = 0, strength = 0 } = settings;

            result = checkSensitivity(
              {
                contrast: interpolate(contrast, pos),
                strength: interpolate(strength, pos),
              },
              color,
            );
          }

          if (action.name === "checkIlluminant") {
            const { temperature = 1000, strength = 0 } = settings;

            result = checkIlluminant(
              {
                temperature: interpolate(temperature, pos),
                strength: interpolate(strength, pos),
              },
              color,
            );
          }

          return result;
        }),
    ),
  ].reverse();
}
#+END_SRC

**** Color Harmonies

QuarkSuite provides a conventional set of color schemes (or harmonies) to get
you started on aesthetically pleasing color palettes. When combined with the
above color perception checks, you can create aesthetically pleasing and
accessible color schemes.

The following schemes are supported:

+ dyadic
+ analogous
+ complementary
+ split (complementary)
+ triadic
+ clash
+ tetradic
+ square
+ five color
+ six color

In addition, where it makes sense, the color harmony action allows an =accented=
flag that will include the complement in the scheme for those common accented
variations.

#+BEGIN_SRC js
function colorHarmonies({ type, accented = false }, color) {
  const withComplement = accented ? [colorAdjustment({ hue: 180 }, color)] : [];

  const harmonies = {
    dyadic: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 30 }, color),
      ...withComplement,
    ],
    complementary: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 180 }, color),
    ],
    analogous: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 30 }, color),
      colorAdjustment({ hue: 30 * 2 }, color),
      ...withComplement,
    ],
    split: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 180 - 30 }, color),
      ...withComplement,
      colorAdjustment({ hue: 180 + 30 }, color),
    ],
    clash: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 90 }, color),
      colorAdjustment({ hue: 90 * 3 }, color),
    ],
    triadic: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 120 }, color),
      ...withComplement,
      colorAdjustment({ hue: 120 * 2 }, color),
    ],
    double: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 30 }, color),
      colorAdjustment({ hue: 180 }, color),
      colorAdjustment({ hue: 180 + 30 }, color),
    ],
    tetradic: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 45 }, color),
      colorAdjustment({ hue: 180 }, color),
      colorAdjustment({ hue: 180 + 45 }, color),
    ],
    square: [
      colorAdjustment({ hue: 0 }, color),
      colorAdjustment({ hue: 90 }, color),
      colorAdjustment({ hue: 90 * 2 }, color),
      colorAdjustment({ hue: 90 * 3 }, color),
    ],
  };

  return harmonies[type];
}
#+END_SRC

**** Palette Configurations

We made it, y'all. We finally have the full set of color generation helpers to create palettes suitable for web design.

To this end, QuarkSuite supports two main palette configurations:

+ Material-esque: This is a palette composed of a scale =[ui[], [variants[], accents[]], states[]]=. This is configured
  similar to the way Material Design palettes are configured (but not exactly, so material-/esque/).
+ Artistic: This is a classical palette where you can create a scale of =[ui[], [tints[], tones[], shades[]], states[]]=
  with set levels of contrast between your variants.

***** Material Configuration

For the material configuration, we're going to allow the user to define the overall light and dark contrast as well as
place the accent palette behind an =accented= boolean. If defined, it will add in the accents to the end of the variant collection.
The same occurs for the interface states if =stated= is true.

#+BEGIN_SRC js
function materialConfiguration(
  { contrast = 100, accented = false, stated = false },
  color,
) {
  // [bg, fg]
  const ui = [
    colorMix(
      { target: "#fff", strength: 100 * numberFromPercentage(contrast) },
      color,
    ),
    colorMix(
      { target: "#111", strength: 100 * numberFromPercentage(contrast) },
      color,
    ),
  ];

  // [50, 100, 200, 300, 400, 500, 600, 700, 800, 900]
  const variants = [
    ...colorInterpolation(
      colorMix,
      {
        target: "#fff",
        strength: 90 * numberFromPercentage(contrast),
        steps: 6,
      },
      color,
    ).reverse(),
    ...colorInterpolation(
      colorMix,
      {
        target: "#111",
        strength: 90 * numberFromPercentage(contrast),
        steps: 4,
      },
      color,
    ),
  ];

  // [A100, A200, A300, A400]
  const accents = accented
    ? [
      colorAdjustment(
        {
          lightness: 25 * numberFromPercentage(contrast),
          chroma: -50,
          hue: -15,
        },
        color,
      ),
      colorAdjustment(
        { chroma: -25 * numberFromPercentage(contrast), hue: -15 },
        color,
      ),
      colorAdjustment(
        {
          lightness: 25 * numberFromPercentage(contrast),
          chroma: 50,
          hue: -15,
        },
        color,
      ),
      colorAdjustment(
        {
          lightness: -25 * numberFromPercentage(contrast),
          chroma: 50,
          hue: 15,
        },
        color,
      ),
    ]
    : [];

  // [PENDING, SUCCESS, WARNING, ERROR]
  const states = stated
    ? [
      colorMix({ target: "gainsboro", strength: 90 }, color),
      colorMix({ target: "forestgreen", strength: 90 }, color),
      colorMix({ target: "goldenrod", strength: 90 }, color),
      colorMix({ target: "firebrick", strength: 90 }, color),
    ]
    : [];

  return [ui, [variants, accents], states];
}
#+END_SRC

***** Artistic Configuration

For the artistic configuration, we're going to allow the user to set overall =contrast= and an output limit for each
variant. =stated= is also allowed here and works identically to the material-esque config.

#+BEGIN_SRC js
function artisticConfiguration(
  { contrast = 100, tints = 3, tones = 3, shades = 3, stated = false },
  color,
) {
  // [bg, fg]
  const ui = [
    colorMix(
      { target: "#fff", strength: 100 * numberFromPercentage(contrast) },
      color,
    ),
    colorMix(
      { target: "#111", strength: 100 * numberFromPercentage(contrast) },
      color,
    ),
  ];

  // [tints[], tones[], shades[]]
  const variants = [
    tints
      ? colorInterpolation(
        colorMix,
        {
          target: "#fff",
          strength: 90 * numberFromPercentage(contrast),
          steps: tints,
        },
        color,
      )
      : [],
    tones
      ? colorInterpolation(
        colorMix,
        {
          target: "#aaa",
          strength: 90 * numberFromPercentage(contrast),
          steps: tones,
        },
        color,
      )
      : [],
    shades
      ? colorInterpolation(
        colorMix,
        {
          target: "#111",
          strength: 90 * numberFromPercentage(contrast),
          steps: shades,
        },
        color,
      )
      : [],
  ];

  // [PENDING, SUCCESS, WARNING, ERROR]
  const states = stated
    ? [
      colorMix({ target: "gainsboro", strength: 90 }, color),
      colorMix({ target: "forestgreen", strength: 90 }, color),
      colorMix({ target: "goldenrod", strength: 90 }, color),
      colorMix({ target: "firebrick", strength: 90 }, color),
    ]
    : [];

  return [ui, variants, states];
}
#+END_SRC

**** Palette Accessibility

Before formatting our palette as a color token dictionary, we're going to provide a means for handling color
accessibility. The core targets are our palette =variants=, because =ui= and =states= remain constant. In addition, the
contrast context is the background color of our palette.

QuarkSuite determines color accessibility through two methods:

+ Standard WCAG Color Contrast Ratings
+ Colorimetric contrast calculations

***** WCAG Color Contrast Ratios

This is the way that most of us as front-end designers/developers are familiar with. If you've ever used a [[https://contrast-ratio.com/][contrast
ratio calculator]] on the internet, you know what this is about. For those who don't, the [[https://webaim.org/articles/contrast/][WebAIM article on it]] is a great
overview.

For the implementation, we'll be doing a few things in the following order:

1. Calculate the relative luminance between a background and foreground color (in the sRGB space)
2. Filtering out any =variants= that fail the user-defined contrast requirements against the background
3. Returning the altered palette

You'll see also that we've accounted for situations where we might want to calculate the most accessible colors from a
dark theme.

#+BEGIN_SRC js
function calculateRelativeLuminance(color) {
  const [, [R, G, B]] = parser(
    extractor(["rgb", serializeRgb(_convert(color, "rgb"))]),
  );

  const [LR, LG, LB] = rgbToLrgb([R, G, B]);

  return 0.2126 * LR + 0.7152 * LG + 0.0722 * LB;
}

function calculateWCAGContrastRatio(a, b) {
  return [a, b]
    .map((color) => calculateRelativeLuminance(color))
    .sort((a, b) => b - a)
    .map((LUM) => LUM + 0.05)
    .reduce((L1, L2) => L1 / L2);
}

function wcagContrastCriteria({ rating, large }, ratio) {
  return new Map([
    // minimum
    ["AA", large ? ratio >= 3.1 : ratio >= 4.5],
    // enhanced
    ["AAA", large ? ratio >= 4.5 : ratio > 7.1],
  ]).get(rating);
}

function variantContrastWcag({ rating, large, background }, variants) {
  const valid = (collection) =>
    collection.filter((foreground) => {
      const ratio = calculateWCAGContrastRatio(background, foreground);
      return wcagContrastCriteria({ rating, large }, ratio);
    });

  const optional = (fn, collection) => collection.length ? fn(collection) : [];

  if (variants.length === 2) {
    const [main, accents] = variants;

    return [valid(main), optional(valid, accents)];
  }

  const [tints, tones, shades] = variants;

  return [
    optional(valid, tints),
    optional(valid, tones),
    optional(valid, shades),
  ];
}

function paletteWcagContrast({ rating = "AA", large, dark = false }, palette) {
  // Extract palette datasets
  const [ui, variants, state] = palette;
  const [bg, fg] = ui;

  if (dark) {
    // Invert order of [bg, fg]
    const [fg, bg] = ui;
    return [
      [bg, fg],
      variantContrastWcag({ rating, large, background: bg }, variants),
      state,
    ];
  }

  return [
    [bg, fg],
    variantContrastWcag({ rating, large, background: bg }, variants),
    state,
  ];
}
#+END_SRC

***** Colorimetric Contrast

The second method of determining contrast uses the colorimetric data of the background itself. The process here is:

1. Convert background and foreground to OKLCH
2. Check the /perceptual/ lightness difference and filter out any colors that don't meet user-determined requirements
3. Return the altered palette

Much like the standard method, we account for the possibility of a dark theme.

/Only use this method if you need the precision./ The WCAG standard should be your choice for the majority of use cases.

#+BEGIN_SRC js
function comparePerceptualLightness(bg, fg) {
  const [, bgValues] = extractor([
    "oklch",
    serializeOklch(_convert(bg, "oklch")),
  ]);
  const [, fgValues] = extractor([
    "oklch",
    serializeOklch(_convert(fg, "oklch")),
  ]);

  const [bL] = bgValues.map((V) => parseFloat(V));
  const [fL] = fgValues.map((V) => parseFloat(V));

  return numberToPercentage(Math.abs((bL - fL) / 100));
}

function filterCondition({ min, max }, difference) {
  return max ? difference >= min && difference <= max : difference >= min;
}

function variantsColorimetricContrast({ min, max, background }, variants) {
  const valid = (collection) =>
    collection.filter((foreground) => {
      const difference = comparePerceptualLightness(background, foreground);

      return filterCondition({ min, max }, difference);
    });

  const optional = (fn, collection) => collection.length ? fn(collection) : [];

  if (variants.length === 2) {
    const [main, accents] = variants;

    return [valid(main), optional(valid, accents)];
  }

  const [tints, tones, shades] = variants;

  return [
    optional(valid, tints),
    optional(valid, tones),
    optional(valid, shades),
  ];
}

function paletteColorimetricContrast({ min = 75, max, dark = false }, palette) {
  const [ui, variants, state] = palette;
  const [bg, fg] = ui;

  if (dark) {
    const [fg, bg] = ui;

    return [
      [bg, fg],
      variantsColorimetricContrast({ min, max, background: bg }, variants),
      state,
    ];
  }

  return [
    [bg, fg],
    variantsColorimetricContrast({ min, max, background: bg }, variants),
    state,
  ];
}
#+END_SRC

**** Palette Formatting

Now that we've generated our palettes, we'll need a way to assemble them into a dictionary of color tokens. At this
point, we know palette configurations output one of two standard data sets, so we'll only need to concern ourselves
with what's /different/ between them.

We'll need two helpers: =tokenizeMaterialVariants()= and =tokenizeArtisticVariants= to handle these special cases.

Finally, we contain the whole token assembly process in its own =tokenizePalette()= function

#+BEGIN_SRC js
function tokenizeMaterialVariants(variants) {
  // Extract [main[], accents[]]
  const [main, accents] = variants;

  return {
    // 50-900
    ...main.reduce((acc, color, index) => {
      if (index === 0) return { ...acc, 50: color };
      return { ...acc, [`${index}00`]: color };
    }, {}),
    // a100-a400
    ...(accents.length
      ? accents.reduce((acc, color, index) => {
        return { ...acc, [`a${++index}00`]: color };
      }, {})
      : {}),
  };
}

function tokenizeArtisticVariants(variants) {
  const [tints, tones, shades] = variants;

  // Here, we check the variants that contain data and filter out any that don't before assembling the tokens
  return Object.entries({ light: tints, muted: tones, dark: shades })
    .filter(([, data]) => data.length)
    .reduce((acc, [category, data]) => {
      return {
        ...acc,
        [category]: data.reduce((a, color, i) => {
          return { ...a, [`${++i}00`]: color };
        }, {}),
      };
    }, {});
}

function tokenizePalette(palette) {
  // Standard palettes share internal structure
  const [[bg, fg], variants, states] = palette;

  let variations = {};

  // Material palettes contain two kinds of variants
  if (variants.length === 2) {
    variations = tokenizeMaterialVariants(variants);
  }

  // Otherwise it's artistic
  if (variants.length === 3) {
    variations = tokenizeArtisticVariants(variants);
  }

  return {
    bg,
    fg,
    ...variations,
    ...(states.length
      ? {
        state: {
          pending: states[0],
          success: states[1],
          warning: states[2],
          error: states[3],
        },
      }
      : {}),
  };
}
#+END_SRC

*** Content
:PROPERTIES:
:header-args:js: :tangle "./v2/content.js" :mkdirp yes :comments link
:END:

Now that we're finally done with colors, we can move on to content.

This depends on a general workflow for creating and modifying modular scales. If you're coming from v1, you'll also
notice that I've eliminated formulas and bootstrappers in favor of creating tokens around typical scale configurations
(unidirectional, bidirectional, and range) and specific requirements (as with timing).

**** Modular Scales

Modular scales in v2 are primarily designed around providing consistent /options/. Modern CSS provides so many ways to
recalculate and interpolate values on the fly via logical functions (=min()=, =max()=, =calc()=, and =clamp()=) that it
no longer makes sense to expect that we'll be using full, static modular scales in web design for anything but
compatibility.

v2 modular scaling is intended to take full advantage of the fact that the future is fluid while accomodating the still
somewhat static present.

***** Creating a Raw Modular Scale

Raw scale creation is handled by a small =create= function. Raw modular scales assume relative units, so if you want to
create a pixel scale, set the base to =16=. In addition, multiple ratios are allowed for threaded scales.

#+BEGIN_SRC js
function create({ values = 6, ratio = 1.5 }, base) {
  if (Array.isArray(ratio)) {
    return [
      ...new Set(
        Array(values)
          .fill(base)
          .reduce(
            (acc, base, pos) => [...acc, ...ratio.map((r) => base * r ** pos)],
            []
          )
      ),
    ]
      .slice(0, values)
      .sort((a, b) => a - b);
  }

  return Array(values)
    .fill(base)
    .map((base, pos) => base * ratio ** pos);
}
#+END_SRC

***** Scale Modification

The first action available to modular scales is in-place modification of values. This is handled internally by an
=update()= function that accepts a calculation function and a raw scale, then outputs a new scale with the
recalculations.

#+BEGIN_SRC js
function update(calc, ms) {
  return ms.map((n) => calc(n));
}
#+END_SRC

***** Scale Configurations

Now we have all the pieces for creating and modifying raw modular scales, but in practice, we will often use particular
scale configurations.

+ Unidirectional: a scale that goes in one direction. (=base ->=)
+ Bidirectional: a scale that goes in two directions (=<- base ->=)
+ Ranged: a scale that has a minimum and maximum value and a range of values between them (=min -> max=)

There are other configurations that come into play with special cases, and we'll revisit those when we ecounter them.

We'll write =unidirectional=, =bidirectional()= and =ranged()= helpers to specifically handle each configuration.

#+BEGIN_SRC js
function unidirectional(ms) {
  const [base, ...x] = ms;

  return [base, x];
}

function bidirectional(ms) {
  const [base, ...x] = ms;
  const d = update((n) => base ** 2 / n, x);

  return [base, x, d];
}

function ranged({ min = 1, max = 10, trunc = false }, ms) {
  const [, ...x] = ms;

  const range = update((n) => {
    let value = min + (max - min) / n;
    return trunc ? Math.trunc(value) : value;
  }, x)
        .filter((n) => n > min && n < max)
        .sort((a, b) => a - b);

  return [min, range, max];
}
#+END_SRC

***** Scale Units

Once we've finished our calculation and configuration, we can attach our units. This is handled internally by the
=output()= helper.

#+BEGIN_SRC js
function output(unit, n) {
  return unit ? String(+n.toPrecision(5)).concat(unit) : +n.toPrecision(5);
}
#+END_SRC

**** Text Families

The code for text family tokens is largely unchanged from v1.

#+BEGIN_SRC js
const SYSTEM_FONT_STACKS = {
  sans: "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  serif:
  "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  monospace:
  "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
};

function generateStack(fallback, font) {
  return [font, SYSTEM_FONT_STACKS[fallback]].join(", ");
}

function fontWeights(key) {
  return new Map([
    ["thin", 100],
    ["extralight", 200],
    ["light", 300],
    ["regular", 400],
    ["medium", 500],
    ["semibold", 600],
    ["bold", 700],
    ["extrabold", 800],
    ["black", 900],
  ]).get(key);
}

function generateWeights(weights) {
  return weights.reduce((acc, key) => {
    const value = fontWeights(key);

    return { ...acc, [key]: value };
  }, {});
}

function textFamily({ system = "sans", weights = ["regular", "bold"] }, font) {
  return {
    family: generateStack(system, font),
    ...generateWeights(weights),
  };
}
#+END_SRC

**** Token Assembly

Now, let's create a helper to actually assemble our calculated modular scales into token dictionaries. Note that the
grid type calculates columns by the length of the modular scale and rows derive from columns.

#+BEGIN_SRC js
function assemble(settings, ms) {
  const { type = "bidirectional", unit = "rem", inversion = unit } = settings;

  if (type === "unidirectional") {
    const [base, x] = unidirectional(ms);

    return {
      base: output(unit, base),
      ...x
        .map((v) => output(unit, v))
        .reduce((acc, v, pos) => ({ ...acc, ["x".concat(++pos + 1)]: v }), {}),
    };
  }

  if (type === "ranged") {
    const { min = 1, max = 10, trunc = false } = settings;
    const [, range] = ranged({ min, max, trunc }, ms);

    return {
      base: output(unit, max),
      ...range
        .map((v) => output(unit, v))
        .reverse()
        .reduce((acc, v, pos) => ({ ...acc, ["i".concat(++pos + 1)]: v }), {}),
      min: output(unit, min),
    };
  }

  if (type === "grid") {
    const columns = ms.length;
    const [, ratio] = ms;
    const rows = Math.round(cols / ratio);
    const cells = (dim) =>
          Array(dim)
          .fill(0)
          .map((x, pos) => ++x + pos)
          .reduce((acc, v) => ({ ...acc, [-v]: -v, [v]: v }), {});

    return {
      columns,
      rows,
      col: cells(columns),
      row: cells(rows),
    };
  }

  const [base, x, d] = bidirectional(ms);

  return {
    base: output(unit, base),
    ...x
      .map((v) => output(unit, v))
      .reduce((acc, v, pos) => ({ ...acc, ["x".concat(++pos + 1)]: v }), {}),
    ...d
      .map((v) => output(inversion, v))
      .reduce((acc, v, pos) => ({ ...acc, ["d".concat(++pos + 1)]: v }), {}),
  };
}
#+END_SRC
