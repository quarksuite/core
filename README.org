#+TITLE: Quarks System Core (QSC)
#+AUTHOR: Chatman R. Jr
#+DATE: <2021-02-23 Tue>
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:deno :results output none
#+PROPERTY: header-args:shell :results output code

* Intro :noexport:

This repository is part of a toolkit for creating, assembling, and distributing design
systems. The whole kit lives under the umbrella of the QuarkSuite name.

Other appendages of QuarkSuite include:

+ Quarks System Language (QSL): A domain-specific language for codifying design language into design systems
+ Quarks System User Interface (QSUI): A UI kit for design system documentation and visual development
+ Quarks System Development Environment (QSDE): A complete development environment integrating all
  the above and some extras

If you're interested in how this project evolved, feel free to [[https://github.com/quarksuite/legacy][browse the repository for QuarkSuite 1]].

* Summary :noexport:

The Quarks System Core is the oldest and most mature part of QuarkSuite. It's been refined from
QuarkSuite 1 to serve as an engine powering the rest of the kit.

That said, it can still be used as a standalone library if your needs are simple, you require
absolute control, or you want to develop your own design system workflow with a QSC foundation.

* Installation :noexport:
* Features :noexport:
* Source Code Index                                                   :TOC@4:
- [[#api][API]]
  - [[#how-to-read-the-api][How to Read the API]]
  - [[#utilities-utilitiesindexjs][Utilities (=utilities/index.js=)]]
    - [[#compose-utilitiescomposejs][compose (=utilities/compose.js=)]]
    - [[#pipe-utilitiespipejs][pipe (=utilities/pipe.js=)]]
    - [[#bind-utilitiesbindjs][bind (=utilities/bind.js=)]]
    - [[#tests][Tests]]
      - [[#utilities-assertions][Utilities Assertions]]
      - [[#utilities-results][Utilities Results]]
    - [[#scenarios][Scenarios]]
  - [[#color-colorindexjs][Color (=color/index.js=)]]
    - [[#format-conversion-colorconversionindexjs][Format Conversion (=color/conversion/index.js=)]]
      - [[#hex-colorconversionhexjs][hex (=color/conversion/hex.js=)]]
      - [[#rgb-colorconversionrgbjs][rgb (=color/conversion/rgb.js=)]]
      - [[#hsl-colorconversionhsljs][hsl (=color/conversion/hsl.js=)]]
      - [[#cmyk-colorconversiondevice-cmykjs][cmyk (=color/conversion/device-cmyk.js=)]]
      - [[#hwb-colorconversionhwbjs][hwb (=color/conversion/hwb.js=)]]
      - [[#lab-colorconversionlabjs][lab (=color/conversion/lab.js=)]]
      - [[#lch-colorconversionlchjs][lch (=color/conversion/lch.js=)]]
      - [[#tests-1][Tests]]
    - [[#properties-adjustment-coloradjustindexjs][Properties Adjustment (=color/adjust/index.js=)]]
      - [[#hue-coloradjusthuejs][hue (=color/adjust/hue.js=)]]
      - [[#saturation-coloradjustsaturationjs][saturation (=color/adjust/saturation.js=)]]
      - [[#lightness-coloradjustlightnessjs][lightness (=color/adjust/lightness.js=)]]
      - [[#alpha-coloradjustalphajs][alpha (=color/adjust/alpha.js=)]]
      - [[#tests-2][Tests]]
    - [[#mixing-colormixindexjs][Mixing (=color/mix/index.js=)]]
      - [[#mix][mix]]
      - [[#tests-3][Tests]]
    - [[#scheme-generation-colorschemeindexjs][Scheme Generation (=color/scheme/index.js=)]]
      - [[#complementary-colorschemecomplementaryjs][complementary (=color/scheme/complementary.js=)]]
      - [[#analogous-colorschemeanalogousjs][analogous (=color/scheme/analogous.js=)]]
      - [[#splitcomplementary-colorschemesplitjs][splitComplementary (=color/scheme/split.js=)]]
      - [[#triadic-colorschemetriadicjs][triadic (=color/scheme/triadic.js=)]]
      - [[#tetradic-colorschemetetradicjs][tetradic (=color/scheme/tetradic.js=)]]
      - [[#square-colorschemesquarejs][square (=color/scheme/square.js=)]]
      - [[#scheme-colorschemecustomjs][scheme (=color/scheme/custom.js=)]]
      - [[#tests-4][Tests]]
    - [[#palette-creation-colorpaletteindexjs][Palette Creation (=color/palette/index.js=)]]
      - [[#tints-colorpalettetintsjs][tints (=color/palette/tints.js=)]]
      - [[#tones-colorpalettetonesjs][tones (=color/palette/tones.js=)]]
      - [[#shades-colorpaletteshadesjs][shades (=color/palette/shades.js=)]]
      - [[#tests-5][Tests]]
    - [[#accessibility-colora11yindexjs][Accessibility (=color/a11y/index.js=)]]
      - [[#clrs][clrs]]
      - [[#contrast][contrast]]
      - [[#tests-6][Tests]]
  - [[#typography-typographyindexjs][Typography (=typography/index.js=)]]
    - [[#systemfonts][systemfonts]]
    - [[#tests-7][Tests]]
      - [[#typography-assertions][Typography Assertions]]
      - [[#typography-results][Typography Results]]
  - [[#modular-scale-scaleindexjs][Modular Scale (=scale/index.js=)]]
    - [[#create][create]]
    - [[#update][update]]
    - [[#merge][merge]]
    - [[#chunk][chunk]]
    - [[#units][units]]
    - [[#tests-8][Tests]]
      - [[#modular-scale-assertions][Modular Scale Assertions]]
      - [[#modular-scale-results][Modular Scale Results]]
- [[#internals][Internals]]
  - [[#error-handling-internalserrorjs][Error Handling (=internals/error.js=)]]
  - [[#color][Color]]
    - [[#formats-internalscolorformatindexjs][Formats (=internals/color/format/index.js=)]]
      - [[#rgb-hex-internalscolorformathexjs][RGB Hex (=internals/color/format/hex.js=)]]
      - [[#w3c-x11-internalscolorformatnamedjs][W3C-X11 (=internals/color/format/named.js=)]]
      - [[#functional-rgb-internalscolorformatrgbjs][Functional RGB (=internals/color/format/rgb.js=)]]
      - [[#functional-hsl-internalscolorformathsljs][Functional HSL (=internals/color/format/hsl.js=)]]
      - [[#device-cmyk-internalscolorformatdevice-cmykjs][Device CMYK (=internals/color/format/device-cmyk.js=)]]
      - [[#functional-hwb-internalscolorformathwbjs][Functional HWB (=internals/color/format/hwb.js=)]]
      - [[#functional-cie-lab-internalscolorformatlabjs][Functional CIE Lab (=internals/color/format/lab.js=)]]
      - [[#functional-cie-lch-internalscolorformatlchjs][Functional CIE LCH (=internals/color/format/lch.js=)]]
    - [[#conversion-internalscolorconvertindexjs][Conversion (=internals/color/convert/index.js=)]]
      - [[#setup-internalscolorconvertsetupjs][Setup (=internals/color/convert/setup.js=)]]
      - [[#rgb-hex-conversion-internalscolorconverthexjs][RGB Hex Conversion (=internals/color/convert/hex.js=)]]
      - [[#w3c-x11-conversion-internalscolorconvertnamedjs][W3C-X11 Conversion (=internals/color/convert/named.js=)]]
      - [[#functional-rgb-conversion-internalscolorconvertrgbjs][Functional RGB Conversion (=internals/color/convert/rgb.js=)]]
      - [[#functional-hsl-conversion-internalscolorconverthsljs][Functional HSL Conversion (=internals/color/convert/hsl.js=)]]
      - [[#device-cmyk-conversion-internalscolorconvertdevice-cmykjs][Device CMYK Conversion (=internals/color/convert/device-cmyk.js=)]]
      - [[#functional-hwb-conversion-internalscolorconverthwbjs][Functional HWB Conversion (=internals/color/convert/hwb.js=)]]
      - [[#functional-cie-lab-conversion-internalscolorconvertlabjs][Functional CIE Lab Conversion (=internals/color/convert/lab.js=)]]
      - [[#functional-cie-lch-conversion-internalscolorconvertlchjs][Functional CIE LCH Conversion (=internals/color/convert/lch.js=)]]
- [[#data][Data]]
  - [[#color-1][Color]]
    - [[#w3c-x11-color-definitions-datacolorw3c-x11js][W3C X11 Color Definitions (=data/color/w3c-x11.js=)]]
    - [[#accesible-web-defaults-datacolora11yjs][Accesible Web Defaults (=data/color/a11y.js=)]]
  - [[#typography][Typography]]
    - [[#system-font-stacks-datatypographysystemjs][System Font Stacks (=data/typography/system.js=)]]

* API

The API is organized by the kind of data each function accepts.

This means you can jump right to the section for what you need to do. The literate style isn't for
everyone, so headings are appropriately marked with their source location in the repo if you prefer
to get right into code.

** How to Read the API

Each section is broken down into:

+ functions: the actual function definitions with developer commentary
+ Tests: proving each function does its job and doesn't choke on the unexpected

** Utilities (=utilities/index.js=)

#+BEGIN_SRC deno :tangle "./utilities/index.js" :comments link
/** Functional Utilities */
export { compose } from "./compose.js";
export { pipe } from "./pipe.js";
export { bind } from "./bind.js";
#+END_SRC

The Quarks System Core rests on a functional foundation. It uses a data-last architecture and the following
utilities are designed to take full advantage of this decision.

*** compose (=utilities/compose.js=)

+ =compose: (...operators) ==> (data) ==> unknown=
+ =operators: Array<(data: unknown) ==> unknown>=: a sequence of data operators

#+BEGIN_SRC deno :tangle "./utilities/compose.js" :comments link
import { ErrorTemplate } from "../internals/error.js";

// Error handling
const isFunction = (x) => typeof x === "function";

/** Error thrown when value is not a function. */
const FuncError = (output) =>
  ErrorTemplate({
    message: "not a function",
    reason: `
This error indicates that one or more of the values is not a
function, so it can't be composed.
`,
    suggestion: `
Check that every value in your composition chain is a function.
`,
    output,
  });

/**
 * A higher order function that accepts a sequence of data operators and combines them
 * into a new function waiting for data.
 *
 * @example Splitting a string after upcasing it.
 *
 * ```ts
 *  const upper = (data) => data.toUpperCase();
 *  const split = (data) => data.split("");
 *
 *  const splitCapitalLetters = compose(upper, split);
 *
 *  splitCapitalLetters("hello"); // ["H", "E", "L", "L", "O"]
 * ```
 *
 * @remark
 * A data operator is also called a unary function. These are both ways of saying a function
 * takes a single argument.
 *
 * @param {((data: unknown) => unknown)[]} operators - a sequence of functions to combine
 * @returns {(data: unknown) => unknown} the composed function waiting for data  */
export function compose(...operators) {
  return (data) =>
    operators.reduce((value, func) => {
      if (!isFunction(func)) return FuncError(func);
      return func(value);
    }, data);
}
#+END_SRC

Two conditions must be met for compose to work:

+ all operators must be functions
+ all operations must have a signature of =(data: unknown) => unknown=

*** pipe (=utilities/pipe.js=)

+ =(data, ...operators) => unknown=
+ =data: unknown=: the data to pass through the pipeline
+ =...operators: Array<(data: unknown) => unknown>=: a sequence of data operators

#+BEGIN_SRC deno :tangle "./utilities/pipe.js" :comments link
import { compose } from "./compose.js";

/**
 * A higher order function that pipes data through a sequence of functions and
 * outputs the result.
 *
 * @example Transforming a string into an upcased array.

 * ```ts
 * const upper = (data) => data.toUpperCase();
 * const split = (data) => data.split("");
 *
 * pipe("hello", upper, split); // ["H", "E", "L", "L", "O"]
 * ```
 *
 * @remarks
 * This function simply inverts `compose` so that the data is immediately transformed
 * instead of combining the functions.
 *
 * @param {unknown} data - the data to pass through the pipeline
 * @param {((data: unknown) => unknown)[]} operators - the sequence of functions to transform data
 * @returns {unknown} The transformed data
 */
export function pipe(data, ...operators) {
  return compose(...operators)(data);
}
#+END_SRC

=pipe= inverts the relationship between data and its operators. This is crucial: data pipelines,
because of the way they're defined can /themselves/ be bound. Data, rather than being the remaining
argument, becomes the /initial/ argument and its operators can be applied freely after.

As you can see, it's a reimplementation of =compose= but with the data as the initial argument and
immediately executes on call.

*** bind (=utilities/bind.js=)

+ =(func, ...initial) => (...remaining) => unknown=
+ =func: (...args: unknown) => unknown=: the function to initialize
+ =initial: unknown[]=: the initial arguments to bind

#+BEGIN_SRC deno :tangle "./utilities/bind.js" :comments link
/**
 * A higher order function that accepts a function and some of its arguments;
 * returning a function waiting for the rest of its arguments.
 *
 * @example Binding add to add8
 *
 * ```ts
 * const add = (y, x) => x + y;
 * const add8 = bind(add, 8);
 *
 * add8(2) // 10
 * ```
 *
 * @remarks
 * `bind` is essential for converting complex utilities into preset data
 * operators which can then be `compose`d and `pipe`d.
 *
 * Additionally, you can chain bind to approximate a full curry of a function:
 * `(z, y, x) => unknown` to `(z) => (y) => (x) => unknown`
 *
 * @param {(...args: unknown[]) => unknown} func - a variadic function to initialize
 * @param {unknown[]} initial - the arguments to apply
 * @returns {((...remaining: unknown) => unknown) | unknown} A function waiing for remaining arguments or the result of calling the function if `initial = total arguments`  */
export function bind(func, ...initial) {
  return func.length === initial.length
    ? func(...initial)
    : (...remaining) => func(...initial, ...remaining);
}
#+END_SRC

Composition and data piping work out of the box for simple unary functions, but what about
functions with more than one argument?

In a data-last architecture, the final argument of a function is /always/ its data.

Any preceding arguments are *data modifiers*.

Using the =bind= utility, a function with a signature of =(z, y, x) => any= will break down to: =(z,
y) => (x) => any= or =(z) => (y) => (x) => any=.

The remaining data operation satisfies the =arity = 1= clause for composition.

*** Tests

**** Utilities Assertions

#+BEGIN_SRC deno :tangle "./utilities/index_test.js" :comments link
import { bind, compose, pipe } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const isString = (x) => typeof x === "string";
const isArray = (x) => Array.isArray(x);

const upper = (x) => isString(x) && x.toUpperCase();
const lower = (x) => isString(x) && x.toLowerCase();

const trim = (x) => isString(x) && x.trim();

const split = (x) => isString(x) && x.split("");

const box = (x) => [x];
const unbox = (x) => isArray(x) && x.toString();

Deno.test("SPEC compose: combines two data operators", function () {
  const splitSafe = compose(split, unbox);
    assertEquals(splitSafe("hello"), "h,e,l,l,o");
});

Deno.test("SPEC compose: can combine a chain of data operators", function () {
  const upperSplitSafe = compose(trim, upper, split);
  assertEquals(upperSplitSafe("   hello      "), ["H", "E", "L", "L", "O"]);
});

Deno.test("EDGE compose: rejects values that are not functions", function () {
  const failsFuncClause = compose(split, 5);
  assertThrows(
    () => {
      throw failsFuncClause("hello");
    },
    undefined,
    "not a function",
  );
});

Deno.test("SPEC pipe: can transform data", function () {
  assertEquals(pipe("hello", upper), "HELLO");
});

Deno.test("SPEC pipe: can chain operators", function () {
  assertEquals(
    pipe(
      "hello",
      split,
      (x) => x.map((xs) => xs.charCodeAt(0)),
      (x) => x.map((xs) => xs + 16),
      (x) => x.map((xs) => String.fromCharCode(xs)),
      (x) => x.join(""),
    ),
    "xu||\x7f",
  );
});

const splitWith = (delimiter, x) => isString(x) && x.split(delimiter);
const filterAs = (condition, x) => isArray(x) && x.filter(condition);
const map = (transform, x) => box(x).map(transform);

const normalize = (b, a, x) => Math.round(Math.min(Math.max(x, a), b));

Deno.test("SPEC bind: can initialize arguments and wait for remaining", function () {
  const filterEven = bind(filterAs, (x) => x % 2 === 0);
  assertEquals(filterEven([1, 2, 3, 4, 5, 6, 7, 8, 9]), [2, 4, 6, 8]);
});

Deno.test("SPEC bind: initialize arguments in sequence for a full curry", function () {
  const limit = bind(normalize, 240);
  const threshold = bind(limit, 160);
  assertEquals(threshold(320), 240);
});

Deno.test("SPEC bind: when initial arguments match function arity, simply execute", function () {
  const boundMap = bind(map, (x, i) => `mapped ${x} at ${i}`, [
    ...Array(8).fill("hi"),
  ]);
  const standardMap = map((x, i) => `mapped ${x} at ${i}`, [
    ...Array(8).fill("hi"),
  ]);
  assertEquals(boundMap, standardMap);
});
#+END_SRC

**** Utilities Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./utilities/index_test.js)
#+END_SRC

#+NAME: utilities-test
#+begin_src shell
running 8 tests
test SPEC compose: combines two data operators ... ok (8ms)
test SPEC compose: can combine a chain of data operators ... ok (2ms)
test EDGE compose: rejects values that are not functions ... ok (4ms)
test SPEC pipe: can transform data ... ok (3ms)
test SPEC pipe: can chain operators ... ok (13ms)
test SPEC bind: can initialize arguments and wait for remaining ... ok (3ms)
test SPEC bind: initialize arguments in sequence for a full curry ... ok (1ms)
test SPEC bind: when initial arguments match function arity, simply execute ... ok (2ms)

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (46ms)

#+end_src

*** Scenarios

** Color (=color/index.js=)

Quarks System Core is designed to work with all valid CSS color formats (current and future). The
color module provides utilities for conversion, modification, mixing, generating schemes, and
creating palettes.

#+BEGIN_SRC deno :tangle "./color/index.js" :comments link
/** Public color utilities */
export * from "./conversion/index.js";
export * from "./adjust/index.js";
export * from "./mix/index.js";
export * from "./scheme/index.js";
export * from "./palette/index.js";
export * from "./a11y/index.js";
#+END_SRC

*** Format Conversion (=color/conversion/index.js=)

The public conversion API is designed to abstract the internal =inputFormat.outputFormat= conversion
utilities into a simple =outputFormat:: inputColor -> outputColor= conversion.

For example: =hex("rgb(255, 0, 0)")= will yield =#ff0000=.

Each utility checks the validity of the input color before doing anything with it, and will throw a
helpful error message if something goes wrong.

#+BEGIN_SRC deno :tangle "./color/conversion/index.js" :comments link
/** Public color conversion utilities */
export { hex } from "./hex.js";
export { rgb } from "./rgb.js";
export { hsl } from "./hsl.js";
export { cmyk } from "./device-cmyk.js";
export { hwb } from "./hwb.js";
export { lab } from "./lab.js";
export { lch } from "./lch.js";
#+END_SRC

To streamline the conversion process and make it easier to add future formats, Quarks System Core
provides a collection of conversion pipelines for each format.

#+BEGIN_SRC deno :tangle "./color/conversion/setup.js" :comments link
import * as format from "../../internals/color/format/index.js";
import * as convert from "../../internals/color/convert/index.js";
import { ErrorTemplate } from "../../internals/error.js";
import { pipe } from "../../utilities/pipe.js";

const ColorError = (output) =>
  ErrorTemplate({
    message: "not a valid CSS color format",
    reason: `
This error indicates that the input for conversion is not actually a color.
`,
    suggestion: `
Ensure that the input is a valid CSS color.

Examples:

#deaded
#bea
#face
#abcdef68

aliceblue
rebeccapurple

rgb(110, 33, 229)
rgba(139, 110, 19, 0.5)

hsl(300, 89%, 38%)
hsla(3.4rad, 100%, 25%, 0.99)

device-cmyk(0 1 1 0)
device-cmyk(78% 39% 0 0)

hwb(190 39% 3%)

lab(64% 19 -47)

lch(38% 78 147)
`,
    output,
  });

const parseColor = (color, input, ...conversionChain) =>
  input.validate(color) && pipe(color, input.extract, ...conversionChain);

const parseNamedColor = (color, chain = false, ...conversionChain) =>
  format.named.validate(color) && chain
    ? pipe(color, convert.named.hex, format.hex.extract, ...conversionChain)
    : pipe(color, convert.named.hex);

const parseSelf = (color, input) => input.validate(color) && color;

// Possible RGB hex conversion chains
export const hex = (color) =>
  Object.values({
    hex: parseSelf(color, format.hex),
    named: parseNamedColor(color),
    rgb: parseColor(color, format.rgb, convert.rgb.hex),
    hsl: parseColor(
      color,
      format.hsl,
      convert.hsl.rgb,
      format.rgb.extract,
      convert.rgb.hex,
    ),
    cmyk: parseColor(
      color,
      format.cmyk,
      convert.cmyk.rgb,
      format.rgb.extract,
      convert.rgb.hex,
    ),
    hwb: parseColor(
      color,
      format.hwb,
      convert.hwb.rgb,
      format.rgb.extract,
      convert.rgb.hex,
    ),
    lab: parseColor(
      color,
      format.lab,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.hex,
    ),
    lch: parseColor(
      color,
      format.lch,
      convert.lch.lab,
      format.lab.extract,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.hex,
    ),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);

// Possible RGB conversion chains
export const rgb = (color) =>
  Object.values({
    hex: parseColor(color, format.hex, convert.hex.rgb),
    named: parseNamedColor(color, true, convert.hex.rgb),
    rgb: parseSelf(color, format.rgb),
    hsl: parseColor(color, format.hsl, convert.hsl.rgb),
    cmyk: parseColor(color, format.cmyk, convert.cmyk.rgb),
    hwb: parseColor(color, format.hwb, convert.hwb.rgb),
    lab: parseColor(color, format.lab, convert.lab.rgb),
    lch: parseColor(
      color,
      format.lch,
      convert.lch.lab,
      format.lab.extract,
      convert.lab.rgb,
    ),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);

// Possible HSL conversion chains
export const hsl = (color) =>
  Object.values({
    hex: parseColor(
      color,
      format.hex,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.hsl,
    ),
    named: parseNamedColor(
      color,
      true,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.hsl,
    ),
    rgb: parseColor(color, format.rgb, convert.rgb.hsl),
    hsl: parseSelf(color, format.hsl),
    cmyk: parseColor(
      color,
      format.cmyk,
      convert.cmyk.rgb,
      format.rgb.extract,
      convert.rgb.hsl,
    ),
    hwb: parseColor(
      color,
      format.hwb,
      convert.hwb.rgb,
      format.rgb.extract,
      convert.rgb.hsl,
    ),
    lab: parseColor(
      color,
      format.lab,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.hsl,
    ),
    lch: parseColor(
      color,
      format.lch,
      convert.lch.lab,
      format.lab.extract,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.hsl,
    ),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);

// Possible CMYK conversion chains
export const cmyk = (color) =>
  Object.values({
    hex: parseColor(
      color,
      format.hex,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.cmyk,
    ),
    named: parseNamedColor(
      color,
      true,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.cmyk,
    ),
    rgb: parseColor(color, format.rgb, convert.rgb.cmyk),
    hsl: parseColor(
      color,
      format.hsl,
      convert.hsl.rgb,
      format.rgb.extract,
      convert.rgb.cmyk,
    ),
    cmyk: parseSelf(color, format.cmyk),
    hwb: parseColor(
      color,
      format.hwb,
      convert.hwb.rgb,
      format.rgb.extract,
      convert.rgb.cmyk,
    ),
    lab: parseColor(
      color,
      format.lab,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.cmyk,
    ),
    lch: parseColor(
      color,
      format.lch,
      convert.lch.lab,
      format.lab.extract,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.cmyk,
    ),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);

// Possible HWB conversion chains
export const hwb = (color) =>
  Object.values({
    hex: parseColor(
      color,
      format.hex,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.hwb,
    ),
    named: parseNamedColor(
      color,
      true,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.hwb,
    ),
    rgb: parseColor(color, format.rgb, convert.rgb.hwb),
    hsl: parseColor(
      color,
      format.hsl,
      convert.hsl.rgb,
      format.rgb.extract,
      convert.rgb.hwb,
    ),
    cmyk: parseColor(
      color,
      format.cmyk,
      convert.cmyk.rgb,
      format.rgb.extract,
      convert.rgb.hwb,
    ),
    hwb: parseSelf(color, format.hwb),
    lab: parseColor(
      color,
      format.lab,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.hwb,
    ),
    lch: parseColor(
      color,
      format.lch,
      convert.lch.lab,
      format.lab.extract,
      convert.lab.rgb,
      format.rgb.extract,
      convert.rgb.hwb,
    ),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);

// Possible CIE Lab conversion chains
export const lab = (color) =>
  Object.values({
    hex: parseColor(
      color,
      format.hex,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.lab,
    ),
    named: parseNamedColor(
      color,
      true,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.lab,
    ),
    rgb: parseColor(color, format.rgb, convert.rgb.lab),
    hsl: parseColor(
      color,
      format.hsl,
      convert.hsl.rgb,
      format.rgb.extract,
      convert.rgb.lab,
    ),
    cmyk: parseColor(
      color,
      format.cmyk,
      convert.cmyk.rgb,
      format.rgb.extract,
      convert.rgb.lab,
    ),
    hwb: parseColor(
      color,
      format.hwb,
      convert.hwb.rgb,
      format.rgb.extract,
      convert.rgb.lab,
    ),
    lab: parseSelf(color, format.lab),
    lch: parseColor(color, format.lch, convert.lch.lab),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);

// Possible CIE LCH conversion chains
export const lch = (color) =>
  Object.values({
    hex: parseColor(
      color,
      format.hex,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.lab,
      format.lab.extract,
      convert.lab.lch,
    ),
    named: parseNamedColor(
      color,
      true,
      convert.hex.rgb,
      format.rgb.extract,
      convert.rgb.lab,
      format.lab.extract,
      convert.lab.lch,
    ),
    rgb: parseColor(
      color,
      format.rgb,
      convert.rgb.lab,
      format.lab.extract,
      convert.lab.lch,
    ),
    hsl: parseColor(
      color,
      format.hsl,
      convert.hsl.rgb,
      format.rgb.extract,
      convert.rgb.lab,
      format.lab.extract,
      convert.lab.lch,
    ),
    cmyk: parseColor(
      color,
      format.cmyk,
      convert.cmyk.rgb,
      format.rgb.extract,
      convert.rgb.lab,
      format.lab.extract,
      convert.lab.lch,
    ),
    hwb: parseColor(
      color,
      format.hwb,
      convert.hwb.rgb,
      format.rgb.extract,
      convert.rgb.lab,
      format.lab.extract,
      convert.lab.lch,
    ),
    lab: parseColor(color, format.lab, convert.lab.lch),
    lch: parseSelf(color, format.lch),
  })
    .filter((found) => !!found)
    .toString() || ColorError(color);
#+END_SRC

I'll be using these conversion trees to allow target formats to consume any input format.

**** hex (=color/conversion/hex.js=)

+ =hex: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/hex.js" :comments link
import { hex as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to RGB hex.
 *
 * @example Converting RGB to RGB Hex
 *
 * ```ts
 * hex("rgb(0, 0, 0)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to RGB hex
 */
export const hex = (color) => target(color);
#+END_SRC

**** rgb (=color/conversion/rgb.js=)

+ =rgb: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/rgb.js" :comments link
import { rgb as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to RGB.
 *
 * @example Converting RGB Hex to RGB
 *
 * ```ts
 * rgb("#deaded");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to RGB
 */
export const rgb = (color) => target(color);
#+END_SRC

**** hsl (=color/conversion/hsl.js=)

+ =hsl: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/hsl.js" :comments link
import { hsl as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to HSL.
 *
 * @example Converting Device CMYK to HSL
 *
 * ```ts
 * hsl("device-cmyk(30% 0 60% 0)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to HSL
 */
export const hsl = (color) => target(color);
#+END_SRC

**** cmyk (=color/conversion/device-cmyk.js=)

+ =cmyk: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/device-cmyk.js" :comments link
import { cmyk as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to CMYK
 *
 * @example Converting HSL to Device CMYK
 *
 * ```ts
 * cmyk("hsl(97, 63%, 81%)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to CMYK
 */
export const cmyk = (color) => target(color);
#+END_SRC

**** hwb (=color/conversion/hwb.js=)

+ =hwb: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/hwb.js" :comments link
import { hwb as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to HWB.
 *
 * @example Converting CIELCH to HWB
 *
 * ```ts
 * hwb("lch(78.31% 83 210)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to HWB
 */
export const hwb = (color) => target(color);
#+END_SRC

**** lab (=color/conversion/lab.js=)

+ =lab: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/lab.js" :comments link
import { lab as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to CIE Lab.
 *
 * @example Convert HWB to CIELAB
 *
 * ```ts
 * lab("hwb(90 25% 10%)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to CIE Lab
 */
export const lab = (color) => target(color);
#+END_SRC

**** lch (=color/conversion/lch.js=)

+ =lch: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC deno :tangle "./color/conversion/lch.js" :comments link
import { lch as target } from "./setup.js";

/**
 * A function that converts any valid CSS color to CIE LCH.
 *
 * @example Convert CIELCH to RGB Hex
 *
 * ```ts
 * lch("#face");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to CIE LCH
 */
export const lch = (color) => target(color);
#+END_SRC

**** Tests

Catching color errors before they show up in someone else's interface is crucial because *color is
hard*.

Since I've included extensive conversion examples in the internal conversion documentation, I'll be
plugging some values to test the conversion chaining and error reporting here.

***** Color Format Conversion Assertions

#+BEGIN_SRC deno :tangle "./color/conversion/index_test.js" :comments link
import { cmyk, hex, hsl, hwb, lab, lch, rgb } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const conversions = { hex, rgb, hsl, cmyk, hwb, lab, lch };

const samples = {
  hex: "#348ec9",
  rgb: "rgb(30, 119, 200)",
  hsl: "hsl(300, 78%, 69%)",
  cmyk: "device-cmyk(49% 2% 10% 0%)",
  hwb: "hwb(145 30% 5%)",
  lab: "lab(43.319% -42 -8)",
  lch: "lch(85.19% 73.81 67.142)",
};

const colors = [
  "midnightblue",
  "gainsboro",
  "cornsilk",
  "crimson",
  "springgreen",
  "rebeccapurple",
];

colors.forEach((color) => {
  Object.entries(conversions).forEach(([format, fn]) =>
    Deno.test(
      `SPEC try ${color} ${format.toUpperCase()}: "${fn(color)}"`,
      function () {
        assertEquals(fn(color), fn(color));
      },
    )
  );
});

Deno.test(
  `EDGE: does nothing when input is the same format as target conversion`,
  function () {
    Object.entries(conversions).forEach(([format, fn]) =>
      assertEquals(fn(samples[format]), samples[format])
    );
  },
);

Deno.test(`EDGE: rejects invalid or unsupported color formats`, function () {
  Object.values(conversions).forEach((fn) =>
    assertThrows(
      () => {
        throw fn("invalid");
      },
      undefined,
      "not a valid CSS color",
    )
  );
});
#+END_SRC

***** Color Format Conversion Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./color/conversion/index_test.js)
#+END_SRC

#+NAME: conversion-test
#+begin_src shell
running 44 tests
test SPEC try midnightblue HEX: "#191970" ... ok (5ms)
test SPEC try midnightblue RGB: "rgb(25, 25, 112)" ... ok (2ms)
test SPEC try midnightblue HSL: "hsl(240, 63.504%, 26.863%)" ... ok (2ms)
test SPEC try midnightblue CMYK: "device-cmyk(77.679% 77.679% 0% 56.078%)" ... ok (3ms)
test SPEC try midnightblue HWB: "hwb(240 9.8039% 56.078%)" ... ok (2ms)
test SPEC try midnightblue LAB: "lab(14.928% 25.96 -50.904)" ... ok (1ms)
test SPEC try midnightblue LCH: "lch(14.928% 57.141 297.021)" ... ok (2ms)
test SPEC try gainsboro HEX: "#dcdcdc" ... ok (2ms)
test SPEC try gainsboro RGB: "rgb(220, 220, 220)" ... ok (2ms)
test SPEC try gainsboro HSL: "hsl(0, 0%, 86.275%)" ... ok (2ms)
test SPEC try gainsboro CMYK: "device-cmyk(0% 0% 0% 13.726%)" ... ok (2ms)
test SPEC try gainsboro HWB: "hwb(0 86.275% 13.726%)" ... ok (2ms)
test SPEC try gainsboro LAB: "lab(87.761% 0 0)" ... ok (3ms)
test SPEC try gainsboro LCH: "lch(87.761% 0 0)" ... ok (1ms)
test SPEC try cornsilk HEX: "#fff8dc" ... ok (2ms)
test SPEC try cornsilk RGB: "rgb(255, 248, 220)" ... ok (2ms)
test SPEC try cornsilk HSL: "hsl(48, 100%, 93.137%)" ... ok (1ms)
test SPEC try cornsilk CMYK: "device-cmyk(0% 2.7451% 13.726% 0%)" ... ok (2ms)
test SPEC try cornsilk HWB: "hwb(48 86.275% 0%)" ... ok (1ms)
test SPEC try cornsilk LAB: "lab(97.584% -0.95546 14.387)" ... ok (2ms)
test SPEC try cornsilk LCH: "lch(97.584% 14.419 93.8)" ... ok (2ms)
test SPEC try crimson HEX: "#dc143c" ... ok (2ms)
test SPEC try crimson RGB: "rgb(220, 20, 60)" ... ok (2ms)
test SPEC try crimson HSL: "hsl(348, 83.333%, 47.059%)" ... ok (3ms)
test SPEC try crimson CMYK: "device-cmyk(0% 90.909% 72.727% 13.726%)" ... ok (2ms)
test SPEC try crimson HWB: "hwb(348 7.8431% 13.726%)" ... ok (2ms)
test SPEC try crimson LAB: "lab(47.88% 71.283 35.481)" ... ok (2ms)
test SPEC try crimson LCH: "lch(47.88% 79.625 26.462)" ... ok (1ms)
test SPEC try springgreen HEX: "#00ff7f" ... ok (2ms)
test SPEC try springgreen RGB: "rgb(0, 255, 127)" ... ok (1ms)
test SPEC try springgreen HSL: "hsl(150, 100%, 50%)" ... ok (2ms)
test SPEC try springgreen CMYK: "device-cmyk(100% 0% 50.196% 0%)" ... ok (2ms)
test SPEC try springgreen HWB: "hwb(150 0% 0%)" ... ok (1ms)
test SPEC try springgreen LAB: "lab(88.435% -72.513 45.975)" ... ok (2ms)
test SPEC try springgreen LCH: "lch(88.435% 85.859 147.62)" ... ok (2ms)
test SPEC try rebeccapurple HEX: "#663399" ... ok (2ms)
test SPEC try rebeccapurple RGB: "rgb(102, 51, 153)" ... ok (2ms)
test SPEC try rebeccapurple HSL: "hsl(270, 50%, 40%)" ... ok (3ms)
test SPEC try rebeccapurple CMYK: "device-cmyk(33.333% 66.667% 0% 40%)" ... ok (2ms)
test SPEC try rebeccapurple HWB: "hwb(270 20% 40%)" ... ok (3ms)
test SPEC try rebeccapurple LAB: "lab(32.393% 38.428 -47.69)" ... ok (3ms)
test SPEC try rebeccapurple LCH: "lch(32.393% 61.246 308.861)" ... ok (2ms)
test EDGE: does nothing when input is the same format as target conversion ... ok (3ms)
test EDGE: rejects invalid or unsupported color formats ... ok (4ms)

test result: ok. 44 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (97ms)

#+end_src

*** Properties Adjustment (=color/adjust/index.js=)

After ensuring that color conversion is rock solid, the possibilities for adjustment open up. The
main ways to adjust a color include:

+ Hue: the perceptual identity of a color. Hue is the way we perceive a color. The qualitative
  difference between red and cyan.
+ Saturation/Chroma: the given amount of a color. Saturation represents color /intensity/.
+ Lightness/Luminance: the amount of light a color reflects or absorbs. An indication of whether a
  a color is pure, a shade, or  a tint/pastel.
+ Alpha/Transparency: the opacity of a color. Whether a color is solid or lets light through.

Many ways exist to change these qualities, but Quarks System Core explicitly does it from the HSL(A)
color space for both ease of calculation and convention.

#+BEGIN_SRC deno :tangle "./color/adjust/index.js" :comments link
/** Color adjustment utilities */
export { h, hue } from "./hue.js";
export { s, sat, saturation } from "./saturation.js";
export { l, lightness, luminance } from "./lightness.js";
export { a, alpha, transparency } from "./alpha.js";
#+END_SRC

I also want to be able to preserve the input format of a color after adjustment so /you/ won't have to
think about it when you use these functions.

#+BEGIN_SRC deno :tangle "./color/adjust/setup.js" :comments link
import * as format from "../../internals/color/format/index.js";
import * as revert from "../conversion/index.js";

// Secondary format validation
export const preserve = (target, color) =>
  Object.values({
    hex: format.hex.validate(color) && revert.hex(target),
    named: format.named.validate(color) && revert.hex(target),
    rgb: format.rgb.validate(color) && revert.rgb(target),
    hsl: format.hsl.validate(color) && revert.hsl(target),
    cmyk: format.cmyk.validate(color) && revert.cmyk(target),
    hwb: format.hwb.validate(color) && revert.hwb(target),
    lab: format.lab.validate(color) && revert.lab(target),
    lch: format.lch.validate(color) && revert.lch(target),
  })
    .filter((matched) => !!matched)
    .toString();
#+END_SRC

The simple method performs a /secondary/ color validation for the input and passes the resulting HSL
color after adjustment along to its conversion function.

**** hue (=color/adjust/hue.js=)

+ =hue/h: (offset: number, color: string) => string=
+ =offset: number=: the rotational offset from current hue (positive or negative)
+ =color: string=: the color to adjust

Each of the adjustment functions follow a similar pattern. First the input color is converted to
HSL(A), and then its values are extracted. Finally, the relevant property is changed, and the color
is reverted to its input format.

#+BEGIN_SRC deno :tangle "./color/adjust/hue.js" :comments link
import { extract } from "../../internals/color/format/hsl.js";
import {
  correctHueClockwise,
  correctHueCounterClockwise,
} from "../../internals/color/convert/setup.js";
import { hsl } from "../conversion/hsl.js";
import { preserve } from "./setup.js";
import { pipe } from "../../utilities/pipe.js";

/**
 * A function that allows hue adjustment of any valid CSS color.
 *
 * @example Positive values adjust clockwise
 *
 * ```ts
 * hue(30, "red");
 * ```
 *
 * @example Negative values adjust counterclockwise
 *
 * ```ts
 * // negative vallues adjust counterclockwise
 * hue(-45, "lime");
 * ```
 *
 * @remarks
 * The hue is bound to one full revolution (360Â°) and automatically
 * corrects an adjustment value to the expected output if out of range.
 *
 * It corrects clockwise if value after calculation is < 0;
 * counterclockwise if value after calculation is > 360.
 *
 * @param {number} offset - the rotational offset from current hue
 * @param {string} color - the color to adjust
 * @returns {string} The adjusted color
 */
export function hue(offset, color) {
  const [h, S, L, alpha] = pipe(color, hsl, extract);
  const hue = parseFloat(h) + offset;

  // Hue correction
  let H;
  if (hue > 360) {
    H = correctHueClockwise(hue);
  } else if (Math.sign(hue) === -1) {
    H = pipe(hue, correctHueClockwise, correctHueCounterClockwise);
  } else {
    H = hue;
  }

  const A = (alpha && (alpha ?? 1)) || 1;

  return preserve(
    A === 1 ? `hsl(${H}, ${S}, ${L})` : `hsla(${H}, ${S}, ${L}, ${A})`,
    color,
  );
}

/** Shorthand for `hue()` */
export const h = hue;
#+END_SRC

I added a hue correction step so that any adjustment values are acceptable.

**** saturation (=color/adjust/saturation.js=)

+ =saturation/sat/s: (amount: number, color: string) => string=
+ =amount: number=: the amount to adjust saturation (as a percentage)
+ =color: string=: the color to adjust

Saturation and lightness are bound by a linear range of  =0-100=.

#+BEGIN_SRC deno :tangle "./color/adjust/saturation.js" :comments link
import { extract } from "../../internals/color/format/hsl.js";
import { normalize } from "../../internals/color/convert/setup.js";
import { hsl } from "../conversion/hsl.js";
import { preserve } from "./setup.js";
import { pipe } from "../../utilities/pipe.js";

/**
 * A function that allows saturation adjustment of any valid CSS color.
 *
 * @example Positive values increase
 *
 * ```ts
 * saturation(15, "red");
 * ```
 *
 * @example Negative values decrease
 *
 * ```ts
 * saturation(-30, "lime");
 * ```
 *
 * @remarks
 * As a percentage value, amount is locked to a range of 0-100%. If
 * the calculation would yield a value out of bounds, the minimum or
 * maximum is returned.
 *
 * At 0%, a color is achromatic (gray). At 100%, a color is fully saturated.
 *
 * @param {number} amount - the amount to adjust saturation (as a percentage)
 * @param {string} color - the color to adjust
 * @returns {string} The adjusted color
 */
export function saturation(amount, color) {
  const [H, s, L, alpha] = pipe(color, hsl, extract);

  const S = `${normalize(0, parseFloat(s) + amount, 100)}%`;
  const A = (alpha && (alpha ?? 1)) || 1;

  return preserve(
    A === 1 ? `hsl(${H}, ${S}, ${L})` : `hsla(${H}, ${S}, ${L}, ${A})`,
    color,
  );
}

/** An alias for `saturation()` */
export const sat = saturation;

/** Shorthand for `saturation()` */
export const s = saturation;
#+END_SRC

**** lightness (=color/adjust/lightness.js=)

+ =lightness/luminance/l: (amount: number, color: string) => string=
+ =amount: number=: the amount to adjust lightness (as a percentage)
+ =color: string=: the color to adjust

#+BEGIN_SRC deno :tangle "./color/adjust/lightness.js" :comments link
import { extract } from "../../internals/color/format/hsl.js";
import { normalize } from "../../internals/color/convert/setup.js";
import { hsl } from "../conversion/hsl.js";
import { preserve } from "./setup.js";
import { pipe } from "../../utilities/pipe.js";

/**
 * A function that allows lightness/luminance adjustment of any valid CSS color.
 *
 * @example Positive values increase
 *
 * ```ts
 * lightness(15, "red");
 * ```
 *
 * @example Negative values decrease
 *
 * ```ts
 * lightness(-30, "lime");
 * ```
 *
 * @remarks
 * As a percentage value, amount is locked to a range of 0-100%. If
 * the calculation would yield a value out of bounds, the minimum or
 * maximum is returned.
 *
 * At 0%, sits pure black. At 100%, pure white.
 *
 * @param {number} amount - the amount to adjust lightness (as a percentage)
 * @param {string} color - the color to adjust
 * @returns {string} The adjusted color
 */
export function lightness(amount, color) {
  const [H, S, l, alpha] = pipe(color, hsl, extract);

  const L = `${normalize(0, parseFloat(l) + amount, 100)}%`;
  const A = (alpha && (alpha ?? 1)) || 1;

  return preserve(
    A === 1 ? `hsl(${H}, ${S}, ${L})` : `hsla(${H}, ${S}, ${L}, ${A})`,
    color,
  );
}

/** An alias for `lightness()` */
export const luminance = lightness;

/** Shorthand for `lightness()` */
export const l = lightness;
#+END_SRC

**** alpha (=color/adjust/alpha.js=)

+ =alpha/transparency/a: (amount: number, color: string) => string=
+ =amount: number=: the amount to adjust transparency (as a percentage)
+ =color: string=: the color to adjust

#+BEGIN_SRC deno :tangle "./color/adjust/alpha.js" :comments link
import { extract } from "../../internals/color/format/hsl.js";
import {
  calcFractionFromPercent,
  calcPercentFromFraction,
  normalize,
} from "../../internals/color/convert/setup.js";
import { hsl } from "../conversion/hsl.js";
import { preserve } from "./setup.js";
import { pipe } from "../../utilities/pipe.js";

/**
 * A function that allows alpha/transparency adjustment of any valid CSS color.
 *
 * @example Positive values increase
 *
 * ```ts
 * alpha(12, "rgba(255, 0, 0, 0.48)");
 * ```
 *
 * @example Negative values decrease
 *
 * ```ts
 * lightness(-30, "lime");
 * ```
 *
 * @remarks
 * As a percentage value, amount is locked to a range of 0-100%. If
 * the calculation would yield a value out of bounds, the minimum or
 * maximum is returned.
 *
 * At 0%, a color is fully transparent. At 100%, fully opaque.
 *
 * @param {number} amount - the amount to adjust transparency (as a percentage)
 * @param {string} color - the color to adjust
 * @returns {string} The adjusted color
 */
export function alpha(amount, color) {
  const [H, S, L, alpha] = pipe(color, hsl, extract);

  const A = calcFractionFromPercent(
    normalize(0, calcPercentFromFraction(alpha ?? 1) + amount, 100),
  );
  return preserve(
    A === 1 ? `hsl(${H}, ${S}, ${L})` : `hsla(${H}, ${S}, ${L}, ${A})`,
    color,
  );
}

/** An alias for `alpha()` */
export const transparency = alpha;

/** Shorthand for `alpha()` */
export const a = alpha;
#+END_SRC

**** Tests

***** Color Adjustment Assertions

#+BEGIN_SRC deno :tangle "./color/adjust/index_test.js" :comments link
import {
  a,
  alpha,
  h,
  hue,
  l,
  lightness,
  luminance,
  s,
  sat,
  saturation,
  transparency,
} from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC hue: can adjust clockwise", function () {
  const color = "red";

  assertEquals(hue(15, color), "#ff4000");
  assertEquals(hue(30, color), "#ff8000");
  assertEquals(hue(45, color), "#ffbf00");
  assertEquals(hue(60, color), "#ffff00");
  assertEquals(hue(75, color), "#bfff00");
  assertEquals(hue(90, color), "#80ff00");
});

Deno.test("SPEC hue: can adjust counterclockwise", function () {
  const color = "lime";

  assertEquals(hue(-15, color), "#40ff00");
  assertEquals(hue(-30, color), "#80ff00");
  assertEquals(hue(-45, color), "#bfff00");
  assertEquals(hue(-60, color), "#ffff00");
  assertEquals(hue(-75, color), "#ffbf00");
  assertEquals(hue(-90, color), "#ff8000");
});

Deno.test("SPEC hue: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#ffc0d1"],
    ["midnightblue", "#707019"],
    ["rgb(255, 133, 30)", "rgb(30, 154, 255)"],
    ["hsl(300, 40%, 70%)", "hsl(120, 40%, 70%)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(0% 89.804% 19.608% 0%)"],
    ["hwb(120 30% 20%)", "hwb(300 30.196% 20%)"],
    ["lab(36.44% 30 -79)", "lab(72.191% 9.656 70.685)"],
    ["lch(63.198% 36 135)", "lch(51.614% 36.568 318.756)"],
  ];

  colors.forEach(([input, target]) => assertEquals(hue(180, input), target));
});

Deno.test("EDGE hue: rejects invalid color", function () {
  assertThrows(
    () => {
      throw hue(16, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});

Deno.test("ALIAS h of hue", function () {
  assertEquals(h(33, "hwb(60 38% 0%)"), "hwb(93 38.039% 0%)");
});

Deno.test("SPEC saturation: can saturate a color", function () {
  const color = "cadetblue";

  assertEquals(saturation(4, color), "#5ba2a4");
  assertEquals(saturation(8, color), "#55a7aa");
  assertEquals(saturation(16, color), "#4bb0b4");
  assertEquals(saturation(32, color), "#37c3c8");
  assertEquals(saturation(64, color), "#0ee9f1");
});

Deno.test("SPEC saturation: can desaturate a color", function () {
  const color = "chartreuse";

  assertEquals(saturation(-4, color), "#80fa05");
  assertEquals(saturation(-8, color), "#80f50a");
  assertEquals(saturation(-16, color), "#80eb14");
  assertEquals(saturation(-32, color), "#80d629");
  assertEquals(saturation(-64, color), "#80ad52");
});

Deno.test("SPEC saturation: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#cff0e7"],
    ["midnightblue", "#3a3a4f"],
    ["rgb(255, 133, 30)", "rgb(201, 137, 84)"],
    ["hsl(300, 40%, 70%)", "hsl(300, 0%, 70%)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(59.5% 0% 46.5% 21.569%)"],
    ["hwb(120 30% 20%)", "hwb(120 51.765% 41.569%)"],
    ["lab(36.44% 30 -79)", "lab(43.941% 4.7393 -33.095)"],
    ["lch(63.198% 36 135)", "lch(56.315% 0 0)"],
  ];

  colors.forEach(([input, target]) =>
    assertEquals(saturation(-48, input), target)
  );
});

Deno.test("EDGE saturation: rejects invalid color", function () {
  assertThrows(
    () => {
      throw saturation(16, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});

Deno.test("ALIAS sat of saturation", function () {
  assertEquals(sat(-16, "chocolate"), "#bf6c31");
});

Deno.test("ALIAS s of saturation", function () {
  assertEquals(s(-8, "burlywood"), "#d8b78d");
});

Deno.test("SPEC lightness: can lighten a color", function () {
  const color = "midnightblue";

  assertEquals(lightness(4, color), "#1d1d81");
  assertEquals(lightness(8, color), "#212192");
  assertEquals(lightness(16, color), "#2828b3");
  assertEquals(lightness(32, color), "#5454d9");
  assertEquals(lightness(64, color), "#d9d9f7");
});

Deno.test("SPEC lightness: can darken a color", function () {
  const color = "cornsilk";

  assertEquals(lightness(-4, color), "#fff4c7");
  assertEquals(lightness(-8, color), "#fff0b3");
  assertEquals(lightness(-16, color), "#ffe88a");
  assertEquals(lightness(-32, color), "#ffd738");
  assertEquals(lightness(-64, color), "#947600");
});

Deno.test("SPEC lightness: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#ffffff"],
    ["midnightblue", "#3737d2"],
    ["rgb(255, 133, 30)", "rgb(255, 202, 158)"],
    ["hsl(300, 40%, 70%)", "hsl(300, 40%, 95%)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(40% 0% 31.372% 0%)"],
    ["hwb(120 30% 20%)", "hwb(120 69.02% 9.0196%)"],
    ["lab(36.44% 30 -79)", "lab(65.959% 6.3644 -44.264)"],
    ["lch(63.198% 36 135)", "lch(82.966% 16.294 136.74)"],
  ];

  colors.forEach(([input, target]) =>
    assertEquals(lightness(25, input), target)
  );
});

Deno.test("EDGE lightness: rejects invalid color", function () {
  assertThrows(
    () => {
      throw lightness(16, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});

Deno.test("ALIAS luminance of lightness", function () {
  assertEquals(
    luminance(12, "lab(38.1993% -39 -147.39)"),
    "lab(61.316% 0 -60.022)",
  );
});

Deno.test("ALIAS l of lightness", function () {
  assertEquals(l(30, "slategray"), "#c6ccd2");
});

Deno.test("SPEC alpha: can increase", function () {
  const color = "#abcdef68";

  assertEquals(alpha(4, color), "#abcdef73");
  assertEquals(alpha(8, color), "#abcdef7d");
  assertEquals(alpha(16, color), "#abcdef91");
  assertEquals(alpha(32, color), "#abcdefba");
  assertEquals(alpha(64, color), "#abcdef");
});

Deno.test("SPEC alpha: can decrease", function () {
  const color = "#abcdef";

  assertEquals(alpha(-4, color), "#abcdeff5");
  assertEquals(alpha(-8, color), "#abcdefeb");
  assertEquals(alpha(-16, color), "#abcdefd6");
  assertEquals(alpha(-32, color), "#abcdefad");
  assertEquals(alpha(-64, color), "#abcdef5c");
});

Deno.test("SPEC alpha: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#c0ffeebf"],
    ["midnightblue", "#191970bf"],
    ["rgb(255, 133, 30)", "rgba(255, 131, 30, 0.75)"],
    ["hsl(300, 40%, 70%)", "hsla(300, 40%, 70%, 0.75)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(89.804% 0% 70.196% 0% / 0.75)"],
    ["hwb(120 30% 20%)", "hwb(120 30.196% 20% / 0.75)"],
    ["lab(36.44% 30 -79)", "lab(36.64% 29.588 -78.743 / 0.75)"],
    ["lch(63.198% 36 135)", "lch(63.182% 35.872 135.17 / 0.75)"],
  ];

  colors.forEach(([input, target]) => assertEquals(alpha(-25, input), target));
});

Deno.test("ALIAS transparency of alpha", function () {
  assertEquals(transparency(-25, "#deaded"), "#deadedbf");
});

Deno.test("ALIAS a of alpha", function () {
  assertEquals(a(-64, "#deaded"), "#deaded5c");
});
#+END_SRC

***** Color Adjustment Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./color/adjust/index_test.js)
#+END_SRC

#+NAME: adjustment-test
#+begin_src shell
running 22 tests
test SPEC hue: can adjust clockwise ... ok (16ms)
test SPEC hue: can adjust counterclockwise ... ok (6ms)
test SPEC hue: can adjust all supported formats ... ok (13ms)
test EDGE hue: rejects invalid color ... ok (4ms)
test ALIAS h of hue ... ok (3ms)
test SPEC saturation: can saturate a color ... ok (4ms)
test SPEC saturation: can desaturate a color ... ok (3ms)
test SPEC saturation: can adjust all supported formats ... ok (6ms)
test EDGE saturation: rejects invalid color ... ok (3ms)
test ALIAS sat of saturation ... ok (3ms)
test ALIAS s of saturation ... ok (2ms)
test SPEC lightness: can lighten a color ... ok (4ms)
test SPEC lightness: can darken a color ... ok (3ms)
test SPEC lightness: can adjust all supported formats ... ok (6ms)
test EDGE lightness: rejects invalid color ... ok (2ms)
test ALIAS luminance of lightness ... ok (3ms)
test ALIAS l of lightness ... ok (3ms)
test SPEC alpha: can increase ... ok (4ms)
test SPEC alpha: can decrease ... ok (5ms)
test SPEC alpha: can adjust all supported formats ... ok (4ms)
test ALIAS transparency of alpha ... ok (3ms)
test ALIAS a of alpha ... ok (3ms)

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (106ms)

#+end_src

*** Mixing (=color/mix/index.js=)

Mixing colors creates new colors. For digital displays, however, colors cannot be mixed like
paint. While there are mixing implementations that mimic the RYB pigments color wheel, this isn't
one of them.

Not only because it adds extra complexity for no real gain, but also because this is a /digital/
design systems project and the native, light-based RGB color wheel is more familiar for those of us
working in this space.

**** mix

+ =mix: (amount: number, target: string, color: string) => string=
+ =amount: number=: the amount to mix with target (as a percentage)
+ =target: string=: the blending target to mix with input color
+ =color: string=: the input color

The color mixing implementation works similar to the color adjustment functions in that the result
will have the same format as the /input/ color. This means the target color to mix with can be /any/
valid CSS format; they'll both convert to RGB for calculation.

First, I import some helpers from other modules and write a helper function to calculate RGB channel difference.

#+BEGIN_SRC deno :tangle "./color/mix/index.js" :comments link
import {
  calcChannelFromFraction,
  calcFractionFromChannel,
  calcFractionFromPercent,
  calcPercentFromFraction,
  normalize,
  significant,
} from "../../internals/color/convert/setup.js";
import { extract } from "../../internals/color/format/rgb.js";
import { rgb } from "../conversion/rgb.js";
import { preserve } from "../adjust/setup.js";
import { pipe } from "../../utilities/pipe.js";

const precision = significant.bind(null, 5);

/** Calculate the difference between original and target */
const calcChannelDifference = (original, target, p) =>
  precision(((1 - p) * original ** 2 + p * target ** 2) ** 0.5);
#+END_SRC

Next, I set up a function to actually process the channels.

#+BEGIN_SRC deno :tangle "./color/mix/index.js" :comments link
function calcMixture(original, target, amount) {
  const [OR, OG, OB] = original;
  const [TR, TG, TB] = target;

  return [
    [OR, TR],
    [OG, TG],
    [OB, TB],
  ].map(([X, Y]) => calcChannelDifference(X, Y, amount));
}
#+END_SRC

Finally, the public function executes the mix.

#+BEGIN_SRC deno :tangle "./color/mix/index.js" :comments link
/**
 * A function for mixing colors of any valid CSS format.
 *
 *
 * @example Even mixture
 *
 * ```ts
 * mix(50, 'red', 'blue');
 * ```
 *
 * @example Farther from target
 *
 * ```ts
 * mix(34, 'green', 'blue');
 * ```
 *
 * @example Closer to target
 *
 * ```ts
 * mix(75, 'blue', 'white');
 * ```
 *
 * @remarks
 * As a percentage, the amount is bound to a range of 0-100%. At 0%
 * it yields the input color. And at 100%, it yields the target color
 *
 * @param {number} amount - the amount to mix with target (as a percentage)
 * @param {string} target - the mixture target
 * @param {string} color - the input color
 * @returns {string} The mixture result
 */
export function mix(amount, target, color) {
  const [OR, OG, OB, OA] = pipe(color, rgb, extract);
  const [TR, TG, TB, TA] = pipe(target, rgb, extract);
  const p = calcFractionFromPercent(normalize(0, amount, 100));

  // Mix the channels
  const [R, G, B] = calcMixture([OR, OG, OB], [TR, TG, TB], p).map((V) =>
    Math.round(V)
  );

  // If one or both colors have an alpha value, calculate difference
  const [A1, A2] = [OA, TA].map((V) =>
    V != null ? calcChannelFromFraction(V) : 255
  );

  const A = calcFractionFromChannel(
    normalize(0, calcChannelDifference(A1, A2, p), 255),
  );

  return preserve(
    A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`,
    color,
  );
}
#+END_SRC

**** Tests

***** Color Mixing Assertions

#+BEGIN_SRC deno :tangle "./color/mix/index_test.js" :comments link
import { mix } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC mix: can mix colors", function () {
  const red = "rgb(255, 0, 0)";
  const yellow = "rgb(255, 255, 0)";
  const green = "rgb(0, 255, 0)";
  const cyan = "rgb(0, 255, 255)";
  const blue = "rgb(0, 0, 255)";
  const magenta = "rgb(255, 0, 255)";

  const colors = [
    [red, "rgb(255, 180, 0)", yellow],
    [red, "rgb(180, 180, 0)", green],
    [red, "rgb(180, 180, 180)", cyan],
    [red, "rgb(180, 0, 180)", blue],
    [red, "rgb(255, 0, 180)", magenta],
    [yellow, "rgb(180, 255, 0)", green],
    [yellow, "rgb(180, 255, 180)", cyan],
    [yellow, "rgb(180, 180, 180)", blue],
    [yellow, "rgb(255, 180, 180)", magenta],
    [green, "rgb(0, 255, 180)", cyan],
    [green, "rgb(0, 180, 180)", blue],
    [green, "rgb(180, 180, 180)", magenta],
    [cyan, "rgb(0, 180, 255)", blue],
    [cyan, "rgb(180, 180, 255)", magenta],
    [blue, "rgb(180, 0, 255)", magenta],
  ];

  colors.forEach(([color, blend, target]) =>
    assertEquals(mix(50, target, color), blend)
  );
});

Deno.test("SPEC mix: can mix colors with alpha property", function () {
  assertEquals(mix(50, "#ce9ddaef", "#c91193"), "#cc70baf7");
  assertEquals(mix(75, "#deaded", "#face"), "#e7ace5fb");
  assertEquals(mix(95, "#3ad9cfc5", "#cc911df9"), "#49d6cac8");
});

Deno.test("SPEC mix: can mix colors of any valid format", function () {
  const colors = [
    ["#c99faa", "#ed5f66", "red"],
    ["rgb(118, 20, 250)", "rgb(216, 204, 150)", "yellow"],
    ["hsl(320, 70%, 31%)", "hsl(111, 59.514%, 51.569%)", "lime"],
    [
      "device-cmyk(0% 79% 32% 0%)",
      "device-cmyk(33.188% 9.6069% 0% 10.196%)",
      "cyan",
    ],
    ["hwb(148 28% 38%)", "hwb(222 16.863% 15.686%)", "blue"],
    ["lab(46.48% -38 120)", "lab(54.802% 64.129 -40.944)", "magenta"],
    ["lch(89.311% 63 300)", "lch(80.804% 32.723 315.73)", "#deaded"],
  ];

  colors.forEach(([color, blend, target]) =>
    assertEquals(mix(64, target, color), blend)
  );
});

Deno.test("EDGE mix: throws error when either color is invalid", function () {
  assertThrows(
    () => {
      throw mix(40, "invalid", "#c0ffee");
    },
    undefined,
    "not a valid CSS color",
  );
  assertThrows(
    () => {
      throw mix(40, "#deaded", "c0ffee");
    },
    undefined,
    "not a valid CSS color",
  );
  assertThrows(
    () => {
      throw mix(40, "invalid", "c0ffee");
    },
    undefined,
    "not a valid CSS color",
  );
});
#+END_SRC

***** Color Mixing Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./color/mix/index_test.js)
#+END_SRC

#+NAME: mix-test
#+begin_src shell
running 4 tests
test SPEC mix: can mix colors ... ok (17ms)
test SPEC mix: can mix colors with alpha property ... ok (4ms)
test SPEC mix: can mix colors of any valid format ... ok (11ms)
test EDGE mix: throws error when either color is invalid ... ok (3ms)

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (36ms)

#+end_src

*** Scheme Generation (=color/scheme/index.js=)

Color schemes are a way of adding more visual interest and tension to a design. The primary scheme
configurations used in digital design include:

+ Monochromatic: a single color scheme consisting of a base color and palette variants (tints,
  tones, and/or shades) of that color
+ Analogous: a multi-color scheme consisting of a base color and a selection of hues directly next
  to it on the color wheel. Examples: red, orange, yellow or red, magenta-red, magenta
+ Complementary: a two color scheme consisting of a base color and its complement (opposite) on the
  color wheel. Examples: red and cyan or green and magenta
+ Split-Complementary: A three color scheme consisting of a base color and two hues on either side
  of its complement. Example: red, cyan-blue, green-cyan
+ Triadic: a color scheme consisting of three colors equally spaced around the color wheel. Example:
  red, green, blue
+ Tetradic/Dual: a four color scheme consisting of a base color, its complement, and a rotational
  offset of both points; creating a rectangle
+ Square: a color scheme consisting of four colors equally spaced around the color wheel

Besides providing functions for each of the basic color schemes, Quarks System Core also provides
a function for generating advanced custom schemes.

#+BEGIN_SRC deno :tangle "./color/scheme/index.js" :comments link
export { complementary } from "./complementary.js";
export { analogous } from "./analogous.js";
export { splitComplementary } from "./split.js";
export { triadic } from "./triadic.js";
export { tetradic, dualComplementary } from "./tetradic.js";
export { square } from "./square.js";
export { scheme } from "./custom.js";
#+END_SRC

Compared with QuarkSuite 1, QSC eliminates scheme boilerplate and leaves calculation and offset
adjustments for the advanced function.

**** complementary (=color/scheme/complementary.js=)

+ =complementary: (color: string) => [string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC deno :tangle "./color/scheme/complementary.js" :comments link
import { hue } from "../adjust/hue.js";

/**
 * Creates a complementary color scheme from any valid CSS color.
 *
 * @example Creating a complementary scheme
 *
 * ```ts
 * complementary("coral");
 * ```
 *
 * @remarks
 * A complementary color scheme is composed of a base color and its
 * opposite on the color wheel. It is a scheme with the highest possible
 * warm/cool color contrast.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string]} The base hues for a complementary color scheme
 */
export const complementary = (color) => [hue(0, color), hue(180, color)];
#+END_SRC

**** analogous (=color/scheme/analogous.js=)

+ =analogous: (color: string) => [string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC deno :tangle "./color/scheme/analogous.js" :comments link
import { hue } from "../adjust/hue.js";

const construct = (arc, color) => [
  hue(0, color),
  hue(-arc, color),
  hue(arc, color),
];

/**
 * Creates an analogous color scheme from any valid CSS color.
 *
 * @example Creating an analogous color scheme
 *
 * ```ts
 * analogous("coral");
 * ```
 *
 * @remarks
 * An analogous color scheme is composed of a color and its directly
 * adjacent counterparts on the color wheel; hues about 30Â° apart from
 * the origin.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string]} The base hues for a analogous color scheme
 */
export const analogous = (color) => construct(30, color);
#+END_SRC

**** splitComplementary (=color/scheme/split.js=)

+ =splitComplementary: (color: string) => [string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC deno :tangle "./color/scheme/split.js" :comments link
import { hue } from "../adjust/hue.js";

export function construct(arc, color) {
  const complement = hue.bind(null, 180);

  return [
    hue(0, color),
    hue(arc, complement(color)),
    hue(-arc, complement(color)),
  ];
}

/**
 * Creates a split complementary color scheme from any valid CSS color.
 *
 * @example Creaing a split complementary scheme
 *
 * ```ts
 * splitComplementary("coral");
 * ```
 *
 * @remarks
 * A split complementary scheme is composed of a base color and a bisection
 * of colors directly next to its opposite; hues about 30Â° apart.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string]} The base hues for a split complementary color scheme
 */
export const splitComplementary = (color) => construct(30, color);
#+END_SRC

**** triadic (=color/scheme/triadic.js=)

+ =triadic: (color: string) => [string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC deno :tangle "./color/scheme/triadic.js" :comments link
import { hue } from "../adjust/hue.js";
import { construct } from "./split.js";

/**
 * Creates a triadic color scheme from any valid CSS color.
 *
 * @example Creating a triadic color scheme
 *
 * ```ts
 * triadic("coral");
 * ```
 *
 * @remarks
 * A triadic color scheme is composed of three colors evenly spaced around
 * the color wheel; the origin and two hues 120Â° apart from the origin.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string]} The base hues for a triadic color scheme
 */
export const triadic = (color) => construct(60, color);
#+END_SRC

**** tetradic (=color/scheme/tetradic.js=)

+ =tetradic/dualComplementary: (color: string) => [string, string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC deno :tangle "./color/scheme/tetradic.js" :comments link
import { hue } from "../adjust/hue.js";

export function construct(offset, color) {
  const origin = hue(0, color);
  const complement = hue(180, color);

  return [origin, hue(-offset, origin), complement, hue(-offset, complement)];
}

/**
 * Creates a tetradic color scheme from any valid CSS color.
 *
 * @example Creating a tetradic color scheme
 *
 * ```ts
 * tetradic("coral");
 * ```
 *
 * @remarks
 * A tetradic color scheme consists of a color, its opposite, and a
 * second complementary pair of colors. They are also called dual
 * complementary schemes.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string, string]} The base hues for a tetradic color scheme
 */
export const tetradic = (color) => construct(60, color);

/** An alias for `tetradic()` */
export const dualComplementary = tetradic;
#+END_SRC

**** square (=color/scheme/square.js=)

+ =square: (color: string) => [string, string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC deno :tangle "./color/scheme/square.js" :comments link
import { hue } from "../adjust/hue.js";
import { construct } from "./tetradic.js";

/**
 * Creates a square color scheme from any valid CSS color.
 *
 * @example Creating a square color scheme
 *
 * ```ts
 * square("coral");
 * ```
 *
 * @remarks
 * A square color scheme consists of four colors positioned equally
 * around the color wheel; hues 90Â° apart from the origin.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string, string]} The base hues for a square color scheme
 */
export const square = (color) => construct(90, color);
#+END_SRC

**** scheme (=color/scheme/custom.js=)

+ =scheme: (attrs: { hues: number, arc: number, offset?: number }, color: string) => string[]=
+ =attrs: { hues: number, arc: number, offset?: number }=
  - =hues: number=: the number of total hues to generate (minus values that overlap)
  - =arc: number=: the desired arc distance between each hue on the wheel
  - =offset?: number=: an optional rotation offset for generated hues (does not change origin)
+ =color: string=: the base color to generate custom scheme

#+BEGIN_SRC deno :tangle "./color/scheme/custom.js" :comments link
import { hue } from "../adjust/hue.js";

function generate({ hues, arc, offset = 0 }, color) {
  const values = Array(offset ? hues - 1 : hues + 1).fill(arc);
  const half = Math.ceil(values.length / 2);
  const [leftOfOrigin, rightOfOrigin] = [
    values.slice(0, half),
    values.slice(half, values.length),
  ];
  return offset
    ? [
      ...new Set([
        hue(0, color),
        ...leftOfOrigin.map((v, i) => hue(-(v * i) - offset, color)),
        ...rightOfOrigin.map((v, i) => hue(v * i + offset, color)),
      ]),
    ] // Must preserve the origin with offset
    : [
      ...new Set([
        ...leftOfOrigin.map((v, i) => hue(-(v * i) - offset, color)),
        ...rightOfOrigin.map((v, i) => hue(v * i + offset, color)),
      ]),
    ]; // Must add an extra hue to generate from origin
}

/**
 * A function for creating advanced schemes from any valid CSS color.
 *
 * @example Creating a five tone color scheme
 *
 * ```ts
 * scheme({ hues: 5, arc: 72 }, "#e33a00");
 * ```
 *
 * @example Creating a six tone color scheme
 *
 * ```ts
 * scheme({ hues: 6, arc: 60 }, "hsl(320grad, 75%, 50%)");
 * ```
 * @example  Creating an accented split complementary
 *
 * ```ts
 * scheme({ hues: 4, arc: 30, offset: 150 }, "royalblue");
 * ```
 *
 * @remarks
 * This function is for generating schemes beyond basic configuration.
 *
 * It allows setting any number of hues but will only generate unique colors.
 * The arc is the distance between each color on the wheel. The offset defines
 * degree of rotation for the generated hues from the origin.
 *
 * @param {{ hues: number, arc: number, offset?: number }} attrs - A configuration object defining desired hues (minus overlapping values), arc distance between each hue from the origin, and optional rotation offset
 * @param {string} color - the base color to generate scheme
 * @returns {string[]} A collection of base hues for a custom scheme
 */
export const scheme = (attrs, color) => generate(attrs, color);
#+END_SRC

**** Tests

***** Color Scheme Generation Assertions

#+BEGIN_SRC deno :tangle "./color/scheme/index_test.js" :comments link
import {
  analogous,
  complementary,
  dualComplementary,
  scheme,
  splitComplementary,
  square,
  tetradic,
  triadic,
} from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test(
  "SPEC complementary: generate base hues for complementary scheme",
  function () {
    assertEquals(complementary("red"), ["#ff0000", "#00ffff"]);
    assertEquals(complementary("lime"), ["#00ff00", "#ff00ff"]);
    assertEquals(complementary("blue"), ["#0000ff", "#ffff00"]);
  },
);

Deno.test(
  "SPEC analogous: generate base hues for analogous scheme",
  function () {
    assertEquals(analogous("red"), ["#ff0000", "#ff0080", "#ff8000"]);
    assertEquals(analogous("lime"), ["#00ff00", "#80ff00", "#00ff80"]);
    assertEquals(analogous("blue"), ["#0000ff", "#0080ff", "#8000ff"]);
  },
);

Deno.test(
  "SPEC splitComplementary: generate base hues for split complementary scheme",
  function () {
    assertEquals(splitComplementary("red"), ["#ff0000", "#0080ff", "#00ff80"]);
    assertEquals(splitComplementary("lime"), ["#00ff00", "#ff0080", "#8000ff"]);
    assertEquals(splitComplementary("blue"), ["#0000ff", "#80ff00", "#ff8000"]);
  },
);

Deno.test("SPEC triadic: generate base hues for triadic scheme", function () {
  assertEquals(triadic("red"), ["#ff0000", "#0000ff", "#00ff00"]);
  assertEquals(triadic("cyan"), ["#00ffff", "#ffff00", "#ff00ff"]);
});

Deno.test("SPEC tetradic: generate base hues for tetradic scheme", function () {
  assertEquals(tetradic("red"), ["#ff0000", "#ff00ff", "#00ffff", "#00ff00"]);
  assertEquals(tetradic("lime"), ["#00ff00", "#ffff00", "#ff00ff", "#0000ff"]);
  assertEquals(tetradic("blue"), ["#0000ff", "#00ffff", "#ffff00", "#ff0000"]);
});

Deno.test("ALIAS dualComplementary of tetradic", function () {
  assertEquals(dualComplementary("cyan"), [
    "#00ffff",
    "#00ff00",
    "#ff0000",
    "#ff00ff",
  ]);
});

Deno.test("SPEC square: generate base hues for square scheme", function () {
  assertEquals(square("red"), ["#ff0000", "#8000ff", "#00ffff", "#80ff00"]);
  assertEquals(square("lime"), ["#00ff00", "#ff8000", "#ff00ff", "#0080ff"]);
  assertEquals(square("blue"), ["#0000ff", "#00ff80", "#ffff00", "#ff0080"]);
});

Deno.test("SPEC scheme: simulate complementary", function () {
  assertEquals(scheme({ hues: 2, arc: 180 }, "red"), ["#ff0000", "#00ffff"]);
});

Deno.test("SPEC scheme: simulate triadic", function () {
  assertEquals(scheme({ hues: 3, arc: 120 }, "red"), [
    "#ff0000",
    "#0000ff",
    "#00ff00",
  ]);
});

Deno.test("SPEC scheme: simulate square", function () {
  assertEquals(scheme({ hues: 4, arc: 90 }, "red"), [
    "#ff0000",
    "#8000ff",
    "#00ffff",
    "#80ff00",
  ]);
});

Deno.test("SPEC scheme: 4 color analogous", function () {
  assertEquals(scheme({ hues: 4, arc: 30 }, "red"), [
    "#ff0000",
    "#ff0080",
    "#ff00ff",
    "#ff8000",
  ]);
});

Deno.test("SPEC scheme: accented triad", function () {
  assertEquals(scheme({ hues: 5, arc: 30, offset: 120 }, "red"), [
    "#ff0000",
    "#0000ff",
    "#0080ff",
    "#00ff00",
    "#00ff80",
  ]);
});

Deno.test("SPEC scheme: accented split complementary", function () {
  assertEquals(scheme({ hues: 4, arc: 30, offset: 150 }, "red"), [
    "#ff0000",
    "#0080ff",
    "#00ffff",
    "#00ff80",
  ]);
});

Deno.test("EDGE: rejects invalid color", function () {
  const fns = [
    complementary,
    analogous,
    splitComplementary,
    triadic,
    tetradic,
    square,
  ];

  fns.map((fn) =>
    assertThrows(
      () => {
        throw fn("invalid");
      },
      undefined,
      "not a valid CSS color",
    )
  );
  assertThrows(
    () => {
      throw scheme({ hues: 2, arc: 180 }, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});
#+END_SRC

***** Color Scheme Generation Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./color/scheme/index_test.js)
#+END_SRC

#+NAME: scheme-test
#+begin_src shell
running 14 tests
test SPEC complementary: generate base hues for complementary scheme ... ok (17ms)
test SPEC analogous: generate base hues for analogous scheme ... ok (6ms)
test SPEC splitComplementary: generate base hues for split complementary scheme ... ok (8ms)
test SPEC triadic: generate base hues for triadic scheme ... ok (5ms)
test SPEC tetradic: generate base hues for tetradic scheme ... ok (5ms)
test ALIAS dualComplementary of tetradic ... ok (3ms)
test SPEC square: generate base hues for square scheme ... ok (3ms)
test SPEC scheme: simulate complementary ... ok (1ms)
test SPEC scheme: simulate triadic ... ok (3ms)
test SPEC scheme: simulate square ... ok (3ms)
test SPEC scheme: 4 color analogous ... ok (3ms)
test SPEC scheme: accented triad ... ok (3ms)
test SPEC scheme: accented split complementary ... ok (3ms)
test EDGE: rejects invalid color ... ok (3ms)

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (70ms)

#+end_src

*** Palette Creation (=color/palette/index.js=)

A color palette isn't complete without contrast, so we'll finish with tints, tones, and shades.

+ Tints: any color mixed with pure white
+ Tones: any color mixed with pure gray
+ Shades: any color mixed with pure black

#+BEGIN_SRC deno :tangle "./color/palette/index.js" :comments link
export { tints } from "./tints.js";
export { tones } from "./tones.js";
export { shades } from "./shades.js";
#+END_SRC

First, I'm setting up a helper for generating my variants.

#+BEGIN_SRC deno :tangle "./color/palette/setup.js" :comments link
import { mix } from "../mix/index.js";

export const generate = (color, target, contrast, count) =>
  Array.from(Array(count).fill(color)).map((base, index) =>
    mix(contrast - (contrast / count) * index, target, base)
  );
#+END_SRC

**** tints (=color/palette/tints.js=)

+ =tints: (count: number, contrast: number, color: string) => string[]=
+ =count: number=: number of tints to generate
+ =contrast: number=: contrast between generated values (as a percentage)
+ =color: string=: the base color to generate tints from

#+BEGIN_SRC deno :tangle "./color/palette/tints.js" :comments link
import { pipe } from "../../utilities/pipe.js";
import { generate } from "./setup.js";
import { extract } from "../../internals/color/format/hwb.js";
import { hwb } from "../conversion/hwb.js";
import { preserve } from "../adjust/setup.js";

/**
 * Generates tints from any valid CSS color.
 *
 * @example Generating 4 high contrast tints
 *
 * ```ts
 * tints(4, 98, "royalblue");
 * ```
 *
 * @remarks
 * A color mixed with pure white creates a tint of that color.
 *
 * @param {number} count - number of tints to generate
 * @param {number} contrast - contrast of palette (as a percentage)
 * @param {string} color - the base color to generate from
 * @returns {string[]} A generated scale of tints
 */
export const tints = (
  count,
  contrast,
  color,
) => [
  ...new Set([
    ...generate(color, "white", contrast, count)
      .map((color) => pipe(color, hwb, extract))
      .sort((a, b) => parseFloat(a[1]) - parseFloat(b[1]))
      .map(([H, W, B, A]) =>
        !A ? `hwb(${H} ${W} ${B})` : `hwb(${H} ${W} ${B} / ${A})`
      )
      .map((target) => preserve(target, color)),
  ]),
];
#+END_SRC

**** tones (=color/palette/tones.js=)

+ =tones: (count: number, contrast: number, color: string) => string[]=
+ =count: number=: number of tones to generate
+ =contrast: number=: contrast between generated values (as a percentage)
+ =color: string=: the base color to generate tones from

#+BEGIN_SRC deno :tangle "./color/palette/tones.js" :comments link
import { pipe } from "../../utilities/pipe.js";
import { generate } from "./setup.js";
import { extract } from "../../internals/color/format/hwb.js";
import { hwb } from "../conversion/hwb.js";
import { preserve } from "../adjust/setup.js";

/**
 * Generates tones from any valid CSS color.
 *
 * @example Generating 4 high contrast tones
 *
 * ```ts
 * tones(4, 98, "royalblue");
 * ```
 *
 * @remarks
 * A color mixed with pure gray creates a tone of that color.
 *
 * Be aware that tone is also another way of referring to the hue.
 *
 * @param {number} count - number of tones to generate
 * @param {number} contrast - contrast of palette (as a percentage)
 * @param {string} color - the base color to generate from
 * @returns {string[]} A generated scale of tones
 */
export const tones = (
  count,
  contrast,
  color,
) => [
  ...new Set([
    ...generate(color, "gray", contrast, count)
      .map((color) => pipe(color, hwb, extract))
      .sort(
        (a, b) =>
          parseFloat(a[1]) +
          parseFloat(a[2]) -
          (parseFloat(b[1]) + parseFloat(b[2])),
      )
      .map(([H, W, B, A]) =>
        !A ? `hwb(${H} ${W} ${B})` : `hwb(${H} ${W} ${B} / ${A})`
      )
      .map((target) => preserve(target, color)),
  ]),
];
#+END_SRC

**** shades (=color/palette/shades.js=)

+ =shades: (count: number, contrast: number, color: string) => string[]=
+ =count: number=: number of shades to generate
+ =contrast: number=: contrast between generated values (as a percentage)
+ =color: string=: the base color to generate shades from

#+BEGIN_SRC deno :tangle "./color/palette/shades.js" :comments link
import { pipe } from "../../utilities/pipe.js";
import { generate } from "./setup.js";
import { extract } from "../../internals/color/format/hwb.js";
import { hwb } from "../conversion/hwb.js";
import { preserve } from "../adjust/setup.js";

/**
 * Generates shades from any valid CSS color.
 *
 * @example Generating 4 high contrast shades
 *
 * ```ts
 * shades(4, 98, "royalblue");
 * ```
 *
 * @remarks
 * A color mixed with pure black creates a shade of that color.
 *
 * @param {number} count - number of shades to generate
 * @param {number} contrast - contrast of palette (as a percentage)
 * @param {string} color - the base color to generate from
 * @returns {string[]} A generated scale of shades
 */
export const shades = (
  count,
  contrast,
  color,
) => [
  ...new Set([
    ...generate(color, "black", contrast, count)
      .map((color) => pipe(color, hwb, extract))
      .sort((a, b) => parseFloat(a[2]) - parseFloat(b[2]))
      .map(([H, W, B, A]) =>
        !A ? `hwb(${H} ${W} ${B})` : `hwb(${H} ${W} ${B} / ${A})`
      )
      .map((target) => preserve(target, color)),
  ]),
];
#+END_SRC

**** Tests

***** Color Palette Assertions

#+BEGIN_SRC deno :tangle "./color/palette/index_test.js" :comments link
import { shades, tints, tones } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC tints: can generate tints", function () {
  assertEquals(tints(2, 100, "red"), ["#ffb4b4", "#ffffff"]);
  assertEquals(tints(3, 100, "lime"), ["#92ff92", "#d1ffd1", "#ffffff"]);
  assertEquals(tints(4, 100, "blue"), [
    "#8080ff",
    "#b4b4ff",
    "#ddddff",
    "#ffffff",
  ]);
});

Deno.test("SPEC tones: can generate tones", function () {
  assertEquals(tones(2, 100, "red"), ["#ca5b5b", "#808080"]);
  assertEquals(tones(3, 100, "lime"), ["#4add4a", "#69b469", "#808080"]);
  assertEquals(tones(4, 100, "blue"), [
    "#4040e6",
    "#5b5bca",
    "#6f6fa9",
    "#808080",
  ]);
});

Deno.test("SPEC shades: can generate shades", function () {
  assertEquals(shades(2, 100, "red"), ["#b40000", "#000000"]);
  assertEquals(shades(3, 100, "lime"), ["#00d100", "#009200", "#000000"]);
  assertEquals(shades(4, 100, "blue"), [
    "#0000dd",
    "#0000b4",
    "#000080",
    "#000000",
  ]);
});
#+END_SRC

***** Color Palette Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./color/palette/index_test.js)
#+END_SRC

#+NAME: palette-test
#+begin_src shell
running 3 tests
test SPEC tints: can generate tints ... ok (46ms)
test SPEC tones: can generate tones ... ok (10ms)
test SPEC shades: can generate shades ... ok (9ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (67ms)

#+end_src

*** Accessibility (=color/a11y/index.js=)

Accessibility is a first-class concern for every modern web project. Quarks System Core
addresses this vital aspect of digital design with the following tools.

**** clrs

+ =clrs: (color: string) => string=
+ =color: string=: a valid name for a swatch in the Colors project

#+BEGIN_SRC deno :tangle "./color/a11y/index.js" :comments link
import { ErrorTemplate } from "../../internals/error.js";
import { A11yColors } from "../../data/color/a11y.js";

const ColorUndefinedError = (output) =>
  ErrorTemplate({
    message: "color not defined in Colors",
    reason: `
This error triggers when the color does not match a defined color in
the Colors project.
`,
    suggestion: `
Pass in one of the below valid colors:

navy
blue
aqua

teal

olive
green
lime

yellow
orange
red

maroon
fuchsia
purple

black

gray/grey
silver

white
`,
    output,
  });

/**
 * A function for using better web defaults from the Colors project.
 *
 * @example Using a more accessible teal
 *
 * ```ts
 * clrs("teal");
 * ```
 *
 * @param { "navy" | "aqua" | "blue" | "teal" | "olive" | "green" | "lime" | "yellow" | "orange" | "red" | "maroon" | "fuchsia" | "purple" | "black" | "gray" | "grey" | "silver" | "white" } color - a valid color name in the Colors project
 * @returns {string} The targeted color from the Colors project
 */
export function clrs(color) {
  if (A11yColors.hasOwnProperty(color)) {
    return A11yColors[color];
  }

  return ColorUndefinedError(color);
}
#+END_SRC

A great base for accessible palettes is the Colors project. It provides a [[https://clrs.cc][curated collection of
better default colors]] optimized for high contrast interfaces.

**** contrast

+ =contrast: (opts: { rating: "AA" | "AAA", enhanced?: boolean }, palette: string[]) => string[]=
+ =opts: { rating: "AA" | "AAA", enhanced?: boolean }=: palette contrast filtering options
  - =rating: "AA" | "AAA"=: the desired minimum WCAG color contrast accessibility rating to process a palette
  - =enhanced?: boolean=: a flag to toggle the enhanced WCAG recommendations

QSC allows a hefty degree of flexibility in defining and generating your palettes. It also provides
a necessary guardrail to keep color choices from running afoul of usability.

#+BEGIN_SRC deno :tangle "./color/a11y/index.js" :comments link
import { significant } from "../../internals/color/convert/setup.js";
import { calcFractionFromChannel } from "../../internals/color/convert/setup.js";
import { extract } from "../../internals/color/format/rgb.js";
import { pipe } from "../../utilities/pipe.js";
import { rgb } from "../conversion/rgb.js";

const precision = significant.bind(null, 3);

function calcRelativeLuminance(color) {
  const [R, G, B] = pipe(color, rgb, extract)
    .map((V) =>
      pipe(
        V,
        parseFloat,
        calcFractionFromChannel,
      )
    ).map((V) => V <= 0.03928 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4);

  return R * 0.2126 + 0.7152 * G + B * 0.0722;
}

function calcRatio(foreground, background) {
  const [L1, L2] = [foreground, background].sort((a, b) =>
    calcRelativeLuminance(b) - calcRelativeLuminance(a)
  ).map((V) => calcRelativeLuminance(V));

  return precision((L1 + 0.05) / (L2 + 0.05));
}

/**
 * A function that allows you to filter palettes by their contrast rating.
 *
 * @example Filtering a palette to only contain colors with a WCAG AA rating
 *
 * ```ts
 * contrast({ rating: "AA" }, palette);
 * ```
 *
 * @example Filtering a palette to only contain colors with a WCAG AAA rating
 *
 * ```ts
 * contrast({ rating: "AAA" }, palette);
 * ```
 *
 * @example Using the enhanced recommendations flag
 *
 * ```ts
 * contrast({ rating: "AA", enhanced: true}, palette);
 * ```
 *
 * @param {{ rating: "AA" | "AAA", enhanced?: boolean }} opts - options for filtering the palette
 * @param {string[]} palette - the completed color palette to filter
 * @returns {string[]} A color palette filtered by accessibility standards
 */
export function contrast(opts, palette) {
  const { rating, enhanced = false } = opts;
  const [base, ...generated] = palette;

  return [
    base,
    ...generated.filter((color) => {
      const ratio = calcRatio(base, color);
      const max = ratio <= 21;

      if (rating === "AA") {
        return (enhanced ? (ratio >= 4.5) : (ratio >= 3.1)) && max;
      }

      if (rating === "AAA") {
        return (enhanced ? (ratio >= 7) : (ratio >= 4.5)) && max;
      }
    }),
  ];
}
#+END_SRC

You can use the =contrast()= function in two main ways:

+ Validating your color choices for a custom palette
+ Filtering a generated palette down to an accessible subset of colors

**** Tests

***** Color Accessibility Assertions

#+BEGIN_SRC deno :tangle "./color/a11y/index_test.js" :comments link
import { clrs, contrast } from "./index.js";
import { shades, tints } from "../palette/index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const Colors = [
  ["navy", "#001f3f"],
  ["blue", "#0074d9"],
  ["aqua", "#7fdbff"],
  ["teal", "#39cccc"],
  ["olive", "#3d9970"],
  ["green", "#2ecc40"],
  ["lime", "#01ff70"],
  ["yellow", "#ffdc00"],
  ["orange", "#ff851b"],
  ["red", "#ff4136"],
  ["maroon", "#85144b"],
  ["fuchsia", "#f012be"],
  ["purple", "#b10dc9"],
  ["black", "#111111"],
  ["gray", "#aaaaaa"],
  ["grey", "#aaaaaa"],
  ["silver", "#dddddd"],
  ["white", "#ffffff"],
];

Colors.forEach(([name, value]) =>
  Deno.test(`SPEC clrs: ${value} matches ${name}`, function () {
    assertEquals(clrs(name), value);
  })
);

Deno.test("EDGE clrs: rejects undefined color", function () {
  assertThrows(
    () => {
      throw clrs("invalid");
    },
    undefined,
    "color not defined in Colors",
  );
});

Deno.test("SPEC contrast: can generate WCAG AA compliant results", function () {
  const base = clrs("red");
  const palette = [base, ...tints(16, 99, base), ...shades(16, 99, base)];

  assertEquals(contrast({ rating: "AA" }, palette), [
    "#ff4136",
    "#ffefef",
    "#fff7f6",
    "#fffefe",
    "#721d18",
    "#5c1713",
    "#43110e",
    "#1a0705",
  ]);
});

Deno.test("SPEC contrast: can generate WCAG AAA compliant results", function () {
  const base = clrs("lime");
  const palette = [base, ...tints(32, 99, base), ...shades(32, 99, base)];

  assertEquals(contrast({ rating: "AAA" }, palette), [
    "#01ff70",
    "#007232",
    "#00662c",
    "#005c28",
    "#005123",
    "#00431e",
    "#003316",
    "#001a0b",
  ]);
});

Deno.test("SPEC contrast: can generate WCAG AA (enhanced) compliant results", function () {
  const base = clrs("aqua");
  const palette = [base, ...tints(32, 99, base), ...shades(32, 99, base)];

  assertEquals(contrast({ rating: "AA", enhanced: true }, palette), [
    "#7fdbff",
    "#335866",
    "#2e4f5c",
    "#284551",
    "#223a43",
    "#192c33",
    "#0d161a",
  ]);
});

Deno.test("SPEC contrast: can generate WCAG AAA (enhanced) compliant results", function () {
  const base = clrs("silver");
  const palette = [base, ...tints(32, 99, base), ...shades(32, 99, base)];

  assertEquals(contrast({ rating: "AAA", enhanced: true }, palette), [
    "#dddddd",
    "#3a3a3a",
    "#2c2c2c",
    "#161616",
  ]);
});
#+END_SRC

***** Color Accessibility Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./color/a11y/index_test.js)
#+END_SRC

#+NAME: accessibility-test
#+begin_src shell
running 23 tests
test SPEC clrs: #001f3f matches navy ... ok (5ms)
test SPEC clrs: #0074d9 matches blue ... ok (2ms)
test SPEC clrs: #7fdbff matches aqua ... ok (2ms)
test SPEC clrs: #39cccc matches teal ... ok (2ms)
test SPEC clrs: #3d9970 matches olive ... ok (2ms)
test SPEC clrs: #2ecc40 matches green ... ok (2ms)
test SPEC clrs: #01ff70 matches lime ... ok (2ms)
test SPEC clrs: #ffdc00 matches yellow ... ok (2ms)
test SPEC clrs: #ff851b matches orange ... ok (2ms)
test SPEC clrs: #ff4136 matches red ... ok (2ms)
test SPEC clrs: #85144b matches maroon ... ok (1ms)
test SPEC clrs: #f012be matches fuchsia ... ok (2ms)
test SPEC clrs: #b10dc9 matches purple ... ok (2ms)
test SPEC clrs: #111111 matches black ... ok (2ms)
test SPEC clrs: #aaaaaa matches gray ... ok (2ms)
test SPEC clrs: #aaaaaa matches grey ... ok (2ms)
test SPEC clrs: #dddddd matches silver ... ok (2ms)
test SPEC clrs: #ffffff matches white ... ok (2ms)
test EDGE clrs: rejects undefined color ... ok (3ms)
test SPEC contrast: can generate WCAG AA compliant results ... ok (56ms)
test SPEC contrast: can generate WCAG AAA compliant results ... ok (65ms)
test SPEC contrast: can generate WCAG AA (enhanced) compliant results ... ok (63ms)
test SPEC contrast: can generate WCAG AAA (enhanced) compliant results ... ok (64ms)

test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (290ms)

#+end_src

** Typography (=typography/index.js=)

Quarks System Core isn't focused much on typography at this point, but it does provide a single
function =systemfonts()= to aid [[https://systemfontstack.com][prototyping with system font stacks]]. I'll expand this module as
needed in step with the project's growth.

*** systemfonts

+ =systemfonts: (...families: ("san-serif" | "serif" | "monospace")[]) => string[]=
+ =...families: ("sans-serif" | "serif" | "monospace")[]=: keywords matching the available system font
  stacks

#+BEGIN_SRC deno :tangle "./typography/index.js" :comments link
import { SystemFontStacks } from "../data/typography/system.js";
import { ErrorTemplate } from "../internals/error.js";

const SystemFamilyError = (output) =>
  ErrorTemplate({
    message: "key is not a system font stack family",
    reason: `
This error is triggered when one or more of the keys passed into
systemfonts() is invalid.
`,
    suggestion: `
Pass in valid system font stack keywords as strings.

Examples:

systemfonts("sans-serif", "monospace");
systemfonts("sans-serif", "serif");
systemfonts("sans-serif");
systemfonts("sans-serif", "serif", "monospace");
`,
    output,
  });

/**
 * Outputs a collection of system font stacks.
 *
 * @example Outputting a single family
 *
 * ```ts
 * systemfonts("sans-serif");
 * ```
 *
 * @example Outputting multiple families
 *
 * ```ts
 * systemfonts("sans-serif", "serif");
 * ```
 *
 * @example Outputting all families
 *
 * ```ts
 * systemfonts("sans-serif", "serif", "monospace");
 * ```
 *
 * @param {("sans-serif" | "serif" | "monospace")[]} families - keyword(s) matching available system font stacks
 * @returns {string[]} An array of system font stacks
 */
export function systemfonts(...families) {
  if (
    families.every((family) =>
      family === "sans-serif" || family === "serif" || family === "monospace"
    )
  ) {
    return families.map((family) => SystemFontStacks[family]);
  }

  return SystemFamilyError(families);
}
#+END_SRC

*** Tests

**** Typography Assertions

#+BEGIN_SRC deno :tangle "./typography/index_test.js" :comments link
import { systemfonts } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC systemfonts: can output a collection of system font stacks for prototyping", function () {
  assertEquals(systemfonts("sans-serif"), [
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  ]);
  assertEquals(systemfonts("sans-serif", "serif"), [
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  ]);
  assertEquals(systemfonts("sans-serif", "serif", "monospace"), [
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
  ]);
});

Deno.test("EGDE systemfonts: rejects invalid family keys", function () {
  assertThrows(
    () => {
      throw systemfonts("invalid");
    },
    undefined,
    "not a system font stack family",
  );
});
#+END_SRC

**** Typography Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./typography/index_test.js)
#+END_SRC

#+NAME: typography-test
#+begin_src shell
running 2 tests
test SPEC systemfonts: can output a collection of system font stacks for prototyping ... ok (6ms)
test EGDE systemfonts: rejects invalid family keys ... ok (3ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (10ms)

#+end_src

** Modular Scale (=scale/index.js=)

Now that I'm all set for color, I can begin thinking about sizing and proportion. Modular scales are
the best way to manage consistency between values. They can be used for:

+ typographical hierarchy
+ spacing
+ sizing
+ borders

The Quarks System Core scale module is more or less unchanged from QuarkSuite 1 with the addition of
error handling to catch bad input.

It begins with creating a scale as a collection of raw values that the remaining utilities consume
and modify before finally attaching units for output.

*** create

+ =create: (values: number, ratio: number, base: number) => number[]=
+ =values: number=: the number of values to include (output range)
+ =ratio: number=: the ratio maintained between each value in the scale
+ =base: number=: initial scale value

The formula to calculate each value in the scale is straightforward. The array is first filled with
the base value, then multiplied with ratio to the nth of the current index.

Example: when =base = 1=, =ratio = 2=, =index = 2=, then ~base * ratio ** index === 1 * 2 ** 2 === 1 * 4 === 4~

#+BEGIN_SRC deno :tangle "./scale/index.js" :comments link
/**
 * Create a new modular scale.
 *
 * @example Create a 6 value scale from base of 1 with ratio of 1.5
 *
 * ```ts
 * create(6, 1.5, 1);
 * ```
 *
 * @param {number} values - the number of values to include (output range)
 * @param {number} ratio - the ratio maintained between each value
 * @param {number} base - the initial scale value
 * @returns {number[]} An array of raw modular scale values
 */
export const create = (values, ratio, base) =>
  Array(values).fill(base).map((base, index) => base * ratio ** index);
#+END_SRC

*** update

+ =update: (calc: (n: number) => number, scale: number[]) => number[]=
+ =calc: (: number) => number=: the desired calculation to modify each scale value
+ =scale: number[]=: the scale to update

This utility updates the values in created scales with a user-defined recalculation and outputs a
new scale from the results.

#+BEGIN_SRC deno :tangle "./scale/index.js" :comments link
import { ErrorTemplate } from "../internals/error.js";

const ScaleError = (output) =>
  ErrorTemplate({
    message: "not a modular scale",
    reason: `
This error triggers when the value passed in as scale is not actually
a modular scale.
`,
    suggestion: `
Ensure that you only use scale modification functions on modular scales.
Create one with create()

Example:

create(8, 2, 1);

  `,
    output,
  });

function unlessMS(body, data) {
  if (
    Array.isArray(data) && data.length &&
    data.every((n) => typeof n === "number")
  ) {
    return body;
  }

  return ScaleError(data);
}

/**
 * Update a scale with a calculation mapping to each value.
 *
 * @example Add ten to each scale value
 *
 * ```ts
 * update(n => n + 10, create(4, 2, 1));
 * ```
 *
 * @param {(n: number) => number} calc - the desired calculation to modify each scale value
 * @param {number[]} scale - the scale to update
 * @returns {number[]} A new scale with updated values
 */
export const update = (calc, scale) =>
  unlessMS(scale.map((n) => calc(n)), scale);
#+END_SRC

For each function beyond this point, I'll need to ensure that data passed in is a raw modular
scale. I wrote a template function to tell the interpreter that nothing should be done unless the
data is a modular scale and throw an error reminding the user to =create()= one if they haven't.

*** merge

+ =merge: (...scales: number[][]) => number[]=
+ =...scales: number[][]=: any number of scales to merge

#+BEGIN_SRC deno :tangle "./scale/index.js" :comments link
/**
 * Merge two or more scales into a scale of their unique values.
 *
 * @example Merge scale a with scale b
 *
 * ```ts
 * merge(create(5, 1.5, 1), create(8, 1.25, 1));
 * ```
 *
 * @param {number[][]} scales - the scales to merge
 * @returns {number[]} A new scale of unique values
 */
export const merge = (...scales) =>
  scales.every((scale) => unlessMS(scale, scale)) && [
    ...new Set(scales.reduce((acc, scale) => [...acc, ...scale], [])),
  ].sort((a, b) => a - b);
#+END_SRC

Using a Set guarantees that the merge will only return the unique values in each scale.

*** chunk

+ =chunk: (size: number, scale: number[]) => number[][]=
+ =size: number=: number of values to capture in each chunk
+ =scale: number[]=: the scale you want to chunk

#+BEGIN_SRC deno :tangle "./scale/index.js" :comments link
/**
 * Splits a scale into smaller scales of a given size.
 *
 * @example Split a 30 value scale into 6 chunks of 5 values
 *
 * ```ts
 * chunk(6, create(30, 1.414, 1));
 * ```
 *
 * @param {number} size - the number of values in each chunk
 * @param {number[]} scale - the scale to chunk
 * @returns {number[][]} A new scale of chunked scale values
 */
export const chunk = (size, scale) =>
  unlessMS(
    Array.from(scale).reduceRight(
      (acc, _v, _i, arr) => [...acc, arr.splice(0, size)],
      [],
    ),
    scale,
  );
#+END_SRC

*** units

+ =units: (unit: string, scale: number[]) => string[]=
+ =unit: string=: any valid CSS relative or absolute unit
+ =scale: number[]=: raw value scale for processing

#+BEGIN_SRC deno :tangle "./scale/index.js" :comments link
import { significant } from "../internals/color/convert/setup.js";

const precision = significant.bind(null, 4);

/**
 * Attach units to a raw scale to create a CSS-ready modular scale.
 *
 * @example Output a scale as rems
 *
 * ```ts
 * units("rem", create(7, 1.25, 1));
 * ```
 *
 * @param { "cm" | "mm" | "Q" | "in" | "pc" | "pt" | "px" | "em" | "ex" | "ch" | "rem" | "lh" | "vw" | "vh" | "vmin" | "vmax" } unit - any valid relative or absolute CSS unit
 * @param {number[]} scale - the raw scale to generate from
 * @returns {string[]} A finished modular scale now ready to use
 */
export const units = (unit, scale) =>
  unlessMS(scale.map((n) => `${precision(n)}${unit}`), scale);
#+END_SRC

*** Tests

**** Modular Scale Assertions

Alright. Time to test the scale creation flow and error handling.

#+BEGIN_SRC deno :tangle "./scale/index_test.js" :comments link
import { chunk, create, merge, units, update } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC create: can generate raw modular scales", function () {
  assertEquals(create(6, 1.25, 1), [
    1,
    1.25,
    1.5625,
    1.953125,
    2.44140625,
    3.0517578125,
  ]);
  assertEquals(create(8, 1.5, 1), [
    1,
    1.5,
    2.25,
    3.375,
    5.0625,
    7.59375,
    11.390625,
    17.0859375,
  ]);
  assertEquals(create(10, 2, 1), [
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
    512,
  ]);
});

Deno.test("SPEC update: can update values with an in-place recalculation", function () {
  const scale = create(8, 2, 1);

  assertEquals(update((n) => n + 16, scale), [
    17,
    18,
    20,
    24,
    32,
    48,
    80,
    144,
  ]);
  assertEquals(update((n) => n / 4, scale), [
    0.25,
    0.5,
    1,
    2,
    4,
    8,
    16,
    32,
  ]);
  assertEquals(update((n) => n * 2, scale), [
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
  ]);
});

Deno.test("SPEC merge: can combine values from multiple scales into one scale", function () {
  const a = create(8, 1.5, 1);
  const b = create(6, 1.25, 1);
  const c = create(4, 1.75, 1);

  assertEquals(merge(a, b), [
    1,
    1.25,
    1.5,
    1.5625,
    1.953125,
    2.25,
    2.44140625,
    3.0517578125,
    3.375,
    5.0625,
    7.59375,
    11.390625,
    17.0859375,
  ]);
  assertEquals(merge(a, c), [
    1,
    1.5,
    1.75,
    2.25,
    3.0625,
    3.375,
    5.0625,
    5.359375,
    7.59375,
    11.390625,
    17.0859375,
  ]);
  assertEquals(merge(b, c), [
    1,
    1.25,
    1.5625,
    1.75,
    1.953125,
    2.44140625,
    3.0517578125,
    3.0625,
    5.359375,
  ]);
});

Deno.test("SPEC chunk: can split a larger set of scale values into multiple scales of a given size", function () {
  const [first, second, third, ...rest] = chunk(5, create(24, 1.5, 1));

  assertEquals(first, [1, 1.5, 2.25, 3.375, 5.0625]);
  assertEquals(second, [
    7.59375,
    11.390625,
    17.0859375,
    25.62890625,
    38.443359375,
  ]);
  assertEquals(third, [
    57.6650390625,
    86.49755859375,
    129.746337890625,
    194.6195068359375,
    291.92926025390625,
  ]);
  assertEquals(rest, [
    [
      437.8938903808594,
      656.8408355712891,
      985.2612533569336,
      1477.8918800354004,
      2216.8378200531006,
    ],
    [
      3325.256730079651,
      4987.885095119476,
      7481.8276426792145,
      11222.741464018822,
    ],
  ]);
});

Deno.test("SPEC units: can attach units and output CSS-ready modular scales", function () {
  assertEquals(units("rem", create(6, 1.5, 1)), [
    "1rem",
    "1.5rem",
    "2.25rem",
    "3.375rem",
    "5.063rem",
    "7.594rem",
  ]);
  assertEquals(units("ex", create(4, 2, 1)), [
    "1ex",
    "2ex",
    "4ex",
    "8ex",
  ]);
  assertEquals(units("pt", create(5, 1.25, 12)), [
    "12pt",
    "15pt",
    "18.75pt",
    "23.44pt",
    "29.3pt",
  ]);
});

Deno.test("EDGE: scale modifiers (update, merge, chunk, units) reject empty scales", function () {
  assertThrows(
    () => {
      throw update((n) => n, []);
    },
    undefined,
    "not a modular scale",
  );
  assertThrows(
    () => {
      throw merge([], []);
    },
    undefined,
    "not a modular scale",
  );
  assertThrows(
    () => {
      throw chunk(3, []);
    },
    undefined,
    "not a modular scale",
  );
  assertThrows(
    () => {
      throw units("rem", []);
    },
    undefined,
    "not a modular scale",
  );
});
#+END_SRC

**** Modular Scale Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./scale/index_test.js)
#+END_SRC

#+NAME: scale-test
#+begin_src shell
running 6 tests
test SPEC create: can generate raw modular scales ... ok (6ms)
test SPEC update: can update values with an in-place recalculation ... ok (2ms)
test SPEC merge: can combine values from multiple scales into one scale ... ok (1ms)
test SPEC chunk: can split a larger set of scale values into multiple scales of a given size ... ok (2ms)
test SPEC units: can attach units and output CSS-ready modular scales ... ok (3ms)
test EDGE: scale modifiers (update, merge, chunk, units) reject empty scales ... ok (3ms)

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (18ms)

#+end_src

* Internals

This section documents and implements useful internal functions that aid in developing the core
itself. They are not publicly accessible. The only reason you'd want to read this section is if
you're interested in the nuts and bolts of this project.

** Error Handling (=internals/error.js=)

#+BEGIN_SRC deno :tangle "./internals/error.js" :comments link
/** Error message template */
export function ErrorTemplate(
  { message, reason, suggestion, output } = {
    message: "something went wrong",
    reason: "here's why",
    suggestion: "try this",
    output: undefined,
  },
) {
  throw new Error(`
ERROR: ${message.trimEnd()}
${"=".repeat(60)}
REASON: ${reason.trimEnd()}
TRY: ${suggestion.trimEnd()}
${"-".repeat(60)}
OUTPUT: ${output};
`);
}
#+END_SRC

I believe in the power of good error messages in helping developers solve their own problems. Human-readable errors also decrease the likelihood that you'll need to consult documentation during your workflow.

The format of error messages thrown by the core is straightforward.

#+BEGIN_SRC text
ERROR: something went wrong
============================================================
REASON: here's why
TRY: troubleshooting suggestions
------------------------------------------------------------
OUTPUT: "and what actually happened";
#+END_SRC

** Color
*** Formats (=internals/color/format/index.js=)

QuarkSuite is designed primarily for web technologies and handles all current (and upcoming) CSS color
formats. This section documents how the QSC validates colors and extracts color values.

#+BEGIN_SRC deno :tangle "./internals/color/format/index.js" :comments link
/** Internal format validation/extraction utilities */
export * as hex from "./hex.js";
export * as named from "./named.js";
export * as rgb from "./rgb.js";
export * as hsl from "./hsl.js";
export * as cmyk from "./device-cmyk.js";
export * as hwb from "./hwb.js";
export * as lab from "./lab.js";
export * as lch from "./lch.js";
#+END_SRC

From the format index, you can see at a glance which color formats are currently supported.

**** RGB Hex (=internals/color/format/hex.js=)

Hexadecimal colors are the most common format on the web. Below is a table showing the acceptable
formats in CSS and some examples. I also think of them as color primitives, because hex /begins/ the
conversion chain to other formats.

#+NAME: hex-samples
| Color   | Value     |
|---------+-----------|
| Black   | =#000000=   |
| Gray    | =#808080=   |
| White   | =#ffffff=   |
| Red     | =#ff0000=   |
| Yellow  | =#ffff00=   |
| Green   | =#00ff00=   |
| Cyan    | =#00ffff=   |
| Blue    | =#0000ff=   |
| Magenta | =#ff00ff=   |
| Etc.    | =#ace=      |
|         | =#bea=      |
|         | =#fed=      |
|         | =#face=     |
|         | =#cafe=     |
|         | =#deaded=   |
|         | =#c0ffee=   |
|         | =#4991ccaa= |
|         | =#abcdef68=  |

***** Hex Validator

The regular expression to validate a hex color is short.

#+BEGIN_SRC deno :tangle "./internals/color/format/hex.js" :comments link
/** Validate: hex color */
export const validate = (color) => /^#([\da-f]{3,4}){1,2}$/i.test(color);
#+END_SRC

Let's see if all the colors defined in the format table pass:

#+BEGIN_SRC deno :results output code replace :allow read :var hexTable=hex-samples
const hex = await import(`${Deno.cwd()}/internals/color/format/hex.js`);
const colors = hexTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => hex.validate(color)))
#+END_SRC

#+NAME: valid-hex
#+begin_src deno
const colors = [
  "#000000",   "#808080",
  "#ffffff",   "#ff0000",
  "#ffff00",   "#00ff00",
  "#00ffff",   "#0000ff",
  "#ff00ff",   "#ace",
  "#bea",      "#fed",
  "#face",     "#cafe",
  "#deaded",   "#c0ffee",
  "#4991ccaa", "#abcdef68"
]
#+end_src

***** Hex Value Extractor

Now, that I know I have valid hex colors, I need to be able to extract their RGB(A) channels.

The first step is enforcing uniformity. To prevent any surprises, I'm going to simply expand hex
color shorthand =#RGB(A)= to a full hex color =#RRGGBB(AA)=.

#+BEGIN_SRC deno :tangle "./internals/color/format/hex.js" :comments link
/** Expand hex shorthand into full hex color */
function expander(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

Having secured uniform input, I'm ready to extract the channel values for processing.

The only thing to do here is remove the =#= and match the channel values with a regular expression.

#+BEGIN_SRC deno :tangle "./internals/color/format/hex.js" :comments link
/** Extract: hex channel values */
export const extract = (hex) => expander(hex).match(/[\da-f]{2}/g);
#+END_SRC

Then, I'm going to test that the channel values are plucked as =[R, G, B, A]=:

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hex = await import (`${Deno.cwd()}/internals/color/format/hex.js`);

<<valid-hex>>

console.log("const colors =", colors.map((color) => ({color, values: hex.extract(color)})));
#+END_SRC

#+NAME: hex-values
#+begin_src deno
const colors = [
  { color: "#000000", values: [ "00", "00", "00" ] },
  { color: "#808080", values: [ "80", "80", "80" ] },
  { color: "#ffffff", values: [ "ff", "ff", "ff" ] },
  { color: "#ff0000", values: [ "ff", "00", "00" ] },
  { color: "#ffff00", values: [ "ff", "ff", "00" ] },
  { color: "#00ff00", values: [ "00", "ff", "00" ] },
  { color: "#00ffff", values: [ "00", "ff", "ff" ] },
  { color: "#0000ff", values: [ "00", "00", "ff" ] },
  { color: "#ff00ff", values: [ "ff", "00", "ff" ] },
  { color: "#ace", values: [ "aa", "cc", "ee" ] },
  { color: "#bea", values: [ "bb", "ee", "aa" ] },
  { color: "#fed", values: [ "ff", "ee", "dd" ] },
  { color: "#face", values: [ "ff", "aa", "cc", "ee" ] },
  { color: "#cafe", values: [ "cc", "aa", "ff", "ee" ] },
  { color: "#deaded", values: [ "de", "ad", "ed" ] },
  { color: "#c0ffee", values: [ "c0", "ff", "ee" ] },
  { color: "#4991ccaa", values: [ "49", "91", "cc", "aa" ] },
  { color: "#abcdef68", values: [ "ab", "cd", "ef", "68" ] }
]
#+end_src

**** W3C-X11 (=internals/color/format/named.js=)

Named colors are simple to validate. It's a matter of matching the name with its hex value in the
=X11Colors= lookup table as a boolean.

#+BEGIN_SRC deno :tangle "./internals/color/format/named.js" :comments link
import { X11Colors } from "../../../data/color/w3c-x11.js";

/** Validate: W3C X11 named colors */
export const validate = (color) => !!X11Colors[color];
#+END_SRC

**** Functional RGB (=internals/color/format/rgb.js=)

The functional RGB syntax is more complex and allows for more variation in the format. Quarks System
Core supports the legacy format as well as the newer space-separated ones.

#+NAME: rgb-samples
| Color   | Value                    |
|---------+--------------------------|
| Black   | =rgb(0, 0, 0)=             |
| Gray    | =rgb(128, 128, 128)=       |
| White   | =rgb(255, 255, 255)=       |
| Red     | =rgb(255, 0, 0)=           |
| Yellow  | =rgb(255, 255, 0)=         |
| Green   | =rgb(0, 255, 0)=           |
| Cyan    | =rgb(0, 255, 255)=         |
| Blue    | =rgb(0, 0, 255)=           |
| Magenta | =rgb(255, 0, 255)=         |
| Etc.    | =rgb(33, 199, 95)=         |
|         | =rgb(19, 114, 220)=        |
|         | =rgb(10%, 40.4%, 49.9%)=   |
|         | =rgb(200 138 39)=          |
|         | =rgb(31 88 49 / 0.8)=      |
|         | =rgba(110, 33, 110, 0.75)= |
|         | =rgba(10, 119, 30, 30%)=   |

***** RGB Validator

Validating the functional RGB is similarly complex, but the regular expression can be broken down to
its unique and repeating parts and then assembled with the =RegExp.source= property as a new =RegExp=
object.

#+BEGIN_SRC deno :tangle "./internals/color/format/rgb.js" :comments link
/** Validate: functional RGB format */
export function validate(color) {
  // RGB regexp

  // prefix: "rgb(" || "rgba("
  // R && G && B: float<0-100>% || int<0-255>
  let R, G, B;
  R = G = B =
    /(?:(?:100%|(?:\d\.?\d?){1,}%)|(?:25[0-5]|24[0-4][0-9]|1[0-9]{2}|\d{1,}|0))/;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: ", " || " " || " /"
  const channelSep = /(?:[\s,]+)/;
  const alphaSep = /(?:[,\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^rgba?\\(",
      R.source,
      channelSep.source,
      G.source,
      channelSep.source,
      B.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Next up is seeing if the format tests pass.

#+BEGIN_SRC deno :results output code replace :allow read :var rgbTable=rgb-samples
const rgb = await import(`${Deno.cwd()}/internals/color/format/rgb.js`);
const colors = rgbTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => rgb.validate(color)))
#+END_SRC

#+NAME: valid-rgb
#+begin_src deno
const colors = [
  "rgb(0, 0, 0)",
  "rgb(128, 128, 128)",
  "rgb(255, 255, 255)",
  "rgb(255, 0, 0)",
  "rgb(255, 255, 0)",
  "rgb(0, 255, 0)",
  "rgb(0, 255, 255)",
  "rgb(0, 0, 255)",
  "rgb(255, 0, 255)",
  "rgb(33, 199, 95)",
  "rgb(19, 114, 220)",
  "rgb(10%, 40.4%, 49.9%)",
  "rgb(200 138 39)",
  "rgb(31 88 49 / 0.8)",
  "rgba(110, 33, 110, 0.75)",
  "rgba(10, 119, 30, 30%)"
]
#+end_src

All clear!

***** RGB Extractor

The next step is ensuring the channel/alpha values can be extracted.

#+BEGIN_SRC deno :tangle "./internals/color/format/rgb.js" :comments link
/** Extract: RGB channel/alpha values */
export const extract = (rgb) => rgb.match(/([\d.]%?)+/g);
#+END_SRC

The extractor preserves the =%= because it will be properly converted to a fraction for later
calculations. Since the extractor is only used with valid RGB colors, the match pattern does not
need to be intensive.

Now, I'll test that the values are properly pulled.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/internals/color/format/rgb.js`);

<<valid-rgb>>

console.log("const colors =", colors.map((color) => ({ color, values: rgb.extract(color) })));
#+END_SRC

#+NAME: rgb-values
#+begin_src deno
const colors = [
  { color: "rgb(0, 0, 0)", values: [ "0", "0", "0" ] },
  { color: "rgb(128, 128, 128)", values: [ "128", "128", "128" ] },
  { color: "rgb(255, 255, 255)", values: [ "255", "255", "255" ] },
  { color: "rgb(255, 0, 0)", values: [ "255", "0", "0" ] },
  { color: "rgb(255, 255, 0)", values: [ "255", "255", "0" ] },
  { color: "rgb(0, 255, 0)", values: [ "0", "255", "0" ] },
  { color: "rgb(0, 255, 255)", values: [ "0", "255", "255" ] },
  { color: "rgb(0, 0, 255)", values: [ "0", "0", "255" ] },
  { color: "rgb(255, 0, 255)", values: [ "255", "0", "255" ] },
  { color: "rgb(33, 199, 95)", values: [ "33", "199", "95" ] },
  { color: "rgb(19, 114, 220)", values: [ "19", "114", "220" ] },
  { color: "rgb(10%, 40.4%, 49.9%)", values: [ "10%", "40.4%", "49.9%" ] },
  { color: "rgb(200 138 39)", values: [ "200", "138", "39" ] },
  { color: "rgb(31 88 49 / 0.8)", values: [ "31", "88", "49", "0.8" ] },
  { color: "rgba(110, 33, 110, 0.75)", values: [ "110", "33", "110", "0.75" ] },
  { color: "rgba(10, 119, 30, 30%)", values: [ "10", "119", "30", "30%" ] }
]
#+end_src

**** Functional HSL (=internals/color/format/hsl.js=)

HSL is well-loved by designers for being a lot more intuitive than RGB. It explicitly allows
setting:

+ Hue (H): An angle corresponding to a color's position on an RGB color wheel. =0= degrees
  means red, green sits at =120= degrees, and blue sits at =240=
+ Saturation (S): A percentage value corresponding to a color's vibrance or chroma. =0%= indicates a
  fully unsaturated color (yielding gray). =100%= indicates a fully saturated color
+ Lightness/Luminance (L): A percentage value corresponding to a color's brightness. At =50%= a color
  is normalized. =0%= yields pure black and =100%= yields pure white

CSS also defines several angle units for the hue. All of which QuarkSuite supports.

#+NAME: hsl-samples
| Color   | Value                         |
|---------+-------------------------------|
| Black   | =hsl(0, 0%, 0%)=                |
| Gray    | =hsl(0, 0%, 50%)=               |
| White   | =hsl(0, 0%, 100%)=              |
| Red     | =hsl(0, 100%, 50%)=             |
| Yellow  | =hsl(60, 100%, 50%)=            |
| Green   | =hsl(120, 100%, 50%)=           |
| Cyan    | =hsl(180, 100%, 50%)=           |
| Blue    | =hsl(240, 100%, 50%)=           |
| Magenta | =hsl(300, 100%, 50%)=           |
| Etc.    | =hsl(38, 78%, 40%)=             |
|         | =hsl(3 88% 70%)=                |
|         | =hsl(189 63% 85% / 0.71)=       |
|         | =hsla(1.5rad, 73%, 10%, 0.831)= |
|         | =hsl(320grad 89% 36% / 79%)=    |
|         | =hsl(0.36turn 83% 90%)=       |

***** HSL Validator

From here, you'll start seeing a lot of repetition in the validation expressions.

Validating HSL has a similar pattern to validating RGB. In fact, many of the regular expression
fragments are the same.

#+BEGIN_SRC deno :tangle "./internals/color/format/hsl.js" :comments link
/** Validate: functional HSL format */
export function validate(color) {
  // HSL regexp

  // prefix: "hsl(" || "hsla("
  // hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
  const hue = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;
  // saturation && lightness: float<0-100>%
  const saturation = /(?:(?:100%|(?:\d\.?\d?){1,}%))/;
  const lightness = saturation;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: ", " || " " || " /"
  const valueSep = /(?:[\s,]+)/;
  const alphaSep = /(?:[,\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^hsla?\\(",
      hue.source,
      valueSep.source,
      saturation.source,
      valueSep.source,
      lightness.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Now, I'll perform the tests:

#+BEGIN_SRC deno :results output code replace :allow read :var hslTable=hsl-samples
const hsl = await import(`${Deno.cwd()}/internals/color/format/hsl.js`);
const colors = hslTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => hsl.validate(color)))
#+END_SRC

#+NAME: valid-hsl
#+begin_src deno
const colors = [
  "hsl(0, 0%, 0%)",
  "hsl(0, 0%, 50%)",
  "hsl(0, 0%, 100%)",
  "hsl(0, 100%, 50%)",
  "hsl(60, 100%, 50%)",
  "hsl(120, 100%, 50%)",
  "hsl(180, 100%, 50%)",
  "hsl(240, 100%, 50%)",
  "hsl(300, 100%, 50%)",
  "hsl(38, 78%, 40%)",
  "hsl(3 88% 70%)",
  "hsl(189 63% 85% / 0.71)",
  "hsla(1.5rad, 73%, 10%, 0.831)",
  "hsl(320grad 89% 36% / 79%)",
  "hsl(0.36turn 83% 90%)"
]
#+end_src

***** HSL Extractor

Next, I need to be able extract HSL values.

#+BEGIN_SRC deno :tangle "./internals/color/format/hsl.js" :comments link
/** Extract: HSL values */
export const extract = (hsl) => hsl.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

Again, the HSL extractor is very similar to the RGB extractor. The only difference being that I'm
extracting the hue units along with percentages.

Finally, I'll test that the values are extracted.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hsl = await import(`${Deno.cwd()}/internals/color/format/hsl.js`);

<<valid-hsl>>

console.log("const colors =", colors.map((color) => ({ color, values: hsl.extract(color) })));
#+END_SRC

#+NAME: hsl-values
#+begin_src deno
const colors = [
  { color: "hsl(0, 0%, 0%)", values: [ "0", "0%", "0%" ] },
  { color: "hsl(0, 0%, 50%)", values: [ "0", "0%", "50%" ] },
  { color: "hsl(0, 0%, 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hsl(0, 100%, 50%)", values: [ "0", "100%", "50%" ] },
  { color: "hsl(60, 100%, 50%)", values: [ "60", "100%", "50%" ] },
  { color: "hsl(120, 100%, 50%)", values: [ "120", "100%", "50%" ] },
  { color: "hsl(180, 100%, 50%)", values: [ "180", "100%", "50%" ] },
  { color: "hsl(240, 100%, 50%)", values: [ "240", "100%", "50%" ] },
  { color: "hsl(300, 100%, 50%)", values: [ "300", "100%", "50%" ] },
  { color: "hsl(38, 78%, 40%)", values: [ "38", "78%", "40%" ] },
  { color: "hsl(3 88% 70%)", values: [ "3", "88%", "70%" ] },
  { color: "hsl(189 63% 85% / 0.71)", values: [ "189", "63%", "85%", "0.71" ] },
  {
    color: "hsla(1.5rad, 73%, 10%, 0.831)",
    values: [ "1.5rad", "73%", "10%", "0.831" ]
  },
  { color: "hsl(320grad 89% 36% / 79%)", values: [ "320grad", "89%", "36%", "79%" ] },
  { color: "hsl(0.36turn 83% 90%)", values: [ "0.36turn", "83%", "90%" ] }
]
#+end_src

The formats documented beyond this point are brand new territory for the core module and unsupported
in QuarkSuite 1.

**** Device CMYK (=internals/color/format/device-cmyk.js=)

=device-cmyk()= is a prospective format documented in the [[https://www.w3.org/TR/css-color-4/#device-cmyk][current CSS Color Module 4 draft]]. CMYK in
general is a color space typically calibrated for printed media.

+ Cyan (C): the amount of cyan ink in the color
+ Magenta (M): the amount of magenta ink in the color
+ Yellow (Y): the amount of yellow ink in the color
+ BlacK (K): the amount of black ink in the color

It's important to note: as a newer CSS color functional format, =device-cmyk()= doesn't bother with
the older comma-separated syntax, so neither does the Quarks System Core. The same carries for all
color formats beyond this point.

#+NAME: cmyk-samples
| Color   | Value                             |
|---------+-----------------------------------|
| Black   | =device-cmyk(0% 0% 0% 100%)=        |
| Gray    | =device-cmyk(0% 0% 0% 50%)=         |
| White   | =device-cmyk(0% 0% 0% 0%)=          |
| Red     | =device-cmyk(0% 100% 100% 0%)=      |
| Yellow  | =device-cmyk(0% 0% 100% 0%)=        |
| Green   | =device-cmyk(100% 0% 100% 0%)=      |
| Cyan    | =device-cmyk(100% 0% 0% 0%)=        |
| Blue    | =device-cmyk(100% 100% 0% 0%)=      |
| Magenta | =device-cmyk(0% 100% 0% 0%)=        |
| Etc.    | =device-cmyk(37% 63% 0 0)=          |
|         | =device-cmyk(50% 25% 10% 0)=        |
|         | =device-cmyk(0.77 0.33 0 0)=        |
|         | =device-cmyk(0.8 0 0.4 0.13 / 0.8)= |
|         | =device-cmyk(25% 75% 8% 3% / 81.3%)= |

***** CMYK Validator

The validation for CMYK in CSS is thankfully simple.

#+BEGIN_SRC deno :tangle "./internals/color/format/device-cmyk.js" :comments link
/** Validate: CMYK format */
export function validate(color) {
  // CMYK regexp

  // prefix: "device-cymk("
  // c & m & y & k & a: float<0-1> || float<0-100>%
  let c, m, y, k, alpha;
  c = m = y = k = alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s]+)/;
  const alphaSep = /(?:[\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^device-cmyk\\(",
      c.source,
      valueSep.source,
      m.source,
      valueSep.source,
      y.source,
      valueSep.source,
      k.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Now, on to the format tests.

#+BEGIN_SRC deno :results output code replace :allow read :var cmykTable=cmyk-samples
const cmyk = await import(`${Deno.cwd()}/internals/color/format/device-cmyk.js`);
const colors = cmykTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => cmyk.validate(color)));
#+END_SRC

#+NAME: valid-cmyk
#+begin_src deno
const colors = [
  "device-cmyk(0% 0% 0% 100%)",
  "device-cmyk(0% 0% 0% 50%)",
  "device-cmyk(0% 0% 0% 0%)",
  "device-cmyk(0% 100% 100% 0%)",
  "device-cmyk(0% 0% 100% 0%)",
  "device-cmyk(100% 0% 100% 0%)",
  "device-cmyk(100% 0% 0% 0%)",
  "device-cmyk(100% 100% 0% 0%)",
  "device-cmyk(0% 100% 0% 0%)",
  "device-cmyk(37% 63% 0 0)",
  "device-cmyk(50% 25% 10% 0)",
  "device-cmyk(0.77 0.33 0 0)",
  "device-cmyk(0.8 0 0.4 0.13 / 0.8)",
  "device-cmyk(25% 75% 8% 3% / 81.3%)"
]
#+end_src

***** CMYK Extractor

From here, the extractor is another one-liner.

#+BEGIN_SRC deno :tangle "./internals/color/format/device-cmyk.js" :comments link
/** Extract: CMYK values */
export const extract = (cmyk) => cmyk.match(/([\d.]+)%?/g);
#+END_SRC

Finally, the extraction tests:

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const cmyk = await import(`${Deno.cwd()}/internals/color/format/device-cmyk.js`);

<<valid-cmyk>>

console.log("const colors =", colors.map((color) => ({ color, values: cmyk.extract(color) })));
#+END_SRC

#+NAME: cmyk-values
#+begin_src deno
const colors = [
  { color: "device-cmyk(0% 0% 0% 100%)", values: [ "0%", "0%", "0%", "100%" ] },
  { color: "device-cmyk(0% 0% 0% 50%)", values: [ "0%", "0%", "0%", "50%" ] },
  { color: "device-cmyk(0% 0% 0% 0%)", values: [ "0%", "0%", "0%", "0%" ] },
  { color: "device-cmyk(0% 100% 100% 0%)", values: [ "0%", "100%", "100%", "0%" ] },
  { color: "device-cmyk(0% 0% 100% 0%)", values: [ "0%", "0%", "100%", "0%" ] },
  { color: "device-cmyk(100% 0% 100% 0%)", values: [ "100%", "0%", "100%", "0%" ] },
  { color: "device-cmyk(100% 0% 0% 0%)", values: [ "100%", "0%", "0%", "0%" ] },
  { color: "device-cmyk(100% 100% 0% 0%)", values: [ "100%", "100%", "0%", "0%" ] },
  { color: "device-cmyk(0% 100% 0% 0%)", values: [ "0%", "100%", "0%", "0%" ] },
  { color: "device-cmyk(37% 63% 0 0)", values: [ "37%", "63%", "0", "0" ] },
  { color: "device-cmyk(50% 25% 10% 0)", values: [ "50%", "25%", "10%", "0" ] },
  { color: "device-cmyk(0.77 0.33 0 0)", values: [ "0.77", "0.33", "0", "0" ] },
  {
    color: "device-cmyk(0.8 0 0.4 0.13 / 0.8)",
    values: [ "0.8", "0", "0.4", "0.13", "0.8" ]
  },
  {
    color: "device-cmyk(25% 75% 8% 3% / 81.3%)",
    values: [ "25%", "75%", "8%", "3%", "81.3%" ]
  }
]
#+end_src

And now it's on to the next one.

**** Functional HWB (=internals/color/format/hwb.js=)

HWB is short for Hue-Whiteness-Blackness. It's an [[https://www.w3.org/TR/css-color-4/#the-hwb-notation][upcoming color format similar to HSL]] but even
easier to use. It's the format of choice for a variety of browser color picker implementations.

+ Hue (H): works the same as it does in the HSL format
+ Whiteness (W): a percentage value corresponding with how much white to mix with the hue
+ Blackness (B): a percentage value corresponding with how much black to mix with the hue

When W and B are mixed equal amounts, they yield gray. When both are =100%=, the color is achromatic.

#+NAME: hwb-samples
| Color   | Value                     |
|---------+---------------------------|
| Black   | =hwb(0 0% 100%)=            |
| Gray    | =hwb(0 100% 100%)=          |
| White   | =hwb(0 100% 0%)=            |
| Red     | =hwb(0 0% 0%)=              |
| Yellow  | =hwb(60 0% 0%)=             |
| Green   | =hwb(120 0% 0%)=            |
| Cyan    | =hwb(180 0% 0%)=            |
| Blue    | =hwb(240 0% 0%)=            |
| Magenta | =hwb(300 0% 0%)=            |
| Etc.    | =hwb(188 20% 3%)=           |
|         | =hwb(3.1rad 50% 0%)=        |
|         | =hwb(183grad 5% 15% / 0.5)= |
|         | =hwb(0.8turn 38% 99%)=      |

***** HWB Validator

The HWB validator expressions are nearly identical to the HSL validator.

#+BEGIN_SRC deno :tangle "./internals/color/format/hwb.js" :comments link
/** Validate: functional HWB format */
export function validate(color) {
  // HWB regexp

  // prefix: "hwb("
  // hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
  const hue = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;
  // whitness && blackness: float<0-100>%
  const whiteness = /(?:(?:100%|(?:\d\.?\d?){1,}%))/;
  const blackness = whiteness;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s,]+)/;
  const alphaSep = /(?:[,\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^hwb\\(",
      hue.source,
      valueSep.source,
      whiteness.source,
      valueSep.source,
      blackness.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Alright, now the format tests.

#+BEGIN_SRC deno :results output code replace :allow read :var hwbTable=hwb-samples
const hwb = await import(`${Deno.cwd()}/internals/color/format/hwb.js`);
const colors = hwbTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => hwb.validate(color)))
#+END_SRC

#+NAME: valid-hwb
#+begin_src deno
const colors = [
  "hwb(0 0% 100%)",
  "hwb(0 100% 100%)",
  "hwb(0 100% 0%)",
  "hwb(0 0% 0%)",
  "hwb(60 0% 0%)",
  "hwb(120 0% 0%)",
  "hwb(180 0% 0%)",
  "hwb(240 0% 0%)",
  "hwb(300 0% 0%)",
  "hwb(188 20% 3%)",
  "hwb(3.1rad 50% 0%)",
  "hwb(183grad 5% 15% / 0.5)",
  "hwb(0.8turn 38% 99%)"
]
#+end_src

***** HWB Extractor

The value extractor for HWB is identical to the one for HSL.

#+BEGIN_SRC deno :tangle "./internals/color/format/hwb.js" :comments link
/** Extract: HWB values */
export const extract = (hwb) => hwb.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

Finally, the tests for value extraction.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hwb = await import(`${Deno.cwd()}/internals/color/format/hwb.js`);

<<valid-hwb>>

console.log("const colors =", colors.map((color) => ({ color, values: hwb.extract(color) })));
#+END_SRC

#+NAME: hwb-values
#+begin_src deno
const colors = [
  { color: "hwb(0 0% 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hwb(0 100% 100%)", values: [ "0", "100%", "100%" ] },
  { color: "hwb(0 100% 0%)", values: [ "0", "100%", "0%" ] },
  { color: "hwb(0 0% 0%)", values: [ "0", "0%", "0%" ] },
  { color: "hwb(60 0% 0%)", values: [ "60", "0%", "0%" ] },
  { color: "hwb(120 0% 0%)", values: [ "120", "0%", "0%" ] },
  { color: "hwb(180 0% 0%)", values: [ "180", "0%", "0%" ] },
  { color: "hwb(240 0% 0%)", values: [ "240", "0%", "0%" ] },
  { color: "hwb(300 0% 0%)", values: [ "300", "0%", "0%" ] },
  { color: "hwb(188 20% 3%)", values: [ "188", "20%", "3%" ] },
  { color: "hwb(3.1rad 50% 0%)", values: [ "3.1rad", "50%", "0%" ] },
  { color: "hwb(183grad 5% 15% / 0.5)", values: [ "183grad", "5%", "15%", "0.5" ] },
  { color: "hwb(0.8turn 38% 99%)", values: [ "0.8turn", "38%", "99%" ] }
]
#+end_src

**** Functional CIE Lab (=internals/color/format/lab.js=)

The CSS Color Module Level 4 is currently drafting [[https://www.w3.org/TR/css-color-4/#lab-colors][support for device-independent color
formats]]. Quarks System Core supports both.

First up is the CIE Lab (often called Lab for short) color format. The format specification is better
explained on the linked W3C page above, but I'll summarize the components:

+ Lightness (L): a percentage value which, unlike HSL, is /not/ capped at =100%= for this space
+ hues (*a): magenta-red when positive, its complement when negative
+ hues (*b): yellow when positive, its complement when negative

The hue axes are unbound, but for use with the RGB space /must/ cap at =Â±128=.

#+NAME: lab-samples
| Color   | Value                           |
|---------+---------------------------------|
| Black   | =lab(0% 0 0)=                     |
| Gray    | =lab(53.59% 0 0)=                 |
| White   | =lab(100% 0 0)=                   |
| Red     | =lab(54.29% 80.81 69.89)=         |
| Yellow  | =lab(97.6% -15.75 93.39)=         |
| Green   | =lab(87.82% -79.29 80.99)=        |
| Cyan    | =lab(90.67% -50.67 -14.96)=       |
| Blue    | =lab(29.57% 68.3 -112.03)=        |
| Magenta | =lab(60.17% 93.55 -60.5)=         |
| Etc.    | =lab(49.18% 38.1 -110.33)=        |
|         | =lab(91.3% -93 14)=               |
|         | =lab(83.119% 49.34 -3.99 / 0.75)= |
|         | =lab(199% 38 13 / 78%)=         |

***** CIE Lab Validator

The Lab validator is not complex. It reuses the alpha validation expression and modifies the RGB
channel validation expression slightly.

#+BEGIN_SRC deno :tangle "./internals/color/format/lab.js" :comments link
/** Validate: functional CIE Lab format */
export function validate(color) {
  // CIE Lab regexp

  // prefix: "lab("
  // L: float<0->%
  const L = /(?:(?:\d\.?\d?){1,}%)/;
  // a && b: -?int<0-128>
  let a, b;
  a = b = /(?:-?(?:128|(?:1[0-2][0-8]|(?:\d.?\d?){1,})))/;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s]+)/;
  const alphaSep = /(?:[\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^lab\\(",
      L.source,
      valueSep.source,
      a.source,
      valueSep.source,
      b.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Now, it's validator testing time.

#+BEGIN_SRC deno :results output code replace :allow read :var labTable=lab-samples
const lab = await import(`${Deno.cwd()}/internals/color/format/lab.js`);
const colors = labTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => lab.validate(color)))
#+END_SRC

#+NAME: valid-lab
#+begin_src deno
const colors = [
  "lab(0% 0 0)",
  "lab(53.59% 0 0)",
  "lab(100% 0 0)",
  "lab(54.29% 80.81 69.89)",
  "lab(97.6% -15.75 93.39)",
  "lab(87.82% -79.29 80.99)",
  "lab(90.67% -50.67 -14.96)",
  "lab(29.57% 68.3 -112.03)",
  "lab(60.17% 93.55 -60.5)",
  "lab(49.18% 38.1 -110.33)",
  "lab(91.3% -93 14)",
  "lab(83.119% 49.34 -3.99 / 0.75)",
  "lab(199% 38 13 / 78%)"
]
#+end_src

Good to go.

***** CIE Lab Extractor

The CIE Lab value extractor is a slight modification from the HSL extractor. The CIE Lab extractor
needs to be able to capture negative and positive values as well as percentages.

#+BEGIN_SRC deno :tangle "./internals/color/format/lab.js" :comments link
/** Extract: CIE Lab values */
export const extract = (lab) => lab.match(/(-?[\d.]%?)+/g);
#+END_SRC

Time to test it.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lab = await import(`${Deno.cwd()}/internals/color/format/lab.js`);

<<valid-lab>>

console.log("const colors =", colors.map((color) => ({ color, values: lab.extract(color) })));
#+END_SRC

#+NAME: lab-values
#+begin_src deno
const colors = [
  { color: "lab(0% 0 0)", values: [ "0%", "0", "0" ] },
  { color: "lab(53.59% 0 0)", values: [ "53.59%", "0", "0" ] },
  { color: "lab(100% 0 0)", values: [ "100%", "0", "0" ] },
  { color: "lab(54.29% 80.81 69.89)", values: [ "54.29%", "80.81", "69.89" ] },
  { color: "lab(97.6% -15.75 93.39)", values: [ "97.6%", "-15.75", "93.39" ] },
  { color: "lab(87.82% -79.29 80.99)", values: [ "87.82%", "-79.29", "80.99" ] },
  { color: "lab(90.67% -50.67 -14.96)", values: [ "90.67%", "-50.67", "-14.96" ] },
  { color: "lab(29.57% 68.3 -112.03)", values: [ "29.57%", "68.3", "-112.03" ] },
  { color: "lab(60.17% 93.55 -60.5)", values: [ "60.17%", "93.55", "-60.5" ] },
  { color: "lab(49.18% 38.1 -110.33)", values: [ "49.18%", "38.1", "-110.33" ] },
  { color: "lab(91.3% -93 14)", values: [ "91.3%", "-93", "14" ] },
  {
    color: "lab(83.119% 49.34 -3.99 / 0.75)",
    values: [ "83.119%", "49.34", "-3.99", "0.75" ]
  },
  { color: "lab(199% 38 13 / 78%)", values: [ "199%", "38", "13", "78%" ] }
]
#+end_src

**** Functional CIE LCH (=internals/color/format/lch.js=)

The CIE LCH color space is another device-independent color format with added support in the CSS Color
Module Level 4 spec. It's an offshoot of CIE Lab designed to be a little more useful for people. It
consists of:

+ Lightness (L): a percentage value interpreted identically to CIE Lab lightness
+ Chroma (C): a value corresponding to the amount of color desired
+ Hue (H): interpreted similar to HSL, but the angles map to the *a/*b axes

The chroma is theoretically boundless, but in everyday use caps at =230=. The hues at =0deg= and =180deg=
map to magenta-red and green-cyan, respectively. The hues at =90deg= and =270deg= map to a mustard
yellow and sky blue, respectively.

#+NAME: lch-samples
| Color   | Value                              |
|---------+------------------------------------|
| Black   | =lch(0% 0 0)=                        |
| Gray    | =lch(53.59% 0 0)=                    |
| White   | =lch(100% 0 0)=                      |
| Red     | =lch(54.29% 106.84 40.855)=          |
| Yellow  | =lch(97.6% 94.709 99.573)=           |
| Green   | =lch(87.82% 113.34 134.39)=          |
| Cyan    | =lch(90.67% 52.832 196.45)=          |
| Blue    | =lch(29.57% 131.21 301.369)=         |
| Magenta | =lch(60.17% 111.41 327.109)=         |
| Etc.    | =lch(53.31% 89.31 200)=              |
|         | =lch(89.1% 167.34 3.6rad / 0.99)=    |
|         | =lch(24.494% 74.9 193grad)=          |
|         | =lch(47.39% 111.193 0.62turn / 75%)= |

***** CIE LCH Validator

As a refinement of CIE Lab, the CIE LCH validator is a slightly modified implementation. It reuses the
CIE Lab lightness expression but also pulls in the HSL hue expression. They accept the same input
even if they don't function the same way.

#+BEGIN_SRC deno :tangle "./internals/color/format/lch.js" :comments link
/** Validate: functional CIE LCH format */
export function validate(color) {
  // CIE LCH regexp

  // prefix: "lch("
  // lightness: float<0->%
  const lightness = /(?:(?:\d\.?\d?){1,}%)/;
  // chroma: int<0-230>
  const chroma = /(?:(?:230|(?:2[0-2][0-9]|1[0-9][0-9])|(?:\d.?\d?){1,}))/;
  // hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
  const hue = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s]+)/;
  const alphaSep = /(?:[\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^lch\\(",
      lightness.source,
      valueSep.source,
      chroma.source,
      valueSep.source,
      hue.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

And it's format validation test time.

#+BEGIN_SRC deno :results output code replace :allow read :var lchTable=lch-samples
const lch = await import(`${Deno.cwd()}/internals/color/format/lch.js`);
const colors = lchTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => lch.validate(color)))
#+END_SRC

#+NAME: valid-lch
#+begin_src deno
const colors = [
  "lch(0% 0 0)",
  "lch(53.59% 0 0)",
  "lch(100% 0 0)",
  "lch(54.29% 106.84 40.855)",
  "lch(97.6% 94.709 99.573)",
  "lch(87.82% 113.34 134.39)",
  "lch(90.67% 52.832 196.45)",
  "lch(29.57% 131.21 301.369)",
  "lch(60.17% 111.41 327.109)",
  "lch(53.31% 89.31 200)",
  "lch(89.1% 167.34 3.6rad / 0.99)",
  "lch(24.494% 74.9 193grad)",
  "lch(47.39% 111.193 0.62turn / 75%)"
]
#+end_src

***** CIE LCH Extractor

The CIE LCH extractor is identical to the HSL extractor.

#+BEGIN_SRC deno :tangle "./internals/color/format/lch.js" :comments link
/** Extract: CIE LCH values */
export const extract = (lch) => lch.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

Now, I'll set up some extraction tests.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lch = await import(`${Deno.cwd()}/internals/color/format/lch.js`);

<<valid-lch>>

console.log("const colors =", colors.map((color) => ({ color, values: lch.extract(color) })));
#+END_SRC

#+NAME: lch-values
#+begin_src deno
const colors = [
  { color: "lch(0% 0 0)", values: [ "0%", "0", "0" ] },
  { color: "lch(53.59% 0 0)", values: [ "53.59%", "0", "0" ] },
  { color: "lch(100% 0 0)", values: [ "100%", "0", "0" ] },
  { color: "lch(54.29% 106.84 40.855)", values: [ "54.29%", "106.84", "40.855" ] },
  { color: "lch(97.6% 94.709 99.573)", values: [ "97.6%", "94.709", "99.573" ] },
  { color: "lch(87.82% 113.34 134.39)", values: [ "87.82%", "113.34", "134.39" ] },
  { color: "lch(90.67% 52.832 196.45)", values: [ "90.67%", "52.832", "196.45" ] },
  { color: "lch(29.57% 131.21 301.369)", values: [ "29.57%", "131.21", "301.369" ] },
  { color: "lch(60.17% 111.41 327.109)", values: [ "60.17%", "111.41", "327.109" ] },
  { color: "lch(53.31% 89.31 200)", values: [ "53.31%", "89.31", "200" ] },
  {
    color: "lch(89.1% 167.34 3.6rad / 0.99)",
    values: [ "89.1%", "167.34", "3.6rad", "0.99" ]
  },
  { color: "lch(24.494% 74.9 193grad)", values: [ "24.494%", "74.9", "193grad" ] },
  {
    color: "lch(47.39% 111.193 0.62turn / 75%)",
    values: [ "47.39%", "111.193", "0.62turn", "75%" ]
  }
]
#+end_src

And that's it. Full support for validating and extracting the values of all current (and future) CSS
color formats. Not very useful  by itself, so I'm going to write functionality to convert between them.

*** Conversion (=internals/color/convert/index.js=)

The internal color conversion functions are organized by format. They follow a convention of
=inputFormat.outputFormat(color)= this allows them to easily be composed in a logical order to create
the higher level color conversion utilities exposed in the public API.

Each implementation assumes extracted color values instead of a full color. This is to ensure color
formatting functions remain separate from conversion functions for the reasons demonstrated in the API.

#+BEGIN_SRC deno :tangle "./internals/color/convert/index.js" :comments link
/** Internal color conversion utilities */
export * as hex from "./hex.js";
export * as named from "./named.js";
export * as rgb from "./rgb.js";
export * as hsl from "./hsl.js";
export * as cmyk from "./device-cmyk.js";
export * as hwb from "./hwb.js";
export * as lab from "./lab.js";
export * as lch from "./lch.js";
#+END_SRC

**** Setup (=internals/color/convert/setup.js=)

Before I write color conversion functions, I need some helpers to streamline the process.

***** Hex RGB Fragments

As I wrote earlier, I consider hex colors on the web color primitives. They're the starting point
of all conversions because hex colors can only be directly converted to functional RGB which begins
the conversion chain for other formats.

#+BEGIN_SRC deno :tangle "./internals/color/convert/setup.js" :comments link
/** Helper for converting hex->int */
export const hexFragmentToChannel = (fragment) => parseInt(fragment, 16);

/** Helper for converting int->hex */
export const channelToHexFragment = (channel) =>
channel.toString(16).padStart(2, "0");
#+END_SRC

***** Math

Before I write the functions for actual conversion, I need to write some basic arithmetic helpers.

#+BEGIN_SRC deno :tangle "./internals/color/convert/setup.js" :comments link
/** Helper to limit precision */
export const significant = (digits, value) => +value.toPrecision(digits);

/** x + y */
const sum = (y, x) => significant(6, x + y);

/** x â y */
const product = (y, x) => significant(6, x * y);

/** x Ã· y */
const quotient = (y, x) => significant(6, x / y);

/** x % y */
const remainder = (y, x) => significant(6, x % y);

// Hrad, Hgrad, Hturn -> hue

/** Formula: nÂ° = nã­ â 180âÏ */
export const calcHueFromRad = (radians) =>
Math.round(product(quotient(Math.PI, 180), radians));

/** Formula: nÂ° = náµâ 180â200 */
export const calcHueFromGrad = (gradians) =>
Math.round(product(quotient(200, 180), gradians));

/** Formula: nÂ° = n% â 360 */
export const calcHueFromTurn = (turn) => Math.round(product(360, turn));

// Hue correction

/** Formula: nÂ° = -n + 360 */
export const correctHueCounterClockwise = (hue) => sum(360, hue);

/** Formula: nÂ° = n % 360 */
export const correctHueClockwise = (hue) => remainder(360, hue);

// Saturation, lightness

/** Formula: n = n%â100 */
export const calcFractionFromPercent = (percentage) =>
quotient(100, percentage);

/** Formula: n = n â 100 */
export const calcPercentFromFraction = (fraction) => product(100, fraction);

// RGB calculations

/** Formula: n = n â 255 */
export const calcChannelFromFraction = (fraction) => product(255, fraction);

/** Formula: n = nâ255 */
export const calcFractionFromChannel = (channel) => quotient(255, channel);

/** Formula: n = n%â100 â 255 */
export const calcChannelFromPercent = (percentage) =>
Math.round(calcChannelFromFraction(calcFractionFromPercent(percentage)));

/** Normalization to define boundaries */
export const normalize = (a, x, b) => Math.round(Math.min(Math.max(x, a), b));

// Alpha

/** Helper to convert alpha value to hex fragment */
export const calcHexFragmentFromAlpha = (alpha) =>
channelToHexFragment(Math.round(calcChannelFromFraction(alpha)));

#+END_SRC

Now, I'm ready to write the conversion algorithms.

**** RGB Hex Conversion (=internals/color/convert/hex.js=)

To reiterate, a hex color is the primitive color value. They may convert up to another format,
but cannot convert down to anything but machine code.

***** RGB Hex -> Functional RGB (=hex.rgb=)

Converting RGB Hex to functional RGB is a matter of extracting each channel hex fragment and
converting them to their equivalent integers. And then converting the alpha channel /if/ it exists.

#+BEGIN_SRC deno :tangle "./internals/color/convert/hex.js" :comments link
import {
  calcFractionFromChannel,
  hexFragmentToChannel,
  significant,
} from "./setup.js";

/** RGB Hex -> Functional RGB */
export function rgb(hex) {
  const [r, g, b, alpha] = hex;
  const [R, G, B] = [r, g, b].map((fragment) => hexFragmentToChannel(fragment));
  const A = significant(
    4,
    calcFractionFromChannel(hexFragmentToChannel(alpha ?? "ff")),
  );

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

For testing my implementation, I'll reuse the extracted hex results above.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hex = await import(`${Deno.cwd()}/internals/color/convert/hex.js`);

<<hex-values>>

console.log(colors.map(({color, values}) => ({hex: color, rgb: hex.rgb(values)})));
#+END_SRC

#+NAME: hex-to-rgb
#+begin_src deno
[
  { hex: "#000000", rgb: "rgb(0, 0, 0)" },
  { hex: "#808080", rgb: "rgb(128, 128, 128)" },
  { hex: "#ffffff", rgb: "rgb(255, 255, 255)" },
  { hex: "#ff0000", rgb: "rgb(255, 0, 0)" },
  { hex: "#ffff00", rgb: "rgb(255, 255, 0)" },
  { hex: "#00ff00", rgb: "rgb(0, 255, 0)" },
  { hex: "#00ffff", rgb: "rgb(0, 255, 255)" },
  { hex: "#0000ff", rgb: "rgb(0, 0, 255)" },
  { hex: "#ff00ff", rgb: "rgb(255, 0, 255)" },
  { hex: "#ace", rgb: "rgb(170, 204, 238)" },
  { hex: "#bea", rgb: "rgb(187, 238, 170)" },
  { hex: "#fed", rgb: "rgb(255, 238, 221)" },
  { hex: "#face", rgb: "rgba(255, 170, 204, 0.9333)" },
  { hex: "#cafe", rgb: "rgba(204, 170, 255, 0.9333)" },
  { hex: "#deaded", rgb: "rgb(222, 173, 237)" },
  { hex: "#c0ffee", rgb: "rgb(192, 255, 238)" },
  { hex: "#4991ccaa", rgb: "rgba(73, 145, 204, 0.6667)" },
  { hex: "#abcdef68", rgb: "rgba(171, 205, 239, 0.4078)" }
]
#+end_src

Success!

**** W3C-X11 Conversion (=internals/color/convert/named.js=)

***** RGB Hex <- W3C-X11

After validation, the only possible conversion for a CSS named color is a query for its hex value.

#+BEGIN_SRC deno :tangle "./internals/color/convert/named.js" :comments link
import { X11Colors } from "../../../data/color/w3c-x11.js";

/** RGB HEX <- W3C-X11 */
export const hex = (keyword) => X11Colors[keyword];
#+END_SRC

**** Functional RGB Conversion (=internals/color/convert/rgb.js=)

Functional RGB leads to the first progressive conversion fork and regression option.

+ =RGB Hex <- Functional RGB=: a regressive conversion to RGB Hex
+ =Functional RGB -> Functional HSL=: a progressive conversion to HSL
+ =Functional RGB -> Device CMYK=: a progressive conversion to CMYK
+ =Functional RGB -> Functional HWB=: a progressive conversion to HWB
+ =Functional RGB -> Functional CIE Lab=: a progressive conversion to Lab

***** RGB Conversion Setup

Functional RGB conversions are slightly more complex than RGB Hex conversions, so they require a bit
of extra math. Luckily, I defined those arithmetic helpers, so I'll pull in the necessary ones.

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
import {
  calcChannelFromPercent,
  calcFractionFromChannel,
  calcFractionFromPercent,
  calcHexFragmentFromAlpha,
  calcPercentFromFraction,
  channelToHexFragment,
  correctHueCounterClockwise,
  significant,
} from "./setup.js";

const precision = significant.bind(null, 5);

/** A helper function to prep RGB values for calculations */
function parseRGB(rgb) {
  const [r, g, b, alpha] = rgb;
  const value = (s) => parseFloat(s);

  const [R, G, B] = [r, g, b].map((channel) =>
    channel.endsWith("%")
      ? precision(calcChannelFromPercent(value(channel)))
      : precision(value(channel))
  );

  const a = value(alpha);
  const A = a != null ? (a > 1 ? precision(calcFractionFromPercent(a)) : a) : 1;

  return A === 1 ? [R, G, B] : [R, G, B, A];
}
#+END_SRC

***** RGB Hex <- Functional RGB (=rgb.hex=)

A regressive conversion is one that breaks a color down. Since an RGB color begins the chain to
higher conversions, that leaves RGB Hex as the only possible regression.

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
/** RGB Hex <- Functional RGB */
export function hex(rgb) {
  const [r, g, b, alpha] = parseRGB(rgb);

  const [R, G, B] = [r, g, b].map((channel) => channelToHexFragment(channel));
  // Alpha is defined and not null
  const A = (alpha && calcHexFragmentFromAlpha(alpha ?? 1)) || "ff";

  return A === "ff" ? `#${R}${G}${B}` : `#${R}${G}${B}${A}`;
}
#+END_SRC

Now, I'll use the extracted RGB defined earlier to test my conversions for accuracy.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/internals/color/convert/rgb.js`);

<<rgb-values>>

console.log(colors.map(({color, values}) => ({rgb: color, hex: rgb.hex(values)})));
#+END_SRC

#+NAME: rgb-to-hex
#+begin_src deno
[
  { rgb: "rgb(0, 0, 0)", hex: "#000000" },
  { rgb: "rgb(128, 128, 128)", hex: "#808080" },
  { rgb: "rgb(255, 255, 255)", hex: "#ffffff" },
  { rgb: "rgb(255, 0, 0)", hex: "#ff0000" },
  { rgb: "rgb(255, 255, 0)", hex: "#ffff00" },
  { rgb: "rgb(0, 255, 0)", hex: "#00ff00" },
  { rgb: "rgb(0, 255, 255)", hex: "#00ffff" },
  { rgb: "rgb(0, 0, 255)", hex: "#0000ff" },
  { rgb: "rgb(255, 0, 255)", hex: "#ff00ff" },
  { rgb: "rgb(33, 199, 95)", hex: "#21c75f" },
  { rgb: "rgb(19, 114, 220)", hex: "#1372dc" },
  { rgb: "rgb(10%, 40.4%, 49.9%)", hex: "#1a677f" },
  { rgb: "rgb(200 138 39)", hex: "#c88a27" },
  { rgb: "rgb(31 88 49 / 0.8)", hex: "#1f5831cc" },
  { rgb: "rgba(110, 33, 110, 0.75)", hex: "#6e216ebf" },
  { rgb: "rgba(10, 119, 30, 30%)", hex: "#0a771e4d" }
]
#+end_src

***** Functional RGB -> Functional HSL (=rgb.hsl=)

Functional RGB to Functional HSL conversion was supported in QuarkSuite 1, so the algorithm hasn't
changed its implementation. First, it requires a little prep.

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
// https://www.rapidtables.com/convert/color/rgb-to-hsl.html
const calcHue = (R, G, B, cmax, delta) =>
  new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);

const calcSat = (delta, L) =>
  delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));

const calcLightness = (cmin, cmax) => (cmax + cmin) / 2;

function calcHSL(r, g, b) {
  const [R, G, B] = [r, g, b].map((channel) =>
    calcFractionFromChannel(channel)
  );

  const cmin = Math.min(R, G, B);
  const cmax = Math.max(R, G, B);
  const delta = cmax - cmin;

  const [H] = Array.from(calcHue(R, G, B, cmax, delta))
    .filter(([, condition]) => condition)
    .flatMap(([value]) => Math.round(value));

  const L = calcLightness(cmin, cmax);

  const S = calcSat(delta, L);

  return [Math.sign(H) === -1 ? correctHueCounterClockwise(H) : H, S, L];
}
#+END_SRC

And now the actual conversion algorithm:

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
/** Functional RGB -> Functional HSL */
export function hsl(rgb) {
  const [r, g, b, alpha] = parseRGB(rgb);
  const [h, s, l] = calcHSL(r, g, b);

  const [H, S, L] = [
    h,
    precision(calcPercentFromFraction(s)),
    precision(calcPercentFromFraction(l)),
  ];
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `hsl(${H}, ${S}%, ${L}%)` : `hsla(${H}, ${S}%, ${L}%, ${A})`;
}
#+END_SRC

Time for some color conversion tests!

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/internals/color/convert/rgb.js`);

<<rgb-values>>

console.log(colors.map(({color, values}) => ({rgb: color, hsl: rgb.hsl(values)})));
#+END_SRC

#+NAME: rgb-to-hsl
#+begin_src deno
[
  { rgb: "rgb(0, 0, 0)", hsl: "hsl(0, 0%, 0%)" },
  { rgb: "rgb(128, 128, 128)", hsl: "hsl(0, 0%, 50.196%)" },
  { rgb: "rgb(255, 255, 255)", hsl: "hsl(0, 0%, 100%)" },
  { rgb: "rgb(255, 0, 0)", hsl: "hsl(0, 100%, 50%)" },
  { rgb: "rgb(255, 255, 0)", hsl: "hsl(60, 100%, 50%)" },
  { rgb: "rgb(0, 255, 0)", hsl: "hsl(120, 100%, 50%)" },
  { rgb: "rgb(0, 255, 255)", hsl: "hsl(180, 100%, 50%)" },
  { rgb: "rgb(0, 0, 255)", hsl: "hsl(240, 100%, 50%)" },
  { rgb: "rgb(255, 0, 255)", hsl: "hsl(300, 100%, 50%)" },
  { rgb: "rgb(33, 199, 95)", hsl: "hsl(142, 71.552%, 45.49%)" },
  { rgb: "rgb(19, 114, 220)", hsl: "hsl(212, 84.1%, 46.863%)" },
  { rgb: "rgb(10%, 40.4%, 49.9%)", hsl: "hsl(194, 66.013%, 30%)" },
  { rgb: "rgb(200 138 39)", hsl: "hsl(37, 67.364%, 46.863%)" },
  { rgb: "rgb(31 88 49 / 0.8)", hsl: "hsla(139, 47.899%, 23.333%, 0.8)" },
  { rgb: "rgba(110, 33, 110, 0.75)", hsl: "hsla(300, 53.846%, 28.039%, 0.75)" },
  { rgb: "rgba(10, 119, 30, 30%)", hsl: "hsla(131, 84.496%, 25.294%, 0.3)" }
]
#+end_src

Booyah!

***** Functional RGB -> Device CMYK (=rgb.cmyk=)

And now I drift again into unfamiliar terrain, but RapidTables is there again to provide a map.

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
/** Functional RGB -> Device CMYK */
export function cmyk(rgb) {
  const [r, g, b, alpha] = parseRGB(rgb);
  const [R, G, B] = [r, g, b].map((channel) =>
    calcFractionFromChannel(channel)
  );

  // https://www.rapidtables.com/convert/color/rgb-to-cmyk.html
  const k = 1 - Math.max(R, G, B);
  const [c, m, y] = [R, G, B].map((channel) => (1 - channel - k) / (1 - k));
  const A = (alpha && (alpha ?? 1)) || 1;

  // Many examples in the CSS Color Module Level 4 use the percentage format,
  // so I'm assuming that's the preferred format in conversions.
  const [C, M, Y, K] = [c, m, y, k].map((component) =>
    isNaN(component) ? 0 : precision(calcPercentFromFraction(component))
  );

  return A === 1
    ? `device-cmyk(${C}% ${M}% ${Y}% ${K}%)`
    : `device-cmyk(${C}% ${M}% ${Y}% ${K}% / ${A})`;
}
#+END_SRC

Now, I'm checking the math.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/internals/color/convert/rgb.js`);

<<rgb-values>>

console.log(colors.map(({color, values}) => ({rgb: color, cmyk: rgb.cmyk(values)})));
#+END_SRC

#+NAME: rgb-to-cmyk
#+begin_src deno
[
  { rgb: "rgb(0, 0, 0)", cmyk: "device-cmyk(0% 0% 0% 100%)" },
  { rgb: "rgb(128, 128, 128)", cmyk: "device-cmyk(0% 0% 0% 49.804%)" },
  { rgb: "rgb(255, 255, 255)", cmyk: "device-cmyk(0% 0% 0% 0%)" },
  { rgb: "rgb(255, 0, 0)", cmyk: "device-cmyk(0% 100% 100% 0%)" },
  { rgb: "rgb(255, 255, 0)", cmyk: "device-cmyk(0% 0% 100% 0%)" },
  { rgb: "rgb(0, 255, 0)", cmyk: "device-cmyk(100% 0% 100% 0%)" },
  { rgb: "rgb(0, 255, 255)", cmyk: "device-cmyk(100% 0% 0% 0%)" },
  { rgb: "rgb(0, 0, 255)", cmyk: "device-cmyk(100% 100% 0% 0%)" },
  { rgb: "rgb(255, 0, 255)", cmyk: "device-cmyk(0% 100% 0% 0%)" },
  { rgb: "rgb(33, 199, 95)", cmyk: "device-cmyk(83.417% 0% 52.261% 21.961%)" },
  { rgb: "rgb(19, 114, 220)", cmyk: "device-cmyk(91.364% 48.182% 0% 13.726%)" },
  { rgb: "rgb(10%, 40.4%, 49.9%)", cmyk: "device-cmyk(79.528% 18.898% 0% 50.196%)" },
  { rgb: "rgb(200 138 39)", cmyk: "device-cmyk(0% 31% 80.5% 21.569%)" },
  {
    rgb: "rgb(31 88 49 / 0.8)",
    cmyk: "device-cmyk(64.773% 0% 44.318% 65.49% / 0.8)"
  },
  { rgb: "rgba(110, 33, 110, 0.75)", cmyk: "device-cmyk(0% 70% 0% 56.863% / 0.75)" },
  {
    rgb: "rgba(10, 119, 30, 30%)",
    cmyk: "device-cmyk(91.597% 0% 74.79% 53.333% / 0.3)"
  }
]
#+end_src

Seems to check out, but I'm going to implement some visual tests soon.

***** Functional RGB -> Functional HWB (=rgb.hwb=)

The conversion of RGB to HWB is a little unorthodox. It's technically a /composite/ conversion. The
hue is first calculated via partial HSL conversion, and then the amount of white and black is
calculated via a [[https://www.w3.org/TR/css-color-4/#rgb-to-hwb][modified formula from the spec itself]].

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
/** Functional RGB -> Functional HWB */
export function hwb(rgb) {
  const [r, g, b, alpha] = parseRGB(rgb);
  const [R, G, B] = [r, g, b].map((channel) =>
    calcFractionFromChannel(channel)
  );

  const [H] = calcHSL(r, g, b);
  const [W, BLK] = [
    precision(calcPercentFromFraction(Math.min(R, G, B))),
    precision(calcPercentFromFraction(1 - Math.max(R, G, B))),
  ];
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `hwb(${H} ${W}% ${BLK}%)` : `hwb(${H} ${W}% ${BLK}% / ${A})`;
}
#+END_SRC

I'm suspicious of the math here, so let's see the proof.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/internals/color/convert/rgb.js`);

<<rgb-values>>

console.log(colors.map(({color, values}) => ({rgb: color, hwb: rgb.hwb(values)})));
#+END_SRC

#+NAME: rgb-to-hwb
#+begin_src deno
[
  { rgb: "rgb(0, 0, 0)", hwb: "hwb(0 0% 100%)" },
  { rgb: "rgb(128, 128, 128)", hwb: "hwb(0 50.196% 49.804%)" },
  { rgb: "rgb(255, 255, 255)", hwb: "hwb(0 100% 0%)" },
  { rgb: "rgb(255, 0, 0)", hwb: "hwb(0 0% 0%)" },
  { rgb: "rgb(255, 255, 0)", hwb: "hwb(60 0% 0%)" },
  { rgb: "rgb(0, 255, 0)", hwb: "hwb(120 0% 0%)" },
  { rgb: "rgb(0, 255, 255)", hwb: "hwb(180 0% 0%)" },
  { rgb: "rgb(0, 0, 255)", hwb: "hwb(240 0% 0%)" },
  { rgb: "rgb(255, 0, 255)", hwb: "hwb(300 0% 0%)" },
  { rgb: "rgb(33, 199, 95)", hwb: "hwb(142 12.941% 21.961%)" },
  { rgb: "rgb(19, 114, 220)", hwb: "hwb(212 7.451% 13.726%)" },
  { rgb: "rgb(10%, 40.4%, 49.9%)", hwb: "hwb(194 10.196% 50.196%)" },
  { rgb: "rgb(200 138 39)", hwb: "hwb(37 15.294% 21.569%)" },
  { rgb: "rgb(31 88 49 / 0.8)", hwb: "hwb(139 12.157% 65.49% / 0.8)" },
  { rgb: "rgba(110, 33, 110, 0.75)", hwb: "hwb(300 12.941% 56.863% / 0.75)" },
  { rgb: "rgba(10, 119, 30, 30%)", hwb: "hwb(131 3.9216% 53.333% / 0.3)" }
]
#+end_src

I'll test this more , but the results are about what I'd expect.

***** Functional RGB -> Functional CIE Lab (=rgb.lab=)

Converting RGB to CIE Lab is another multistep process. The chain is as follows:

1) =Functional RGB >-< Linear RGB=
2) =Linear RGB -> CIE XYZ=
3) =CIE XYZ -> Functional CIE Lab=

The =>-<= indicates a lateral conversion. One that isn't a completely different format, but a
modification of the original format for some special purpose.

CIE XYZ is a necessary waypoint on the road to CIE Lab conversion indicating a set of general
coordinates based on the range of colors perceptible by the human eye.

#+BEGIN_QUOTE
In some color conversion implementations, it would also be a waypoint in CIE LCH conversion, but I
think it's easier to complete the =Functional RGB <-> Functional CIE Lab= link and then allow
=Functional CIE Lab <-> Functional CIE LCH= to form its own separate link.
#+END_QUOTE

****** Functional RGB >-< Linear RGB

Linear RGB is RGB without the gamma function applied as that would throw off the calculation of CIE
XYZ.

You can [[https://www.image-engineering.de/library/technotes/958-how-to-convert-between-srgb-and-ciexyz][read more about the actual formula]] if you're curious.

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
/** Functional RGB >-< Linear RGB */
const removeGamma = (rgb) =>
  rgb.map((v) => {
    const V = calcFractionFromChannel(v);
    return V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4;
  });
#+END_SRC

****** Linear RGB -> CIE XYZ

Now, to convert the ungamma-ed RGB to XYZ data, we have to pass it through a transformation matrix
of values representing the D65 reference white point defined in sRGB, which CSS uses.

For that, I'm going to use a simple array calculation that /approximates/ what matrix multiplication
is under the hood instead of wiring up a needlessly complex implementation.

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
/** Linear RGB -> CIE XYZ */
function calcXYZ(rgb) {
  const [R, G, B] = removeGamma(rgb);
  return [
    R * 0.4124564 + G * 0.3575761 + B * 0.1804375,
    R * 0.2126729 + G * 0.7151522 + B * 0.072175,
    R * 0.0193339 + G * 0.119192 + B * 0.9503041,
  ]; // [X, Y, Z]
}
#+END_SRC

****** CIE XYZ -> Functional CIE Lab

First, I need to apply the [[http://www.brucelindbloom.com/Eqn_ChromAdapt.html][Bradford method of chromatic adaptation]] to convert from D65 to D50, which
CIE Lab uses.

And then I need to apply the actual [[http://www.brucelindbloom.com/index.html?Equations.html][conversion formula]].

#+BEGIN_SRC deno :tangle "./internals/color/convert/rgb.js" :comments link
function calcD50XYZ(rgb) {
  const [X, Y, Z] = calcXYZ(rgb);
  /*
   * D50 matrix
   * =============================
   * 1.0478112  0.0228866 -0.0501270
   * 0.0295424  0.9904844 -0.0170491
   * -0.0092345  0.0150436  0.7521316
   * =============================
   */
  return [
    X * 1.0478112 + Y * 0.0228866 + Z * -0.050127,
    X * 0.0295424 + Y * 0.9904844 + Z * -0.0170491,
    X * -0.0092345 + Y * 0.0150436 + Z * 0.7521316,
  ];
}

/** Functional RGB -> Functional CIE Lab */
export function lab(rgb) {
  const [r, g, b, alpha] = parseRGB(rgb);
  const [x, y, z] = calcD50XYZ([r, g, b]);

  // CIE standards
  const Îµ = 216 / 24389;
  const Îº = 24389 / 27;
  const white = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Calculating XYZ scaled relative to white
  const [X, Y, Z] = [x, y, z].map((v, i) => v / white[i]);
  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z].map((V) =>
    V > Îµ ? Math.cbrt(V) : (Îº * V + 16) / 116
  );

  // Calculating Lab values and limiting the precision
  const [L, aHue, bHue] = [
    precision(116 * FY - 16),
    precision(500 * (FX - FY)),
    precision(200 * (FY - FZ)),
  ].map((V) => (Math.sign(Math.round(V)) === 0 ? 0 : V));
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1
    ? `lab(${L}% ${aHue} ${bHue})`
    : `lab(${L}% ${aHue} ${bHue} / ${A})`;
}
#+END_SRC

That was a lot, so I'm going to run my tests now.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/internals/color/convert/rgb.js`);

<<rgb-values>>

console.log(colors.map(({color, values}) => ({rgb: color, lab: rgb.lab(values)})));
#+END_SRC

#+NAME: rgb-to-lab
#+begin_src deno
[
  { rgb: "rgb(0, 0, 0)", lab: "lab(0% 0 0)" },
  { rgb: "rgb(128, 128, 128)", lab: "lab(53.585% 0 0)" },
  { rgb: "rgb(255, 255, 255)", lab: "lab(100% 0 0)" },
  { rgb: "rgb(255, 0, 0)", lab: "lab(54.292% 80.812 69.885)" },
  { rgb: "rgb(255, 255, 0)", lab: "lab(97.607% -15.753 93.388)" },
  { rgb: "rgb(0, 255, 0)", lab: "lab(87.818% -79.287 80.99)" },
  { rgb: "rgb(0, 255, 255)", lab: "lab(90.665% -50.665 -14.962)" },
  { rgb: "rgb(0, 0, 255)", lab: "lab(29.568% 68.299 -112.03)" },
  { rgb: "rgb(255, 0, 255)", lab: "lab(60.17% 93.55 -60.499)" },
  { rgb: "rgb(33, 199, 95)", lab: "lab(70.854% -58.576 39.72)" },
  { rgb: "rgb(19, 114, 220)", lab: "lab(47.683% 5.8918 -62.494)" },
  { rgb: "rgb(10%, 40.4%, 49.9%)", lab: "lab(39.981% -16.954 -20.404)" },
  { rgb: "rgb(200 138 39)", lab: "lab(62.671% 18.464 58.572)" },
  { rgb: "rgb(31 88 49 / 0.8)", lab: "lab(32.891% -26.87 16.881 / 0.8)" },
  { rgb: "rgba(110, 33, 110, 0.75)", lab: "lab(28.127% 41.667 -27.612 / 0.75)" },
  { rgb: "rgba(10, 119, 30, 30%)", lab: "lab(43.317% -42.987 38.123 / 0.3)" }
]
#+end_src

Awesome.

**** Functional HSL Conversion (=internals/color/convert/hsl.js=)

HSL conversion sits like an island in the conversion algorithms, because even though it's easier for
humans to work with, RGB conversions are easier to /calculate/. And so, all conversions from this
point on convert to and from the RGB space.

***** Functional RGB <- Functional HSL (=hsl.rgb=)

The only unique HSL conversion is a regressive conversion to RGB which can be used as a jumping off
point for converting to all remaining formats.

First, the extracted values require some prepping before calculations are predictable.

#+BEGIN_SRC deno :tangle "./internals/color/convert/hsl.js" :comments link
import {
  calcChannelFromFraction,
  calcFractionFromPercent,
  calcHueFromGrad,
  calcHueFromRad,
  calcHueFromTurn,
  correctHueClockwise,
  correctHueCounterClockwise,
} from "./setup.js";

// https://www.rapidtables.com/convert/color/hsl-to-rgb.html
const calcChannels = (C, X, H) =>
  new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);

export const parseHSL = (hsl) => {
  const [h, s, l, alpha] = hsl;

  const [H] = [h].map((value) => {
    const n = parseFloat(value);
    const isNegative = (n) => Math.sign(n) === -1;
    let hue;

    // Set hue based on unit
    if (value.endsWith("grad")) {
      hue = isNegative(n) ? calcHueFromGrad(n + 400) : calcHueFromGrad(n);
    } else if (value.endsWith("rad")) {
      hue = isNegative(n) ? calcHueFromRad(n + 6.28319) : calcHueFromRad(n);
    } else if (value.endsWith("turn")) {
      hue = isNegative(n) ? calcHueFromTurn(n + 1) : calcHueFromTurn(n);
    } else {
      hue = n;
    }

    // hue correction
    let degrees;
    if (hue >= 360) {
      degrees = correctHueClockwise(hue);
    } else if (isNegative(hue)) {
      degrees = correctHueClockwise(correctHueCounterClockwise(hue));
    } else {
      degrees = hue;
    }

    return degrees;
  });

  const [S, L] = [s, l].map((value) => {
    const n = parseFloat(value);
    return calcFractionFromPercent(n);
  });

  const a = parseFloat(alpha);
  const A = a != null ? (a > 1 ? calcFractionFromPercent(a) : a) : 1;

  return A === 1 ? [H, S, L] : [H, S, L, A];
};

export const calcRGB = (h, s, l) => {
  // Calculate chroma
  const C = (1 - Math.abs(2 * l - 1)) * s;
  const X = C * (1 - Math.abs(((h / 60) % 2) - 1));
  const m = l - C / 2;

  // Evaluate channels
  const [R, G, B] = Array.from(calcChannels(C, X, h))
    .filter(([, condition]) => condition)
    .flatMap(([evaluation]) => evaluation)
    .map((channel) => Math.round(calcChannelFromFraction(channel + m)));

  return [R, G, B];
};
#+END_SRC

Phew. Now for the actual conversion algorithm, it's a similar pattern to the RGB progressive
conversion to HSL.

#+BEGIN_SRC deno :tangle "./internals/color/convert/hsl.js" :comments link
/** Functional RGB <- Functional HSL */
export function rgb(hsl) {
  const [h, s, l, alpha] = parseHSL(hsl);
  const [R, G, B] = calcRGB(h, s, l);

  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

Now, the tests with my extracted HSL to verify that the math checks out.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hsl = await import(`${Deno.cwd()}/internals/color/convert/hsl.js`);

<<hsl-values>>

console.log(colors.map(({color, values}) => ({hsl: color, rgb: hsl.rgb(values)})));
#+END_SRC

#+NAME: hsl-to-rgb
#+begin_src deno
[
  { hsl: "hsl(0, 0%, 0%)", rgb: "rgb(0, 0, 0)" },
  { hsl: "hsl(0, 0%, 50%)", rgb: "rgb(128, 128, 128)" },
  { hsl: "hsl(0, 0%, 100%)", rgb: "rgb(255, 255, 255)" },
  { hsl: "hsl(0, 100%, 50%)", rgb: "rgb(255, 0, 0)" },
  { hsl: "hsl(60, 100%, 50%)", rgb: "rgb(255, 255, 0)" },
  { hsl: "hsl(120, 100%, 50%)", rgb: "rgb(0, 255, 0)" },
  { hsl: "hsl(180, 100%, 50%)", rgb: "rgb(0, 255, 255)" },
  { hsl: "hsl(240, 100%, 50%)", rgb: "rgb(0, 0, 255)" },
  { hsl: "hsl(300, 100%, 50%)", rgb: "rgb(255, 0, 255)" },
  { hsl: "hsl(38, 78%, 40%)", rgb: "rgb(182, 123, 22)" },
  { hsl: "hsl(3 88% 70%)", rgb: "rgb(246, 118, 111)" },
  { hsl: "hsl(189 63% 85% / 0.71)", rgb: "rgba(193, 234, 241, 0.71)" },
  { hsl: "hsla(1.5rad, 73%, 10%, 0.831)", rgb: "rgba(28, 44, 7, 0.831)" },
  { hsl: "hsl(320grad 89% 36% / 79%)", rgb: "rgba(141, 10, 174, 0.79)" },
  { hsl: "hsl(0.36turn 83% 90%)", rgb: "rgb(208, 251, 215)" }
]
#+end_src

**** Device CMYK Conversion (=internals/color/convert/device-cmyk.js=)

CMYK  conversion is like HSL in that it's more of an endpoint and needs to be regressively converted
to functional RGB before it can be included in a conversion chain.

***** Functional RGB <- Device CMYK (=cmyk.rgb=)

First, some minimal setup.

#+BEGIN_SRC deno :tangle "./internals/color/convert/device-cmyk.js" :comments link
import { calcChannelFromFraction, calcFractionFromPercent } from "./setup.js";

function parseCMYK(cmyk) {
  const [c, m, y, k, alpha] = cmyk;
  const value = (s) => parseFloat(s);
  const [C, M, Y, K] = [c, m, y, k].map((component) =>
    component.endsWith("%")
      ? calcFractionFromPercent(value(component))
      : value(component)
  );

  const a = value(alpha);
  const A = a != null ? (a > 1 ? calcFractionFromPercent(a) : a) : 1;

  return A === 1 ? [C, M, Y, K] : [C, M, Y, K, A];
}
#+END_SRC

For the conversion algorithm, it's RapidTables coming again with the assist.

#+BEGIN_SRC deno :tangle "./internals/color/convert/device-cmyk.js" :comments link
/** Functional RGB <- Device CMYK */
export function rgb(cmyk) {
  const [C, M, Y, K, alpha] = parseCMYK(cmyk);

  const [R, G, B] = [C, M, Y].map((component) =>
    Math.round(calcChannelFromFraction((1 - component) * (1 - K)))
  );
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

Time to see if the math stacks up.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const cmyk = await import(`${Deno.cwd()}/internals/color/convert/device-cmyk.js`);

<<cmyk-values>>

console.log(colors.map(({color, values}) => ({cmyk: color, rgb: cmyk.rgb(values)})));
#+END_SRC

#+NAME: cmyk-to-rgb
#+begin_src deno
[
  { cmyk: "device-cmyk(0% 0% 0% 100%)", rgb: "rgb(0, 0, 0)" },
  { cmyk: "device-cmyk(0% 0% 0% 50%)", rgb: "rgb(128, 128, 128)" },
  { cmyk: "device-cmyk(0% 0% 0% 0%)", rgb: "rgb(255, 255, 255)" },
  { cmyk: "device-cmyk(0% 100% 100% 0%)", rgb: "rgb(255, 0, 0)" },
  { cmyk: "device-cmyk(0% 0% 100% 0%)", rgb: "rgb(255, 255, 0)" },
  { cmyk: "device-cmyk(100% 0% 100% 0%)", rgb: "rgb(0, 255, 0)" },
  { cmyk: "device-cmyk(100% 0% 0% 0%)", rgb: "rgb(0, 255, 255)" },
  { cmyk: "device-cmyk(100% 100% 0% 0%)", rgb: "rgb(0, 0, 255)" },
  { cmyk: "device-cmyk(0% 100% 0% 0%)", rgb: "rgb(255, 0, 255)" },
  { cmyk: "device-cmyk(37% 63% 0 0)", rgb: "rgb(161, 94, 255)" },
  { cmyk: "device-cmyk(50% 25% 10% 0)", rgb: "rgb(128, 191, 230)" },
  { cmyk: "device-cmyk(0.77 0.33 0 0)", rgb: "rgb(59, 171, 255)" },
  { cmyk: "device-cmyk(0.8 0 0.4 0.13 / 0.8)", rgb: "rgba(44, 222, 133, 0.8)" },
  { cmyk: "device-cmyk(25% 75% 8% 3% / 81.3%)", rgb: "rgba(186, 62, 228, 0.813)" }
]
#+end_src

**** Functional HWB Conversion (=internals/color/convert/hwb.js=)

The only possible conversion from HWB is a regressive conversion to RGB. This provides the necessary
bridge to other format conversions.

***** Functional RGB <- Functional HWB

As with the progressive conversion, the regressive conversion is a composite. It first splits the
hue with a call to =calcRGB()= from the HSL conversion module, setting the saturation and lightness to
return a pure hue, then modifies the result with the given amount of white and black.

Again, the implementation uses [[https://www.w3.org/TR/css-color-4/#hwb-to-rgb][a formula ripped straight from the spec]] with some modifications.

First, setting up some helpers:

#+BEGIN_SRC deno :tangle "./internals/color/convert/hwb.js" :comments link
import {
  calcChannelFromFraction,
  calcFractionFromChannel,
  calcFractionFromPercent,
} from "./setup.js";
import { calcRGB, parseHSL } from "./hsl.js";

function parseHWB(hwb) {
  const [h, w, blk, alpha] = hwb;
  const [H] = parseHSL([h, "100%", "50%", "1"]);
  const [W, BLK] = [w, blk].map((component) =>
    calcFractionFromPercent(parseFloat(component))
  );

  const a = parseFloat(alpha);
  const A = a != null ? (a > 1 ? calcFractionFromPercent(a) : a) : 1;

  return A === 1 ? [H, W, BLK] : [H, W, BLK, A];
}
#+END_SRC

And now for the conversion algorithm.

#+BEGIN_SRC deno :tangle "./internals/color/convert/hwb.js" :comments link
/** Functional RGB <- Functional HWB */
export function rgb(hwb) {
  const [h, w, blk, alpha] = parseHWB(hwb);
  const [r, g, b] = calcRGB(h, 1, 0.5);

  const A = (alpha && (alpha ?? 1)) || 1;

  // Achromatic
  if (w + blk >= 1) {
    const GRAY = Math.round(calcChannelFromFraction(w / (w + blk)));
    return A === 1
      ? `rgb(${GRAY}, ${GRAY}, ${GRAY})`
      : `rgba(${GRAY}, ${GRAY}, ${GRAY}, ${A})`;
  }

  const [R, G, B] = [r, g, b].map((channel) =>
    Math.round(
      calcChannelFromFraction(
        calcFractionFromChannel(channel) * (1 - w - blk) + w,
      ),
    )
  );

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

Now the fun part: seeing if anything breaks.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hwb = await import(`${Deno.cwd()}/internals/color/convert/hwb.js`);

<<hwb-values>>

console.log(colors.map(({color, values}) => ({hwb: color, rgb: hwb.rgb(values)})));
#+END_SRC

#+NAME: hwb-to-rgb
#+begin_src deno
[
  { hwb: "hwb(0 0% 100%)", rgb: "rgb(0, 0, 0)" },
  { hwb: "hwb(0 100% 100%)", rgb: "rgb(128, 128, 128)" },
  { hwb: "hwb(0 100% 0%)", rgb: "rgb(255, 255, 255)" },
  { hwb: "hwb(0 0% 0%)", rgb: "rgb(255, 0, 0)" },
  { hwb: "hwb(60 0% 0%)", rgb: "rgb(255, 255, 0)" },
  { hwb: "hwb(120 0% 0%)", rgb: "rgb(0, 255, 0)" },
  { hwb: "hwb(180 0% 0%)", rgb: "rgb(0, 255, 255)" },
  { hwb: "hwb(240 0% 0%)", rgb: "rgb(0, 0, 255)" },
  { hwb: "hwb(300 0% 0%)", rgb: "rgb(255, 0, 255)" },
  { hwb: "hwb(188 20% 3%)", rgb: "rgb(51, 221, 247)" },
  { hwb: "hwb(3.1rad 50% 0%)", rgb: "rgb(128, 255, 251)" },
  { hwb: "hwb(183grad 5% 15% / 0.5)", rgb: "rgba(13, 217, 166, 0.5)" },
  { hwb: "hwb(0.8turn 38% 99%)", rgb: "rgb(71, 71, 71)" }
]
#+end_src

Looks like we're golden.

**** Functional CIE Lab Conversion (=internals/color/convert/lab.js=)

CIE Lab requires a regressive conversion to Functional RGB. With this, the link is complete and CIE
Lab colors now have a bridge to other conversions.

***** CIE Lab Conversion Setup

I'll have to grab the RGB channel conversion function from my math kit.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lab.js" :comments link
import {
  calcChannelFromFraction,
  calcFractionFromPercent,
  calcHueFromRad,
  correctHueCounterClockwise,
  normalize,
  significant,
} from "./setup.js";
#+END_SRC

***** Functional RGB <- CIE Lab

Now, I follow an inversion of the progressive conversion algorithm.

1) =CIE XYZ <- Functional CIE Lab=
2) =Linear RGB <- CIE XYZ=
3) =Linear RGB >-< Functional RGB=

****** CIE XYZ <- Functonal CIE Lab

The [[http://www.brucelindbloom.com/index.html?Equations.html][formula for regressing CIE Lab to CIE XYZ]] is cleanly outlined. So, I'll follow that.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lab.js" :comments link
function calcXYZ(lab) {
  const [L, a, b] = lab.map((v) => parseFloat(v));

  // CIE standards
  const Îµ = 216 / 24389;
  const Îº = 24389 / 27;
  const white = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const Fy = (L + 16) / 116;
  const Fx = a / 500 + Fy;
  const Fz = Fy - b / 200;

  // Calculate xyz
  const [x, y, z] = [
    Fx ** 3 > Îµ ? Fx ** 3 : (116 * Fx - 16) / Îº,
    L > Îº * Îµ ? Fy ** 3 : L / Îº,
    Fz ** 3 > Îµ ? Fz ** 3 : (116 * Fz - 16) / Îº,
  ];

  return [x, y, z].map((V, i) => V * white[i]);
}
#+END_SRC

****** Linear RGB <- CIE XYZ

The next step is converting the D50 XYZ to sRGB native D65 XYZ via chromatic adaptation.

And /then/ passing it through the inverse transformation matrix to get linear RGB.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lab.js" :comments link
function calcLinearRGB(lab) {
  const [x, y, z] = calcXYZ(lab);
  /**
   * D65 transformation matrix
   * =============================
   * 0.9555766 -0.0230393  0.0631636
   * -0.0282895  1.0099416  0.0210077
   * 0.0122982 -0.0204830  1.3299098
   * =============================
   */
  const [X, Y, Z] = [
    x * 0.9555766 + y * -0.0230393 + z * 0.0631636,
    x * -0.0282895 + y * 1.0099416 + z * 0.0210077,
    x * 0.0122982 + y * -0.020483 + z * 1.3299098,
  ];

  /**
   * linear sRGB transformation matrix (inverse)
   * =============================
   *  3.2404542 -1.5371385 -0.4985314
   * -0.9692660  1.8760108  0.0415560
   *  0.0556434 -0.2040259  1.0572252
   * =============================
   */
  return [
    X * 3.2404542 + Y * -1.5371385 + Z * -0.4985314,
    X * -0.969266 + Y * 1.8760108 + Z * 0.041556,
    X * 0.0556434 + Y * -0.2040259 + Z * 1.0572252,
  ];
}
#+END_SRC

****** Linear RGB >-< Functional RGB

Gamma application is the finishing touch before converting the channel values to the expected =0-255=
range.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lab.js" :comments link
const calcRGB = (lrgb) =>
  lrgb.map((V) => V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055);

/** Functional CIE Lab <- Functional RGB */
export function rgb(lab) {
  const [l, a, b, alpha] = lab;

  const [R, G, B] = calcRGB(calcLinearRGB([l, a, b])).map((channel) =>
    normalize(0, calcChannelFromFraction(channel), 255)
  );
  const A = (alpha &&
    (alpha.endsWith("%")
      ? calcFractionFromPercent(parseFloat(alpha))
      : alpha)) ||
    1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

That was a lot to parse. Time to see if the calculations check out.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lab = await import(`${Deno.cwd()}/internals/color/convert/lab.js`);

<<lab-values>>

console.log(colors.map(({color, values}) => ({lab: color, rgb: lab.rgb(values)})));
#+END_SRC

#+NAME: lab-to-rgb
#+begin_src deno
[
  { lab: "lab(0% 0 0)", rgb: "rgb(0, 0, 0)" },
  { lab: "lab(53.59% 0 0)", rgb: "rgb(128, 128, 128)" },
  { lab: "lab(100% 0 0)", rgb: "rgb(255, 255, 255)" },
  { lab: "lab(54.29% 80.81 69.89)", rgb: "rgb(255, 0, 0)" },
  { lab: "lab(97.6% -15.75 93.39)", rgb: "rgb(255, 255, 0)" },
  { lab: "lab(87.82% -79.29 80.99)", rgb: "rgb(0, 255, 0)" },
  { lab: "lab(90.67% -50.67 -14.96)", rgb: "rgb(0, 255, 255)" },
  { lab: "lab(29.57% 68.3 -112.03)", rgb: "rgb(0, 0, 255)" },
  { lab: "lab(60.17% 93.55 -60.5)", rgb: "rgb(255, 0, 255)" },
  { lab: "lab(49.18% 38.1 -110.33)", rgb: "rgb(0, 102, 255)" },
  { lab: "lab(91.3% -93 14)", rgb: "rgb(0, 255, 199)" },
  { lab: "lab(83.119% 49.34 -3.99 / 0.75)", rgb: "rgba(255, 169, 217, 0.75)" },
  { lab: "lab(199% 38 13 / 78%)", rgb: "rgba(255, 255, 255, 0.78)" }
]
#+end_src

I'll stamp this as Good Enoughâ¢.

***** Functional CIE Lab -> Functional CIE LCH

The final bridge is a progressive conversion of CIE Lab to CIE LCH. With this, all known and proposed
CSS color formats are supported by the Quarks System Core.

And thankfully, [[http://www.brucelindbloom.com/Eqn_Lab_to_LCH.html][the formula]] is a dead simple conversion of rectangle coordinates to polar coordinates.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lab.js" :comments link
const precision = significant.bind(null, 5);

/** Functional CIE Lab -> Functional CIE LCH */
export function lch(lab) {
  const [L, a, b, alpha] = lab;
  const [C, h] = [
    precision(Math.sqrt(parseFloat(a) ** 2 + parseFloat(b) ** 2)),
    precision(Math.atan2(parseFloat(b), parseFloat(a)) * (180 / Math.PI)),
  ];

  const H = Math.sign(h) === -1 ? h + 360 : h;

  const A = (alpha &&
    (alpha.endsWith("%")
      ? calcFractionFromPercent(parseFloat(alpha))
      : alpha)) ||
    1;

  return A === 1 ? `lch(${L} ${C} ${H})` : `lch(${L} ${C} ${H} / ${A})`;
}
#+END_SRC

Now to make sure it returns what I expect.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lab = await import(`${Deno.cwd()}/internals/color/convert/lab.js`);

<<lab-values>>

console.log(colors.map(({color, values}) => ({lab: color, lch: lab.lch(values)})));
#+END_SRC

#+NAME: lab-to-lch
#+begin_src deno
[
  { lab: "lab(0% 0 0)", lch: "lch(0% 0 0)" },
  { lab: "lab(53.59% 0 0)", lch: "lch(53.59% 0 0)" },
  { lab: "lab(100% 0 0)", lch: "lch(100% 0 0)" },
  { lab: "lab(54.29% 80.81 69.89)", lch: "lch(54.29% 106.84 40.855)" },
  { lab: "lab(97.6% -15.75 93.39)", lch: "lch(97.6% 94.709 99.573)" },
  { lab: "lab(87.82% -79.29 80.99)", lch: "lch(87.82% 113.34 134.39)" },
  { lab: "lab(90.67% -50.67 -14.96)", lch: "lch(90.67% 52.832 196.45)" },
  { lab: "lab(29.57% 68.3 -112.03)", lch: "lch(29.57% 131.21 301.369)" },
  { lab: "lab(60.17% 93.55 -60.5)", lch: "lch(60.17% 111.41 327.109)" },
  { lab: "lab(49.18% 38.1 -110.33)", lch: "lch(49.18% 116.72 289.051)" },
  { lab: "lab(91.3% -93 14)", lch: "lch(91.3% 94.048 171.44)" },
  {
    lab: "lab(83.119% 49.34 -3.99 / 0.75)",
    lch: "lch(83.119% 49.501 355.3767 / 0.75)"
  },
  { lab: "lab(199% 38 13 / 78%)", lch: "lch(199% 40.162 18.886 / 0.78)" }
]
#+end_src

That'll do it.

**** Functional CIE LCH Conversion (=internals/color/convert/lch.js=)

Now, I need to calculate the regressive conversion of LCH back to Lab. This final algorithm closes
the conversion chain and allows any supported format to convert to and from any other supported
format.

***** Functional CIE Lab <- Functional CIE LCH

First, a little setup.

It's necessary for the hue component of LCH to use the same possible hue inputs as HSL, because
that's what's allowed in the spec.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lch.js" :comments link
import { calcFractionFromPercent, normalize, significant } from "./setup.js";
import { parseHSL } from "./hsl.js";

const precision = significant.bind(null, 5);
#+END_SRC

The [[http://www.brucelindbloom.com/Eqn_LCH_to_Lab.html][conversion algorithm itself]] is short and sweet.

#+BEGIN_SRC deno :tangle "./internals/color/convert/lch.js" :comments link
/** Functional CIE Lab <- Functional CIE LCH */
export function lab(lch) {
  const [L, c, h, alpha] = lch;
  const C = parseFloat(c);
  const [H] = parseHSL([h, "100%", "50%", "1"]);

  const [a, b] = [
    precision(C * Math.cos(H * (Math.PI / 180))),
    precision(C * Math.sin(H * (Math.PI / 180))),
  ];

  const A = (alpha &&
    (alpha.endsWith("%")
      ? calcFractionFromPercent(parseFloat(alpha))
      : alpha)) ||
    1;

  return A === 1 ? `lab(${L} ${a} ${b})` : `lab(${L} ${a} ${b} / ${A})`;
}
#+END_SRC

Alright, time to test the LCH color table.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lch = await import(`${Deno.cwd()}/internals/color/convert/lch.js`);

<<lch-values>>

console.log(colors.map(({color, values}) => ({lch: color, lab: lch.lab(values)})));
#+END_SRC

#+NAME: lch-to-lab
#+begin_src deno
[
  { lch: "lch(0% 0 0)", lab: "lab(0% 0 0)" },
  { lch: "lch(53.59% 0 0)", lab: "lab(53.59% 0 0)" },
  { lch: "lch(100% 0 0)", lab: "lab(100% 0 0)" },
  { lch: "lch(54.29% 106.84 40.855)", lab: "lab(54.29% 80.81 69.889)" },
  { lch: "lch(97.6% 94.709 99.573)", lab: "lab(97.6% -15.75 93.39)" },
  { lch: "lch(87.82% 113.34 134.39)", lab: "lab(87.82% -79.286 80.992)" },
  { lch: "lch(90.67% 52.832 196.45)", lab: "lab(90.67% -50.669 -14.961)" },
  { lch: "lch(29.57% 131.21 301.369)", lab: "lab(29.57% 68.301 -112.03)" },
  { lch: "lch(60.17% 111.41 327.109)", lab: "lab(60.17% 93.552 -60.5)" },
  { lch: "lch(53.31% 89.31 200)", lab: "lab(53.31% -83.924 -30.546)" },
  { lch: "lch(89.1% 167.34 3.6rad / 0.99)", lab: "lab(89.1% -150.4 -73.357 / 0.99)" },
  { lch: "lch(24.494% 74.9 193grad)", lab: "lab(24.494% -74.49 7.8292)" },
  {
    lch: "lch(47.39% 111.193 0.62turn / 75%)",
    lab: "lab(47.39% -81.321 -75.833 / 0.75)"
  }
]
#+end_src

And that's it for color conversion.

* Data

This section documents lookup tables and other hardcoded bits of data used by the core modules.

** Color

*** W3C X11 Color Definitions (=data/color/w3c-x11.js=)

This is a lookup table for [[http://www.w3.org/TR/css3-color/#svg-color][all named CSS colors]] as of the CSS4 module updates.

#+BEGIN_SRC deno :tangle "./data/color/w3c-x11.js" :comments link
/** X11 color names: https://www.w3.org/TR/css3-color/#svg-color */
export const X11Colors = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
#+END_SRC

*** Accesible Web Defaults (=data/color/a11y.js=)

This is a lookup table for [[http://clrs.cc][better web defaults]] optimized for accessibility.

#+BEGIN_SRC deno :tangle "./data/color/a11y.js" :comments link
/** Better web default colors: http://clrs.cc */
export const A11yColors = {
  navy: "#001f3f",
  blue: "#0074d9",
  aqua: "#7fdbff",
  teal: "#39cccc",
  olive: "#3d9970",
  green: "#2ecc40",
  lime: "#01ff70",
  yellow: "#ffdc00",
  orange: "#ff851b",
  red: "#ff4136",
  maroon: "#85144b",
  fuchsia: "#f012be",
  purple: "#b10dc9",
  black: "#111111",
  gray: "#aaaaaa",
  grey: "#aaaaaa",
  silver: "#dddddd",
  white: "#ffffff",
};
#+END_SRC

** Typography

*** System Font Stacks (=data/typography/system.js=)

This is a lookup table for [[https://systemfontstack.com][system font stacks]] for use by themselves or attached to the end of a font
stack to provide better fallbacks than =sans-serif=, =serif=, or =monospace=.

#+BEGIN_SRC deno :tangle "./data/typography/system.js" :comments link
/** System font stacks: https://systemfontstack.com */
export const SystemFontStacks = {
  "sans-serif":
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  serif:
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  monospace:
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
};
#+END_SRC
