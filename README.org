#+TITLE: Quarks System Core (QSC)
#+AUTHOR: Chatman R. Jr
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:js :results output none :comments link
#+PROPERTY: header-args:deno :allow net :results output code
#+PROPERTY: header-args:shell :results output code

Quarks System Core is a workflow for creating, assembling, and distributing design tokens for and on
the web.

It's part of a growing toolkit called QuarkSuite which focuses on using modern web
technologies to spin up portable, reproducible baselines for web projects.

Think of it like a UI boilerplate generator you can use right in your browser.

Current enhancements to the workflow include Quarks System UI: a tiny collection of web components
for visual development and documentation of Quarks System Dictionaries.

Future enhancements may appear based on community feedback or my own needs.

Quarks System Core is written in web standard JavaScript (ES2015+).

- [[#summary][Summary]]
- [[#features][Features]]
  - [[#color-palettes][Color Palettes]]
  - [[#modular-scales][Modular Scales]]
  - [[#token-formats][Token Formats]]
  - [[#workflow][Workflow]]
- [[#getting-started][Getting Started]]
- [[#installation][Installation]]
  - [[#kitchen-sink][Kitchen Sink]]
  - [[#modular][Modular]]
  - [[#webpackrollup][Webpack/Rollup]]
- [[#examples][Examples]]
  - [[#bleeding-edge-chromium-87][Bleeding Edge (Chromium 87+)]]
    - [[#indexhtml][index.html]]
  - [[#deno-160][Deno (1.6.0+)]]
    - [[#buildjs][build.js]]
    - [[#deno-run][deno run]]
  - [[#node-14160][Node (14.16.0+)]]
    - [[#setup][Setup]]
    - [[#indexjs][index.js]]
    - [[#build][Build]]
  - [[#output][Output]]
- [[#user-guide][User Guide]]
  - [[#basics][Basics]]
    - [[#requirements][Requirements]]
    - [[#color][Color]]
      - [[#1-set-a-base-color][1. set a base color]]
      - [[#2-generate-a-color-scheme][2. generate a color scheme]]
      - [[#3-complete-the-palette][3. complete the palette]]
    - [[#typography][Typography]]
      - [[#1-set-fonts-and-styles][1. set fonts and styles]]
      - [[#2-creating-a-text-size-scale][2. creating a text size scale]]
    - [[#layout][Layout]]
      - [[#1-create-a-measureline-length-scale][1. create a measure/line length scale]]
      - [[#2-create-vertical-rhythmspacing-scale][2. create vertical rhythm/spacing scale]]
  - [[#design-tokens][Design Tokens]]
    - [[#interlude-quarks-system-dictionary][Interlude: Quarks System Dictionary]]
      - [[#value][Value]]
      - [[#scale][Scale]]
      - [[#subcategory][Subcategory]]
      - [[#hierarchy][Hierarchy]]
        - [[#context][Context]]
        - [[#namespace][Namespace]]
    - [[#assemble][Assemble]]
    - [[#build-1][Build]]
    - [[#output-1][Output]]
      - [[#tokenscss][tokens.css]]
      - [[#tokensjson][tokens.json]]
  - [[#recap][Recap]]
  - [[#introduction-to-advanced-concepts][Introduction to Advanced Concepts]]
    - [[#bound-utilities][Bound Utilities]]
    - [[#data-pipelines][Data Pipelines]]
    - [[#configurationsformulas][Configurations/Formulas]]
  - [[#applying-advanced-concepts][Applying Advanced Concepts]]
    - [[#formulasjs][formulas.js]]
      - [[#requirements-1][Requirements]]
      - [[#color-1][Color]]
        - [[#1-create-a-palette-formula][1. create a =Palette= formula]]
      - [[#typography-1][Typography]]
        - [[#1-create-a-stack-formula][1. create a =Stack= formula]]
        - [[#2-create-a-content-configuration][2. create a =Content= configuration]]
        - [[#3-use-the-content-configuration-to-create-a-size-formula][3. use the =Content= configuration to create a =Size= formula]]
      - [[#layout-1][Layout]]
        - [[#1-create-a-measure-formula][1. create a =Measure= formula]]
        - [[#2-use-the-content-configuration-to-create-a-spacing-formula][2. use the =Content= configuration to create a =Spacing= formula]]
    - [[#dictjs][dict.js]]
      - [[#1-import-the-formulas-and-define-settings][1. import the formulas and define settings]]
      - [[#2-construct-the-dictionary][2. construct the dictionary]]
    - [[#buildjs-1][build.js]]
      - [[#1-import-token-functions-and-dictionary][1. import token functions and dictionary]]
      - [[#2-build-tokens][2. build tokens]]
    - [[#run][run]]
- [[#source-code][Source Code]]
  - [[#module-api][Module API]]
    - [[#utilities-utilitiesjs][Utilities (=utilities.js=)]]
      - [[#compose][compose]]
      - [[#pipe][pipe]]
      - [[#tests][Tests]]
        - [[#utilities-assertions][Utilities Assertions]]
        - [[#utilities-results][Utilities Results]]
    - [[#color-colorjs][Color (=color.js=)]]
      - [[#format-conversion][Format Conversion]]
        - [[#hex][hex]]
        - [[#rgb][rgb]]
        - [[#hsl][hsl]]
        - [[#cmyk][cmyk]]
        - [[#hwb][hwb]]
        - [[#cielab][cielab]]
        - [[#cielch][cielch]]
        - [[#oklab][oklab]]
        - [[#compare][compare]]
        - [[#tests-1][Tests]]
          - [[#color-format-conversion-assertions][Color Format Conversion Assertions]]
          - [[#color-format-conversion-results][Color Format Conversion Results]]
      - [[#properties-adjustment][Properties Adjustment]]
        - [[#adjust][adjust]]
        - [[#tests-2][Tests]]
          - [[#color-adjustment-assertions][Color Adjustment Assertions]]
          - [[#color-adjustment-results][Color Adjustment Results]]
      - [[#color-mixture][Color Mixture]]
        - [[#mix][mix]]
        - [[#tests-3][Tests]]
          - [[#color-mixture-assertions][Color Mixture Assertions]]
          - [[#color-mixture-results][Color Mixture Results]]
      - [[#scheme-generation][Scheme Generation]]
        - [[#complementary][complementary]]
        - [[#analogous][analogous]]
        - [[#splitcomplementary][splitComplementary]]
        - [[#triadic][triadic]]
        - [[#tetradic][tetradic]]
        - [[#square][square]]
        - [[#custom][custom]]
        - [[#tests-4][Tests]]
          - [[#color-scheme-generation-assertions][Color Scheme Generation Assertions]]
          - [[#color-scheme-generation-results][Color Scheme Generation Results]]
      - [[#color-scales][Color Scales]]
        - [[#tints][tints]]
        - [[#tones][tones]]
        - [[#shades][shades]]
        - [[#tests-5][Tests]]
          - [[#color-scale-assertions][Color Scale Assertions]]
          - [[#color-scale-results][Color Scale Results]]
      - [[#color-accessibility][Color Accessibility]]
        - [[#clrs][clrs]]
        - [[#contrast][contrast]]
        - [[#tests-6][Tests]]
          - [[#color-accessibility-assertions][Color Accessibility Assertions]]
          - [[#color-accessibility-results][Color Accessibility Results]]
    - [[#typography-typographyjs][Typography (=typography.js=)]]
      - [[#systemfonts][systemfonts]]
      - [[#tests-7][Tests]]
        - [[#typography-assertions][Typography Assertions]]
        - [[#typography-results][Typography Results]]
    - [[#modular-scale-modular_scalejs][Modular Scale (=modular_scale.js=)]]
      - [[#create][create]]
      - [[#update][update]]
      - [[#merge][merge]]
      - [[#chunk][chunk]]
      - [[#units][units]]
      - [[#tests-8][Tests]]
        - [[#modular-scale-assertions][Modular Scale Assertions]]
        - [[#modular-scale-results][Modular Scale Results]]
    - [[#design-token-output-formats-design_tokensjs][Design Token Output Formats (=design_tokens.js=)]]
      - [[#css-design_tokensjs][CSS (=design_tokens.js=)]]
        - [[#css][css]]
        - [[#sass][sass]]
        - [[#less][less]]
        - [[#styl][styl]]
        - [[#tests-9][Tests]]
          - [[#css-format-assertions][CSS Format Assertions]]
          - [[#css-format-results][CSS Format Results]]
      - [[#data-export-design_tokensjs][Data Export (=design_tokens.js=)]]
        - [[#raw][raw]]
        - [[#yaml][yaml]]
        - [[#tests-10][Tests]]
          - [[#data-export-assertions][Data Export Assertions]]
          - [[#data-export-results][Data Export Results]]
      - [[#data-transforms-design_tokensjs][Data Transforms (=design_tokens.js=)]]
        - [[#tailwind][tailwind]]
        - [[#styledict][styledict]]
        - [[#tests-11][Tests]]
          - [[#data-transform-assertions][Data Transform Assertions]]
          - [[#data-transform-results][Data Transform Results]]
  - [[#internals][Internals]]
    - [[#error-handling-internalserrorjs][Error Handling (=internals/error.js=)]]
    - [[#color-2][Color]]
      - [[#supported-formats-internalscolorformatsjs][Supported Formats (=internals/color/formats.js=)]]
        - [[#syntax-tokens][Syntax Tokens]]
        - [[#value-extractors][Value Extractors]]
        - [[#rgb-hex][RGB Hex]]
          - [[#hex-validator][Hex Validator]]
          - [[#hex-value-extraction][Hex Value Extraction]]
        - [[#named-colors][Named Colors]]
        - [[#functional-rgb][Functional RGB]]
          - [[#rgb-validator][RGB Validator]]
          - [[#rgb-value-extraction][RGB Value Extraction]]
        - [[#functional-hsl][Functional HSL]]
          - [[#hsl-validator][HSL Validator]]
          - [[#hsl-value-extraction][HSL Value Extraction]]
        - [[#device-cmyk][Device CMYK]]
          - [[#cmyk-validator][CMYK Validator]]
          - [[#cmyk-value-extraction][CMYK Value Extraction]]
        - [[#functional-hwb][Functional HWB]]
          - [[#hwb-validator][HWB Validator]]
          - [[#hwb-value-extraction][HWB Value Extraction]]
        - [[#functional-cielab][Functional CIELAB]]
          - [[#cielab-validator][CIELAB Validator]]
          - [[#cielab-value-extraction][CIELAB Value Extraction]]
        - [[#functional-cielchab][Functional CIELCh(ab)]]
          - [[#cielchab-validator][CIELCh(ab) Validator]]
          - [[#cielchab-value-extraction][CIELCh(ab) Value Extraction]]
        - [[#oklab-lch][Oklab (LCh)]]
          - [[#oklab-lch-validator][Oklab (LCh) Validator]]
          - [[#oklab-lch-value-extraction][Oklab (LCh) Value Extraction]]
        - [[#batch-validation][Batch Validation]]
      - [[#format-conversions-internalscolorconversionsjs][Format Conversions (=internals/color/conversions.js=)]]
        - [[#rgb-hex-conversions][RGB Hex Conversions]]
          - [[#rgb-hex-to-functional-rgb][RGB Hex to Functional RGB]]
        - [[#named-color-conversion][Named Color Conversion]]
          - [[#rgb-hex-from-named-color][RGB Hex from Named Color]]
        - [[#functional-rgb-conversion][Functional RGB Conversion]]
          - [[#rgb-hex-from-functional-rgb][RGB Hex from Functional RGB]]
          - [[#functional-rgb-to-functional-hsl][Functional RGB to Functional HSL]]
          - [[#functional-rgb-to-device-cmyk][Functional RGB to Device CMYK]]
          - [[#functional-rgb-to-functional-hwb][Functional RGB to Functional HWB]]
          - [[#functional-rgb-to-functional-cielab][Functional RGB to Functional CIELAB]]
          - [[#functional-rgb-to-oklab-lch][Functional RGB to Oklab (LCh)]]
        - [[#functional-hsl-conversion][Functional HSL Conversion]]
          - [[#functional-rgb-from-functional-hsl][Functional RGB from Functional HSL]]
        - [[#device-cmyk-conversion][Device CMYK Conversion]]
          - [[#functional-rgb-from-device-cmyk][Functional RGB from Device CMYK]]
        - [[#functional-hwb-conversion][Functional HWB Conversion]]
          - [[#functional-rgb-from-functional-hwb][Functional RGB from Functional HWB]]
        - [[#functional-cielab-conversion][Functional CIELAB Conversion]]
          - [[#functional-rgb-from-functional-cielab][Functional RGB from Functional CIELAB]]
          - [[#functional-cielab-to-functional-cielchab][Functional CIELAB to Functional CIELCh(ab)]]
        - [[#functional-cielch-conversion][Functional CIELCh Conversion]]
          - [[#functional-cielab-from-functional-cielchab][Functional CIELAB from Functional CIELCh(ab)]]
        - [[#oklab-lch-conversion][Oklab (LCh) Conversion]]
        - [[#batch-conversion][Batch Conversion]]
      - [[#math-internalscolormathjs][Math (=internals/color/math.js=)]]
  - [[#data][Data]]
    - [[#color-3][Color]]
      - [[#w3c-x11-color-definitions-datacolorw3c-x11js][W3C X11 Color Definitions (=data/color/w3c-x11.js=)]]
      - [[#accesible-web-defaults-datacolora11yjs][Accesible Web Defaults (=data/color/a11y.js=)]]
    - [[#typography-2][Typography]]
      - [[#system-font-stacks-datatypographysystemjs][System Font Stacks (=data/typography/system.js=)]]

* Summary

This document is a literate program structured to introduce you to Quarks System Core from a
top-down view. Sections representing source code are marked with their relative location in the
repository and are generously annotated, so if the literal style isn't your jam, you can still read the source itself.

* Features

** General Setup

+ Nothing to install
+ Universal but web focused

** Developer Experience

+ Get started immediately with a single function
+ Power tools available as needed

** Design Tokens

*** Output

+ CSS custom properties
+ Preprocessor variables
+ General data exporting
+ Desktop app support
+ Integration with TailwindCSS and Style Dictionary

*** Color

+ Robust premade palette configurations
+ Full support for current and emerging CSS formats
+ Wield color like a color scientist
+ Built-in Colors project defaults for rapid prototyping

*** Typography

+ System font stacks provided for native OS typography or just to have better fallbacks

*** Modular Scales

+ Enforce consistency in your values
+ Merge, modify, and chunk scales according to your needs
+ Attach units when you're ready to roll

* Just Looking Around

If you just want to inspect what the library makes available and play around with it, load up your
console in a modern browser or run a =deno repl= and paste:

#+BEGIN_SRC js
const QSC = await import("https://x.nest.land/quarksuite:core@1.0.0/main.js");
#+END_SRC

* Getting Started

When you're ready to start a real project with Quarks System Core, get situated with the following
setup code.

#+BEGIN_SRC js
import { QuarksSystemDictionary } from "https://x.nest.land/quarksuite:core@1.0.0/main.js";

QuarksSystemDictionary({}); // empty object generates from default settings
#+END_SRC

That's all you need in native ES Module environments.

** Offline

For an offline workflow, you can =curl= the package source directly.

#+BEGIN_SRC shell
curl -o /path/to/your/local/copy.js https://raw.githubusercontent.com/quarksuite/core/main/mod.js
#+END_SRC

** What About Node?

Using Quarks System Core with Node requires a bit extra, because the runtime doesn't /natively/
support ES Module importing from URLs.

That said, plenty of modern build tools and dev environments in the Node ecosystem /do/. I highly
recommend native ESM dev servers ([[https://www.snowpack.dev/ ][Snowpack]], [[https://vitejs.dev/][Vite]], [[https://kit.svelte.dev/][SvelteKit]], [[https://modern-web.dev/docs/dev-server/overview/][Web Dev Server]], [[https://github.com/preactjs/wmr][WMR]]) when using QSC in
a Node environment.

#+BEGIN_SRC js
export default {
  quarks: {
    color: Palette(color),
    text: {
      body: Stack("Zilla Slab", "serif"),
      headings: Stack("Rubik"),
      code: Stack(null, "monospace"),
      leading: { base: 1.5, tight: 1.25, loose: 1.75 },
      style: { extralight: 100, regular: 400, bold: 700, black: 900 },
      size: Size(scale),
    },
    content: {
      line: Measure(48, 72, scale),
      spacing: Spacing(scale.reverse()),
    },
  },
};
#+END_SRC

*** build.js

**** 1. import token functions and dictionary

#+BEGIN_SRC js
import { exists } from "https://deno.land/std@0.92.0/fs/exists.ts";
import {
  css,
  raw,
} from "https://x.nest.land/quarksuite:core@0.2.1/design_tokens.js";
import { default as dict } from "./dict.js";
#+END_SRC

**** 2. build tokens

#+BEGIN_SRC js
async function main() {
  const encoder = new TextEncoder();
  const path = "tokens";
  const build = () => [
    [css, "index.css"],
    [raw, "index.json"]
  ].forEach(([format, target]) =>
    Deno.writeFile(`${path}/${target}`, encoder.encode(format(dict))));

  if (await exists(path)) {
    build();
  } else {
    await Deno.mkdir(path);
    build();
  }
}

main();
#+END_SRC

*** run

#+BEGIN_SRC shell
deno run --allow-read --allow-write ./build.js
#+END_SRC

* Source Code
** Module API

The API is organized by the kind of data each function accepts.

This means you can jump right to the section for what you need to do. The literate style isn't for
everyone, so headings are appropriately marked with their source location in the repo if you prefer
to leap right into code.

Each section is broken down into:

+ functions: the actual function definitions with developer commentary
+ Tests: proving each function does its job and doesn't choke on the unexpected

As a rule, any files in the project root are public modules while any files in directories are
internal utilities.

Most who use this library will want to import the =mod.js= entry point, but if you only need parts
of it, I recommend and encourage importing directly from the modules that fit your purpose.

#+BEGIN_SRC js :tangle "./mod.js" :comments link
export * from "./utilities.js";
export * from "./color.js";
export * from "./typography.js";
export * from "./modular_scale.js";
export * from "./design_tokens.js";
#+END_SRC

*** Utilities (=utilities.js=)

The Quarks System Core rests on a functional base. It uses a data-last architecture and the
following utilities are designed to take full advantage of this decision.

**** compose

+ =compose: (...operators: Array<(data: any) => any>) => (data: any) => any=
+ =operators: Array<(data: any) ==> any>=: a sequence of data operators


Two conditions must be met for composition:

+ all operators must be functions
+ all functions must be monadic ( =(data: any) => any=)

#+BEGIN_SRC js :tangle "./utilities.js" :comments link
import { ErrorTemplate } from "./internals/error.js";

// Error handling
const isFunction = (x) => typeof x === "function";

/** Error thrown when value is not a function. */
const FuncError = (output) =>
  ErrorTemplate({
    message: "not a function",
    reason: `
This error indicates that one or more of the values is not a
function, so it can't be composed.
`,
    suggestion: `
Check that every value in your composition chain is a function.
`,
    output,
  });

/**
 * A higher order function that accepts a sequence of data operators and combines them
 * into a new function waiting for data.
 *
 * @example Splitting a string after upcasing it.
 *
 * ```ts
 *  const upper = (data) => data.toUpperCase();
 *  const split = (data) => data.split("");
 *
 *  const splitCapitalLetters = compose(upper, split);
 *
 *  splitCapitalLetters("hello"); // ["H", "E", "L", "L", "O"]
 * ```
 *
 * @remark
 * A data operator is also called a unary function. These are both ways of saying a function
 * takes a single argument.
 *
 * @param {((data: any) => any)[]} operators - a sequence of functions to combine
 * @returns {(data: any) => any} the composed function waiting for data  */
export function compose(...operators) {
  return (data) =>
    operators.reduce((value, func) => {
      if (!isFunction(func)) return FuncError(func);
      return func(value);
    }, data);
}
#+END_SRC

**** pipe

+ =(data: any, ...operators: Array<(data: any) => any>) => unknown=
+ =data: unknown=: the data to pass through the pipeline
+ =...operators: Array<(data: any) => any>=: a sequence of data operators

=pipe= inverts the relationship between data and its operators. This is crucial because data
pipelines can be bound (with =Function.bind=)which allows the construction of /queued/ data
transformers.

As you can see, it's a reimplementation of =compose= but with the data as the initial argument and
immediately executes on call.

#+BEGIN_SRC js :tangle "./utilities.js" :comments link
/**
 * A higher order function that pipes data through a sequence of functions and
 * outputs the result.
 *
 * @example Transforming a string into an upcased array.

 * ```ts
 * const upper = (data) => data.toUpperCase();
 * const split = (data) => data.split("");
 *
 * pipe("hello", upper, split); // ["H", "E", "L", "L", "O"]
 * ```
 *
 * @remarks
 * This function simply inverts `compose` so that the data is immediately transformed
 * instead of combining the functions.
 *
 * @param {any} data - the data to pass through the pipeline
 * @param {((data: any) => any)[]} operators - the sequence of functions to transform data
 * @returns {any} The transformed data
 */
export function pipe(data, ...operators) {
  return compose(...operators)(data);
}
#+END_SRC

**** Tests

***** Utilities Assertions

#+BEGIN_SRC js :tangle "./tests/utilities_test.js" :comments link
import { compose, pipe } from "../utilities.js";

import {
  assertEquals,
  assertThrows,

} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const isString = (x) => typeof x === "string";
const isArray = (x) => Array.isArray(x);

const upper = (x) => isString(x) && x.toUpperCase();
const lower = (x) => isString(x) && x.toLowerCase();

const trim = (x) => isString(x) && x.trim();

const split = (x) => isString(x) && x.split("");

const box = (x) => [x];
const unbox = (x) => isArray(x) && x.toString();

Deno.test("SPEC compose: combines two data operators", function () {
  const splitSafe = compose(split, unbox);
    assertEquals(splitSafe("hello"), "h,e,l,l,o");
});

Deno.test("SPEC compose: can combine a chain of data operators", function () {
  const upperSplitSafe = compose(trim, upper, split);
  assertEquals(upperSplitSafe("   hello      "), ["H", "E", "L", "L", "O"]);
});

Deno.test("EDGE compose: rejects values that are not functions", function () {
  const failsFuncClause = compose(split, 5);
  assertThrows(
    () => {
      throw failsFuncClause("hello");
    },
    undefined,
    "not a function",
  );
});

Deno.test("SPEC pipe: can transform data", function () {
  assertEquals(pipe("hello", upper), "HELLO");
});

Deno.test("SPEC pipe: can chain operators", function () {
  assertEquals(
    pipe(
      "hello",
      split,
      (x) => x.map((xs) => xs.charCodeAt(0)),
      (x) => x.map((xs) => xs + 16),
      (x) => x.map((xs) => String.fromCharCode(xs)),
      (x) => x.join(""),
    ),
    "xu||\x7f",
  );
});
#+END_SRC

***** Utilities Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/utilities_test.js)
#+END_SRC

#+NAME: utilities-test
#+begin_src shell
running 5 tests
test SPEC compose: combines two data operators ... ok (5ms)
test SPEC compose: can combine a chain of data operators ... ok (2ms)
test EDGE compose: rejects values that are not functions ... ok (3ms)
test SPEC pipe: can transform data ... ok (1ms)
test SPEC pipe: can chain operators ... ok (2ms)

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (14ms)

#+end_src

*** Color (=color.js=)

Quarks System Core is designed to work with all valid CSS color formats (current and future). The
color module provides utilities for conversion, modification, mixing, generating schemes, and
creating palettes.

**** Format Conversion

The implementation for format conversion is simplified even further as of v0.3.0.

I realized that the common trait all of the formats shared is that to be usable on the web, they
/must/ stay within the sRGB gamut.

So the logical chain is:

1. Convert a valid color to RGB implicitly
2. Convert to the desired =output= /explicitly/

All the conversion interface needs to know is =from[input] -> to[output]=.

The input format is gleaned from an identification key attached to the supported format's
validator. And it will only work with valid colors, throwing a =ColorError= otherwise.

In addition: =output= can also be a list of formats =["hex", "rgb", "hsl"]= for example. So Quarks
System Core can now provide *batch conversion* functionality.

That part comes later, though.

#+BEGIN_SRC js :tangle "./color.js" :comments link
import formats from "./internals/color/formats.js";
import conversions from "./internals/color/conversions.js";
import { ErrorTemplate } from "./internals/error.js";
import { compose, pipe } from "./utilities.js";

const ColorError = (output) =>
  ErrorTemplate({
    message: "not a valid CSS color format",
    reason: `
This error indicates that the color format is invalid or unsupported.
`,
    suggestion: `
Ensure that the input is a valid CSS color.

Examples:

#deaded
#bea
#face
#abcdef68

aliceblue
rebeccapurple

rgb(110, 33, 229)
rgba(139, 110, 19, 0.5)

hsl(300, 89%, 38%)
hsla(3.4rad, 100%, 25%, 0.99)

device-cmyk(0 1 1 0)
device-cmyk(78% 39% 0 0)

hwb(190 39% 3%)

lab(64% 19 -47)

lch(38% 78 147)
`,
    output,
  });

const validate = (color) =>
  Array.from(formats)
    .map(([supported, validator]) => [supported, validator(color) && color])
    .filter(([, found]) => found)
    .flat();

function queryFormats(output, color) {
  const [input, value] = validate(color);
  const $ = compose;
  const C = pipe;
  const _ = conversions;

  const from = {
    named: $(_.hexFromNamed, _.hexToRGB),
    hex: $(_.hexToRGB),
    rgb: (value) => value, // identity,
    hsl: $(_.rgbFromHSL),
    cmyk: $(_.rgbFromCMYK),
    hwb: $(_.rgbFromHWB),
    cielab: $(_.rgbFromCielab),
    cielch: $(_.cielabFromCielch, _.rgbFromCielab),
    oklab: $(_.rgbFromOklab),
  };

  const to = {
    hex: $(_.hexFromRGB),
    rgb: $(_.hexFromRGB, _.hexToRGB), // identity
    hsl: $(_.rgbToHSL),
    cmyk: $(_.rgbToCMYK),
    hwb: $(_.rgbToHWB),
    cielab: $(_.rgbToCielab),
    cielch: $(_.rgbToCielab, _.cielabToCielch),
    oklab: $(_.rgbToOklab),
  };

  return (
    (value && Array.isArray(output)
      ? output.reduce(
        (acc, format) => ({
          ...acc,
          original: value,
          [format]: C(value, from[input], to[format]),
        }),
        {},
      )
      : value && C(value, from[input], to[output])) || ColorError(color)
  );
}
#+END_SRC

***** hex

+ =hex: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to RGB hex.
 *
 * @example Converting RGB to RGB Hex
 *
 * ```ts
 * hex("rgb(0, 0, 0)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to RGB hex
 */
export function hex(color) {
  return queryFormats("hex", color);
}
#+END_SRC

***** rgb

+ =rgb: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to RGB.
 *
 * @example Converting RGB Hex to RGB
 *
 * ```ts
 * rgb("#deaded");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to RGB
 */
export function rgb(color) {
  return queryFormats("rgb", color);
}
#+END_SRC

***** hsl

+ =hsl: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to HSL.
 *
 * @example Converting Device CMYK to HSL
 *
 * ```ts
 * hsl("device-cmyk(30% 0 60% 0)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to HSL
 */
export function hsl(color) {
  return queryFormats("hsl", color);
}
#+END_SRC

***** cmyk

+ =cmyk: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to CMYK
 *
 * @example Converting HSL to Device CMYK
 *
 * ```ts
 * cmyk("hsl(97, 63%, 81%)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to CMYK
 */
export function cmyk(color) {
  return queryFormats("cmyk", color);
}
#+END_SRC

***** hwb

+ =hwb: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to HWB.
 *
 * @example Converting CIELCH to HWB
 *
 * ```ts
 * hwb("lch(78% 83 210)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to HWB
 */
export function hwb(color) {
  return queryFormats("hwb", color);
}
#+END_SRC

***** cielab

+ =cielab: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to CIELAB.
 *
 * @example Convert HWB to CIELAB
 *
 * ```ts
 * cielab("hwb(90 25% 10%)");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to CIELAB
 */
export function cielab(color) {
  return queryFormats("cielab", color);
}
#+END_SRC

***** cielch

+ =cielch: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to CIELCh(ab).
 *
 * @example Convert CIELCh(ab) to RGB Hex
 *
 * ```ts
 * cielch("#face");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to CIELCh(ab)
 */
export function cielch(color) {
  return queryFormats("cielch", color);
}
#+END_SRC

***** oklab

+ =oklab: (color: string) => string=
+ =color: string=: the input color to convert

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that converts any valid CSS color to _non-standard_ Oklab (LCh).
 *
 * @example Convert Oklab (LCh) to RGB Hex
 *
 * ```ts
 * oklab("#face");
 * ```
 *
 * @param {string} color - the input color to convert
 * @returns {string} the input color converted to Oklab (LCh)
 */
export function oklab(color) {
  return queryFormats("oklab", color);
}
#+END_SRC

***** compare

+ =compare: (formats: string[], color: string) => object=
+ =formats: string[]=: an array of formats to compare
+ =color: string=: the input color to convert

  New in v0.3.0 is the =compare()= function. Its main purpose is to generate a dictionary from your
  color in formats you may want to use. It's also a handy way of exploring some of the lesser known
  formats.

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function that batch converts a valid CSS color as a dictionary of formats.
 *
 * @example Comparing the hex, rgb, and hsl values of chartreuse
 *
 * ```ts
 * compare(["hex", "rgb", "hsl"], "chartreuse");
 *
 *
 * @param {("hex" | "rgb" | "hsl" | "cmyk" | "hwb" | "cielab" | "cielch" | "oklab")[]} formats - an array of formats to compare
 * @param {string} color - the input color to convert
 * @returns {{original: string, hex?: string, rgb?: string, hsl?: string, cmyk?: string, hwb?: string, cielab?: string, cielch?: string, oklab?: string }} dictionary containing the original input color as well as the requested formats
 */
export function compare(formats, color) {
  return queryFormats(formats, color);
}
#+END_SRC

***** Tests

Catching color errors before they show up in someone else's interface is crucial because *color is
hard*.

Since I've included extensive conversion examples in the internal conversion documentation, I'll be
plugging some values to test the conversion chaining and error reporting.

****** Color Format Conversion Assertions

#+BEGIN_SRC js :tangle "./tests/color_conversion_test.js" :comments link
import { cmyk, hex, hsl, hwb, lab, lch, oklab, rgb } from "../color.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const conversions = { hex, rgb, hsl, cmyk, hwb, lab, lch, oklab };

const samples = {
  hex: "#348ec9",
  rgb: "rgb(30, 119, 200)",
  hsl: "hsl(300, 78%, 69%)",
  cmyk: "device-cmyk(49% 2% 10% 0%)",
  hwb: "hwb(145 30% 5%)",
  lab: "lab(43.319% -42 -8)",
  lch: "lch(85.19% 73.81 67.142)",
  oklab: "oklab(67.39% 0.3418 42)",
};

const colors = [
  "midnightblue",
  "gainsboro",
  "cornsilk",
  "crimson",
  "springgreen",
  "rebeccapurple",
];

colors.forEach((color) => {
  Object.entries(conversions).forEach(([format, fn]) =>
    Deno.test(
      `SPEC try ${color} ${format.toUpperCase()}: "${fn(color)}"`,
      function () {
        assertEquals(fn(color), fn(color));
      },
    )
  );
});

Deno.test(
  `EDGE: does nothing when input is the same format as target conversion`,
  function () {
    Object.entries(conversions).forEach(([format, fn]) =>
      assertEquals(fn(samples[format]), samples[format])
    );
  },
);

Deno.test(`EDGE: rejects invalid or unsupported color formats`, function () {
  Object.values(conversions).forEach((fn) =>
    assertThrows(
      () => {
        throw fn("invalid");
      },
      undefined,
      "not a valid CSS color",
    )
  );
});
#+END_SRC

****** Color Format Conversion Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/color_conversion_test.js)
#+END_SRC

#+NAME: conversion-test
#+begin_src shell
running 50 tests
test SPEC try midnightblue HEX: "#191970" ... ok (4ms)
test SPEC try midnightblue RGB: "rgb(25, 25, 112)" ... ok (2ms)
test SPEC try midnightblue HSL: "hsl(240, 63.504%, 26.863%)" ... ok (2ms)
test SPEC try midnightblue CMYK: "device-cmyk(77.679% 77.679% 0% 56.078%)" ... ok (2ms)
test SPEC try midnightblue HWB: "hwb(240 9.8039% 56.078%)" ... ok (2ms)
test SPEC try midnightblue LAB: "lab(14.928% 25.96 -50.904)" ... ok (2ms)
test SPEC try midnightblue LCH: "lch(14.928% 57.141 297.021)" ... ok (2ms)
test SPEC try midnightblue OKLAB: "oklab(28.812% 0.14363 272.765)" ... ok (2ms)
test SPEC try gainsboro HEX: "#dcdcdc" ... ok (2ms)
test SPEC try gainsboro RGB: "rgb(220, 220, 220)" ... ok (2ms)
test SPEC try gainsboro HSL: "hsl(0, 0%, 86.275%)" ... ok (2ms)
test SPEC try gainsboro CMYK: "device-cmyk(0% 0% 0% 13.726%)" ... ok (2ms)
test SPEC try gainsboro HWB: "hwb(0 86.275% 13.726%)" ... ok (2ms)
test SPEC try gainsboro LAB: "lab(87.761% 0 0)" ... ok (2ms)
test SPEC try gainsboro LCH: "lch(87.761% 0 0)" ... ok (2ms)
test SPEC try gainsboro OKLAB: "oklab(89.449% 0 89.876)" ... ok (2ms)
test SPEC try cornsilk HEX: "#fff8dc" ... ok (2ms)
test SPEC try cornsilk RGB: "rgb(255, 248, 220)" ... ok (2ms)
test SPEC try cornsilk HSL: "hsl(48, 100%, 93.137%)" ... ok (2ms)
test SPEC try cornsilk CMYK: "device-cmyk(0% 2.7451% 13.726% 0%)" ... ok (2ms)
test SPEC try cornsilk HWB: "hwb(48 86.275% 0%)" ... ok (2ms)
test SPEC try cornsilk LAB: "lab(97.584% -0.95546 14.387)" ... ok (2ms)
test SPEC try cornsilk LCH: "lch(97.584% 14.419 93.8)" ... ok (2ms)
test SPEC try cornsilk OKLAB: "oklab(97.73% 0.03726 95.439)" ... ok (2ms)
test SPEC try crimson HEX: "#dc143c" ... ok (2ms)
test SPEC try crimson RGB: "rgb(220, 20, 60)" ... ok (2ms)
test SPEC try crimson HSL: "hsl(348, 83.333%, 47.059%)" ... ok (2ms)
test SPEC try crimson CMYK: "device-cmyk(0% 90.909% 72.727% 13.726%)" ... ok (2ms)
test SPEC try crimson HWB: "hwb(348 7.8431% 13.726%)" ... ok (3ms)
test SPEC try crimson LAB: "lab(47.88% 71.283 35.481)" ... ok (2ms)
test SPEC try crimson LCH: "lch(47.88% 79.625 26.462)" ... ok (3ms)
test SPEC try crimson OKLAB: "oklab(57.119% 0.22194 20.087)" ... ok (2ms)
test SPEC try springgreen HEX: "#00ff7f" ... ok (3ms)
test SPEC try springgreen RGB: "rgb(0, 255, 127)" ... ok (2ms)
test SPEC try springgreen HSL: "hsl(150, 100%, 50%)" ... ok (3ms)
test SPEC try springgreen CMYK: "device-cmyk(100% 0% 50.196% 0%)" ... ok (2ms)
test SPEC try springgreen HWB: "hwb(150 0% 0%)" ... ok (3ms)
test SPEC try springgreen LAB: "lab(88.435% -72.513 45.975)" ... ok (3ms)
test SPEC try springgreen LCH: "lch(88.435% 85.859 147.62)" ... ok (3ms)
test SPEC try springgreen OKLAB: "oklab(87.493% 0.23526 151.02)" ... ok (1ms)
test SPEC try rebeccapurple HEX: "#663399" ... ok (2ms)
test SPEC try rebeccapurple RGB: "rgb(102, 51, 153)" ... ok (2ms)
test SPEC try rebeccapurple HSL: "hsl(270, 50%, 40%)" ... ok (3ms)
test SPEC try rebeccapurple CMYK: "device-cmyk(33.333% 66.667% 0% 40%)" ... ok (1ms)
test SPEC try rebeccapurple HWB: "hwb(270 20% 40%)" ... ok (2ms)
test SPEC try rebeccapurple LAB: "lab(32.393% 38.428 -47.69)" ... ok (2ms)
test SPEC try rebeccapurple LCH: "lch(32.393% 61.246 308.861)" ... ok (3ms)
test SPEC try rebeccapurple OKLAB: "oklab(44.027% 0.1603 303.373)" ... ok (2ms)
test EDGE: does nothing when input is the same format as target conversion ... ok (3ms)
test EDGE: rejects invalid or unsupported color formats ... ok (5ms)

test result: ok. 50 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (115ms)

#+end_src

**** Properties Adjustment

After ensuring that color conversion is rock solid, the possibilities for adjustment open up. The
main ways to adjust a color include:

+ Hue: the perceptual identity of a color. Hue is the way we perceive a color. The qualitative
  difference between red and cyan.
+ Saturation/Chroma: the given amount of a color. Saturation represents color /intensity/.
+ Lightness/Luminance: the amount of light a color reflects or absorbs. An indication of whether a
  a color is pure, a shade, or  a tint/pastel.
+ Alpha/Transparency: the opacity of a color. Whether a color is solid or lets light through.

Quark System Core used to adjust through the HSL color space, but then I realized it would be far
more accurate to handle them through CIELCh(ab). As a perceptually uniform space, it allows explicit
adjustment of color properties whereas HSL would usually implicitly adjust some other property.

However, I ran into some hue shifting issues and wasn't satisfied with the way CIELAB handles chroma
and lightness predictions which led me to implement Oklab as the color space for property adjustments.

I also want to be able to preserve the input format of a color after adjustment so /you/ won't have to
think about it when you use these functions.

#+BEGIN_SRC js :tangle "./color.js" :comments link
import { valueExtractor } from "./internals/color/formats.js";
import {
  calcFractionFromPercent,
  correctHueClockwise,
  correctHueCounterClockwise,
  enforcePrecision,
  normalize,
} from "./internals/color/math.js";

// Secondary format validation
function preserve(target, color) {
  const [format] = validate(color);

  const revert = {
    named: hex(target),
    hex: hex(target),
    rgb: rgb(target),
    hsl: hsl(target),
    cmyk: cmyk(target),
    hwb: hwb(target),
    cielab: cielab(target),
    cielch: cielch(target),
    oklab: oklab(target),
  };

  return revert[format] || ColorError(color);
}
#+END_SRC

The simple method performs a /secondary/ color validation for the input and passes the resulting
Oklab (LCh) color after adjustment along to its conversion function.

***** adjust

As of v0.3.0, the monadic property adjustment functions are gone. I realized it was pretty rare for
me to only adjust one color property at a time.

+ =adjust({ l?: number, c?: number, h?: number, a?: number }, color: string) => string=
+ ={ l?: number, c?: number, h?: number, a?: number }=: a configuration object with
  options corresponding with the adjustable properties

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function for adjusting the properties of a color.
 *
 * @example Rotating the hue of coral a third and reducing the chroma by 10%.
 *
 * ```ts
 * adjust({ h: 120, c: -10 }, "coral");
 *
 *
 * @param {{l?: number, c?: number, h?: number, a?: number}} properties - configuration for adjusting the (l)ightness/luminance, (c)hroma, (h)ue, and/or (a)lpha/transparency of a color
 * @param {string} color - the input color for adjustment
 * @returns {string} the adjusted color
 */
export function adjust({ l, c, h, a }, color) {
  const [lightness, chroma, hue, alpha] = pipe(
    color,
    queryFormats.bind(null, "oklab"),
    valueExtractor,
    (components) => components.map((value) => parseFloat(value)),
  );

  let { l: L, c: C, h: H, a: A } = Object.assign({
    l: lightness,
    c: chroma,
    h: hue,
    a: (alpha && (alpha ?? 1)) || 1,
  });

  if (l) {
    L = normalize(0, enforcePrecision(lightness + l), 100);
  }

  if (c) {
    C = normalize(
      0,
      enforcePrecision(chroma + calcFractionFromPercent(c)),
      0.5,
    );
  }

  if (h) {
    let HUE_ADJUSTMENT = enforcePrecision(hue + h);

    // Hue correction
    if (HUE_ADJUSTMENT > 360) {
      H = correctHueClockwise(HUE_ADJUSTMENT);
    } else if (Math.sign(HUE_ADJUSTMENT) === -1) {
      H = pipe(HUE_ADJUSTMENT, correctHueClockwise, correctHueCounterClockwise);
    } else {
      H = HUE_ADJUSTMENT;
    }
  }

  if (a) {
    A = normalize(
      0,
      enforcePrecision((alpha ?? 1) + calcFractionFromPercent(a)),
      1,
    );
  }

  return preserve(
    A === 1 ? `oklab(${L}% ${C} ${H})` : `oklab(${L}% ${C} ${H} / ${A})`,
    color,
  );
}
#+END_SRC

***** Tests

****** Color Adjustment Assertions

#+BEGIN_SRC js :tangle "./tests/color_adjust_test.js" :comments link
import {
  a,
  alpha,
  h,
  hue,
  l,
  lightness,
  luminance,
  s,
  sat,
  saturation,
  transparency,
} from "../color.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC hue: can adjust clockwise", function () {
  const color = "red";

  assertEquals(hue(15, color), "#fa2a00");
  assertEquals(hue(30, color), "#ef4600");
  assertEquals(hue(45, color), "#de5f00");
  assertEquals(hue(60, color), "#c57500");
  assertEquals(hue(75, color), "#a58900");
  assertEquals(hue(90, color), "#7b9900");
});

Deno.test("SPEC hue: can adjust counterclockwise", function () {
  const color = "lime";

  assertEquals(hue(-15, color), "#9bf200");
  assertEquals(hue(-30, color), "#dbe100");
  assertEquals(hue(-45, color), "#ffcc00");
  assertEquals(hue(-60, color), "#ffb400");
  assertEquals(hue(-75, color), "#ff9b00");
  assertEquals(hue(-90, color), "#ff8300");
});

Deno.test("SPEC hue: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#ffdef1"],
    ["midnightblue", "#432300"],
    ["rgb(255, 133, 30)", "rgb(0, 186, 255)"],
    ["hsl(300, 40%, 70%)", "hsl(125, 34.021%, 61.961%)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(0% 46.667% 0% 0%)"],
    ["hwb(120 30% 20%)", "hwb(294 47.843% 3.9216%)"],
    ["lab(36.44% 30 -79)", "lab(39.711% 31.523 49.911)"],
    ["lch(63.198% 36 135)", "lch(60.635% 35.048 318.44)"],
    ["oklab(56% 0.25 240)", "oklab(56% 0.25 60)"],
  ];

  colors.forEach(([input, target]) => assertEquals(hue(180, input), target));
});

Deno.test("EDGE hue: rejects invalid color", function () {
  assertThrows(
    () => {
      throw hue(16, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});

Deno.test("ALIAS h of hue", function () {
  assertEquals(h(33, "hwb(60 38% 0%)"), "hwb(114 64.314% 0%)");
});

Deno.test("SPEC saturation: can saturate a color", function () {
  const color = "cadetblue";

  assertEquals(saturation(4, color), "#48a1a4");
  assertEquals(saturation(8, color), "#22a5a9");
  assertEquals(saturation(16, color), "#00abb2");
  assertEquals(saturation(32, color), "#00b5c3");
  assertEquals(saturation(64, color), "#00c5e6");
});

Deno.test("SPEC saturation: can desaturate a color", function () {
  const color = "chartreuse";

  assertEquals(saturation(-4, color), "#88fd39");
  assertEquals(saturation(-8, color), "#91fb51");
  assertEquals(saturation(-16, color), "#a0f673");
  assertEquals(saturation(-32, color), "#bceba6");
  assertEquals(saturation(-64, color), "#dbdbdb");
});

Deno.test("SPEC saturation: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#efefef"],
    ["midnightblue", "#2b2b2b"],
    ["rgb(255, 133, 30)", "rgb(171, 171, 171)"],
    ["hsl(300, 40%, 70%)", "hsl(0, 0%, 67.451%)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(7.7982% 0% 7.7982% 14.51%)"],
    ["hwb(120 30% 20%)", "hwb(0 67.843% 32.157%)"],
    ["lab(36.44% 30 -79)", "lab(39.49% 0 0)"],
    ["lch(63.198% 36 135)", "lch(62.082% 0 0)"],
    ["oklab(56% 0.25 240)", "oklab(56% 0.010000000000000009 240)"],
  ];

  colors.forEach(([input, target]) =>
    assertEquals(saturation(-48, input), target)
  );
});

Deno.test("EDGE saturation: rejects invalid color", function () {
  assertThrows(
    () => {
      throw saturation(16, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});

Deno.test("ALIAS sat of saturation", function () {
  assertEquals(sat(-16, "chocolate"), "#b07d61");
});

Deno.test("ALIAS s of saturation", function () {
  assertEquals(s(-8, "burlywood"), "#cebca5");
});

Deno.test("SPEC lightness: can lighten a color", function () {
  const color = "midnightblue";

  assertEquals(lightness(4, color), "#21267d");
  assertEquals(lightness(8, color), "#293289");
  assertEquals(lightness(16, color), "#3c4aa3");
  assertEquals(lightness(32, color), "#677ad8");
  assertEquals(lightness(64, color), "#c7e0ff");
});

Deno.test("SPEC lightness: can darken a color", function () {
  const color = "cornsilk";

  assertEquals(lightness(-4, color), "#f2ebcf");
  assertEquals(lightness(-8, color), "#e4ddc2");
  assertEquals(lightness(-16, color), "#cac4a9");
  assertEquals(lightness(-32, color), "#989278");
  assertEquals(lightness(-64, color), "#3d3721");
});

Deno.test("SPEC lightness: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#cffffe"],
    ["midnightblue", "#95acff"],
    ["rgb(255, 133, 30)", "rgb(255, 219, 131)"],
    ["hsl(300, 40%, 70%)", "hsl(300, 100%, 95.098%)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(59.608% 0% 50.98% 0%)"],
    ["hwb(120 30% 20%)", "hwb(117 62.745% 0%)"],
    ["lab(36.44% 30 -79)", "lab(88.646% -18.579 -17.461)"],
    ["lch(63.198% 36 135)", "lch(96.589% 25.863 133.94)"],
    ["oklab(56% 0.25 240)", "oklab(100% 0.25 240)"],
  ];

  colors.forEach(([input, target]) =>
    assertEquals(lightness(48, input), target)
  );
});

Deno.test("EDGE lightness: rejects invalid color", function () {
  assertThrows(
    () => {
      throw lightness(16, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});

Deno.test("ALIAS luminance of lightness", function () {
  assertEquals(
    luminance(12, "lab(38.1993% -39 -147.39)"),
    "lab(63.564% -4.8385 -56.459)",
  );
});

Deno.test("ALIAS l of lightness", function () {
  assertEquals(l(30, "slategray"), "#ccdef0");
});

Deno.test("SPEC alpha: can increase", function () {
  const color = "#abcdef68";

  assertEquals(alpha(4, color), "#abcdef72");
  assertEquals(alpha(8, color), "#abcdef7c");
  assertEquals(alpha(16, color), "#abcdef91");
  assertEquals(alpha(32, color), "#abcdefba");
  assertEquals(alpha(64, color), "#abcdef");
});

Deno.test("SPEC alpha: can decrease", function () {
  const color = "#abcdef";

  assertEquals(alpha(-4, color), "#abcdeff5");
  assertEquals(alpha(-8, color), "#abcdefeb");
  assertEquals(alpha(-16, color), "#abcdefd6");
  assertEquals(alpha(-32, color), "#abcdefad");
  assertEquals(alpha(-64, color), "#abcdef5c");
});

Deno.test("SPEC alpha: can adjust all supported formats", function () {
  const colors = [
    ["#c0ffee", "#c0ffeebf"],
    ["midnightblue", "#191970bf"],
    ["rgb(255, 133, 30)", "rgba(255, 133, 30, 0.75)"],
    ["hsl(300, 40%, 70%)", "hsla(300, 39.869%, 70%, 0.75)"],
    ["device-cmyk(90% 0% 70% 0%)", "device-cmyk(89.804% 0% 69.804% 0% / 0.75)"],
    ["hwb(120 30% 20%)", "hwb(120 30.196% 20% / 0.75)"],
    ["lab(36.44% 30 -79)", "lab(36.39% 30.198 -79.154 / 0.75)"],
    ["lch(63.198% 36 135)", "lch(63.182% 35.872 135.17 / 0.75)"],
    ["oklab(56% 0.25 240)", "oklab(56% 0.25 240 / 0.75)"],
  ];

  colors.forEach(([input, target]) => assertEquals(alpha(-25, input), target));
});

Deno.test("ALIAS transparency of alpha", function () {
  assertEquals(transparency(-25, "#deaded"), "#deadedbf");
});

Deno.test("ALIAS a of alpha", function () {
  assertEquals(a(-64, "#deaded"), "#deaded5c");
});
#+END_SRC

****** Color Adjustment Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/color_adjust_test.js)
#+END_SRC

#+NAME: adjustment-test
#+begin_src shell
running 22 tests
test SPEC hue: can adjust clockwise ... ok (18ms)
test SPEC hue: can adjust counterclockwise ... ok (5ms)
test SPEC hue: can adjust all supported formats ... ok (11ms)
test EDGE hue: rejects invalid color ... ok (3ms)
test ALIAS h of hue ... ok (2ms)
test SPEC saturation: can saturate a color ... ok (4ms)
test SPEC saturation: can desaturate a color ... ok (3ms)
test SPEC saturation: can adjust all supported formats ... ok (6ms)
test EDGE saturation: rejects invalid color ... ok (2ms)
test ALIAS sat of saturation ... ok (2ms)
test ALIAS s of saturation ... ok (2ms)
test SPEC lightness: can lighten a color ... ok (4ms)
test SPEC lightness: can darken a color ... ok (3ms)
test SPEC lightness: can adjust all supported formats ... ok (5ms)
test EDGE lightness: rejects invalid color ... ok (2ms)
test ALIAS luminance of lightness ... ok (2ms)
test ALIAS l of lightness ... ok (3ms)
test SPEC alpha: can increase ... ok (2ms)
test SPEC alpha: can decrease ... ok (4ms)
test SPEC alpha: can adjust all supported formats ... ok (6ms)
test ALIAS transparency of alpha ... ok (2ms)
test ALIAS a of alpha ... ok (2ms)

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (94ms)

#+end_src

**** Color Mixture

***** mix

+ =mix: (amount: number, target: string, color: string) => string=
+ =amount: number=: the amount to mix with target (as a percentage)
+ =target: string=: the blending target to mix with input color
+ =color: string=: the input color

The color mixing implementation works similar to the color adjustment functions in that the result
will have the same format as the /input/ color. This means the target color to mix with can be /any/
valid CSS format.

First, I import some helpers from other modules.

#+BEGIN_SRC js :tangle "./color.js" :comments link
import {
  calcFractionFromPercent,
  calcPercentFromFraction,
  significant,
} from "./internals/color/convert/setup.js";
import { parseOklab } from "./internals/color/convert/oklab.js";
#+END_SRC

=calcMixture()= was updated in v0.2.0 to use a linear interpolation formula with raw Oklab
values. Not only is the math less complex, the mixtures are more accurate and account for the
presence of an alpha component without additional operations.

#+BEGIN_SRC js :tangle "./color.js" :comments link
function calcMixture(original, target, amount) {
  const [OL, Oa, Ob, Oalpha] = original;
  const [TL, Ta, Tb, Talpha] = target;

  const OA = parseFloat(Oalpha ?? 1);
  const TA = parseFloat(Talpha ?? 1);

  return [
    [OL, TL],
    [Oa, Ta],
    [Ob, Tb],
    [OA, TA],
  ].map(([X, Y]) => X + (Y - X) * amount);
}
#+END_SRC

Finally, the public function executes the mix. You can see here that the Oklab (LCh) is converted
back to rectangular coordinates to apply the mixture formula and then reverted to its string data form.

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * A function for mixing colors of any valid CSS format.
 *
 *
 * @example Even mixture
 *
 * ```ts
 * mix(50, 'red', 'blue');
 * ```
 *
 * @example Farther from target
 *
 * ```ts
 * mix(34, 'green', 'blue');
 * ```
 *
 * @example Closer to target
 *
 * ```ts
 * mix(75, 'blue', 'white');
 * ```
 *
 * @remarks
 * As a percentage, the amount is bound to a range of 0-100%. At 0%
 * it yields the input color. And at 100%, it yields the target color
 *
 * @param {number} amount - the amount to mix with target (as a percentage)
 * @param {string} target - the mixture target
 * @param {string} color - the input color
 * @returns {string} The mixture result
 */
export function mix(amount, target, color) {
  // Convert both colors to raw Oklab
  const c1 = pipe(color, oklab, extract, parseOklab);
  const c2 = pipe(target, oklab, extract, parseOklab);

  // calculate the mixture
  const [l, a, b, alpha] = calcMixture(c1, c2, calcFractionFromPercent(amount));

  // Convert result back to Oklab (LCh)
  const [L, C, h] = [
    calcPercentFromFraction(l),
    Math.sqrt(a ** 2 + b ** 2),
    Math.atan2(b, a) * (180 / Math.PI),
  ];

  // Hue correction
  let H = Math.sign(h) === -1 ? h + 360 : h;

  return preserve(
    alpha === 1
      ? `oklab(${L}% ${C} ${H})`
      : `oklab(${L}% ${C} ${H} / ${alpha})`,
    color,
  );
}
#+END_SRC

***** Tests

****** Color Mixture Assertions

#+BEGIN_SRC js :tangle "./tests/color_mixture_test.js" :comments link
import { mix } from "../color.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC mix: can mix colors freely", function () {
  const red = "#f00";
  const yellow = "#ff0";
  const green = "#0f0";
  const cyan = "#0ff";
  const blue = "#00f";
  const magenta = "#f0f";
  const white = "#fff";
  const gray = "#808080";
  const black = "#000";

  const colors = [
    [red, "#ff6a00", "#ffa000", "#ffd100", "#ffff00", yellow],
    [red, "#ed7300", "#d0a801", "#a0d500", "#00ff00", green],
    [red, "#ee745b", "#d2a993", "#a3d6c9", "#00ffff", cyan],
    [red, "#c6496d", "#8c53a2", "#5147d2", "#0000ff", blue],
    [red, "#fe2464", "#fd2d9b", "#fe28ce", "#ff00ff", magenta],
    [red, "#ff6b59", "#ffa191", "#ffd1c8", "#ffffff", white],
    [red, "#e3493a", "#c66356", "#a5746c", "#808080", gray],
    [red, "#ae0000", "#630000", "#220000", "#000000", black],
    [yellow, "#daff00", "#b0ff00", "#7cff00", "#00ff00", green],
    [yellow, "#daff7c", "#b0ffb0", "#7cffda", "#00ffff", cyan],
    [yellow, "#b5d797", "#6cabc7", "#1d77e7", "#0000ff", blue],
    [yellow, "#ffd88a", "#ffadbc", "#ff79e1", "#ff00ff", magenta],
    [yellow, "#feff78", "#feffac", "#feffd7", "#ffffff", white],
    [yellow, "#dddf54", "#bdbf6c", "#9e9f79", "#808080", gray],
    [yellow, "#aeae00", "#636300", "#222200", "#000000", black],
    [green, "#00ff74", "#00ffa9", "#00ffd6", "#00ffff", cyan],
    [green, "#00d68d", "#00aabf", "#0075e2", "#0000ff", blue],
    [green, "#95dc81", "#c6b4b4", "#e780dc", "#ff00ff", magenta],
    [green, "#79ff71", "#adffa6", "#d8ffd4", "#ffffff", white],
    [green, "#54df4e", "#6dc067", "#7aa076", "#808080", gray],
    [green, "#00ae00", "#006300", "#002200", "#000000", black],
    [cyan, "#00d1ff", "#00a0ff", "#006aff", "#0000ff", blue],
    [cyan, "#9bd8ff", "#ccacff", "#ea78ff", "#ff00ff", magenta],
    [cyan, "#7dffff", "#b1ffff", "#daffff", "#ffffff", white],
    [cyan, "#58dede", "#70bebe", "#7c9f9e", "#808080", gray],
    [cyan, "#00aeae", "#006363", "#002222", "#000000", black],
    [blue, "#572dff", "#9038ff", "#c732ff", "#ff00ff", magenta],
    [blue, "#306dff", "#73a3ff", "#b8d2ff", "#ffffff", white],
    [blue, "#144ae2", "#3b64c4", "#5e75a4", "#808080", gray],
    [blue, "#0000ae", "#000063", "#000022", "#000000", black],
    [magenta, "#ff71ff", "#ffa6ff", "#ffd4ff", "#ffffff", white],
    [magenta, "#e14edf", "#c367c0", "#a376a0", "#808080", gray],
    [magenta, "#ae00ae", "#630063", "#220022", "#000000", black],
    [white, "#dedede", "#bdbdbd", "#9e9e9e", "#808080", gray],
    [white, "#aeaeae", "#636363", "#222222", "#000000", black],
    [gray, "#555555", "#2e2e2e", "#0b0b0b", "#000000", black],
  ];

  colors.forEach(([color, slightly, evenly, heavily, fully, target]) => {
    assertEquals(mix(25, target, color), slightly);
    assertEquals(mix(50, target, color), evenly);
    assertEquals(mix(75, target, color), heavily);
    assertEquals(mix(100, target, color), fully);
  });
});

Deno.test("SPEC mix: can mix colors with alpha property", function () {
  assertEquals(mix(50, "#ce9ddaef", "#c91193"), "#cf67b6f7");
  assertEquals(mix(75, "#deaded", "#face"), "#e6ade5fb");
  assertEquals(mix(95, "#3ad9cfc5", "#cc911df9"), "#4dd6c8c8");
});

Deno.test("SPEC mix: can mix colors of any valid format", function () {
  const colors = [
    ["#c99faa", "#f05e56", "red"],
    ["rgb(118, 20, 250)", "rgb(194, 194, 169)", "yellow"],
    ["hsl(320, 70%, 31%)", "hsl(93, 38.462%, 51.569%)", "lime"],
    [
      "device-cmyk(0% 79% 32% 0%)",
      "device-cmyk(18.667% 12% 0% 11.765%)",
      "cyan",
    ],
    ["hwb(148 28% 38%)", "hwb(211 0% 17.647%)", "blue"],
    ["lab(46.48% -38 120)", "lab(55.959% 46.101 -25.021)", "magenta"],
    ["lch(89.311% 63 300)", "lch(80.57% 33.332 315.903)", "#deaded"],
    [
      "oklab(49% 0.3 78)",
      "oklab(78.6333% 0.11027189298674138 100.66588617825195)",
      "#c0ffee",
    ],
  ];

  colors.forEach(([color, blend, target]) =>
    assertEquals(mix(64, target, color), blend)
  );
});

Deno.test("EDGE mix: throws error when either color is invalid", function () {
  assertThrows(
    () => {
      throw mix(40, "invalid", "#c0ffee");
    },
    undefined,
    "not a valid CSS color",
  );
  assertThrows(
    () => {
      throw mix(40, "#deaded", "c0ffee");
    },
    undefined,
    "not a valid CSS color",
  );
  assertThrows(
    () => {
      throw mix(40, "invalid", "c0ffee");
    },
    undefined,
    "not a valid CSS color",
  );
});
#+END_SRC

****** Color Mixture Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/color_mixture_test.js)
#+END_SRC

#+NAME: mix-test
#+begin_src shell
running 4 tests
test SPEC mix: can mix colors freely ... ok (90ms)
test SPEC mix: can mix colors with alpha property ... ok (3ms)
test SPEC mix: can mix colors of any valid format ... ok (11ms)
test EDGE mix: throws error when either color is invalid ... ok (3ms)

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (108ms)

#+end_src

**** Scheme Generation

Color schemes are a way of adding more visual interest and tension to a design. The primary scheme
configurations used in digital design include:

+ Monochromatic: a single color scheme consisting of a base color and palette variants (tints,
  tones, and/or shades) of that color
+ Analogous: a multi-color scheme consisting of a base color and a selection of hues directly next
  to it on the color wheel. Examples: red, orange, yellow or red, magenta-red, magenta
+ Complementary: a two color scheme consisting of a base color and its complement (opposite) on the
  color wheel. Examples: red and cyan or green and magenta
+ Split-Complementary: A three color scheme consisting of a base color and two hues on either side
  of its complement. Example: red, cyan-blue, green-cyan
+ Triadic: a color scheme consisting of three colors equally spaced around the color wheel. Example:
  red, green, blue
+ Tetradic/Dual: a four color scheme consisting of a base color, its complement, and a rotational
  offset of both points; creating a rectangle
+ Square: a color scheme consisting of four colors equally spaced around the color wheel

Besides providing functions for each of the basic color schemes, Quarks System Core also provides
a function for generating custom schemes.

Compared with QuarkSuite 1, QSC eliminates scheme boilerplate and leaves calculation and offset
adjustments for the custom function.

***** complementary

+ =complementary: (color: string) => [string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC js :tangle "./color.js" :comments link
import { hue } from "./color.js";

/**
 * Creates a complementary color scheme from any valid CSS color.
 *
 * @example Creating a complementary scheme
 *
 * ```ts
 * complementary("coral");
 * ```
 *
 * @remarks
 * A complementary color scheme is composed of a base color and its
 * opposite on the color wheel. It is a scheme with the highest possible
 * warm/cool color contrast.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string]} The base hues for a complementary color scheme
 */
export const complementary = (color) => [hue(0, color), hue(180, color)];
#+END_SRC

***** analogous

+ =analogous: (color: string) => [string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Creates an analogous color scheme from any valid CSS color.
 *
 * @example Creating an analogous color scheme
 *
 * ```ts
 * analogous("coral");
 * ```
 *
 * @remarks
 * An analogous color scheme is composed of a color and its directly
 * adjacent counterparts on the color wheel; hues about 30° apart from
 * the origin.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string]} The base hues for a analogous color scheme
 */
export const analogous = (color) => [
  hue(0, color),
  hue(-30, color),
  hue(30, color),
];
#+END_SRC

***** splitComplementary

+ =splitComplementary: (color: string) => [string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Creates a split complementary color scheme from any valid CSS color.
 *
 * @example Creaing a split complementary scheme
 *
 * ```ts
 * splitComplementary("coral");
 * ```
 *
 * @remarks
 * A split complementary scheme is composed of a base color and a bisection
 * of colors directly next to its opposite; hues about 30° apart.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string]} The base hues for a split complementary color scheme
 */
export const splitComplementary = (color) => [
  hue(0, color),
  hue(30, hue(180, color)),
  hue(-30, hue(180, color)),
];
#+END_SRC

***** triadic

+ =triadic: (color: string) => [string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Creates a triadic color scheme from any valid CSS color.
 *
 * @example Creating a triadic color scheme
 *
 * ```ts
 * triadic("coral");
 * ```
 *
 * @remarks
 * A triadic color scheme is composed of three colors evenly spaced around
 * the color wheel; 120° apart.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string]} The base hues for a triadic color scheme
 */
export const triadic = (color) => [
  hue(0, color),
  hue(120, color),
  hue(240, color),
];
#+END_SRC

***** tetradic

+ =tetradic/dualComplementary: (color: string) => [string, string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Creates a tetradic color scheme from any valid CSS color.
 *
 * @example Creating a tetradic color scheme
 *
 * ```ts
 * tetradic("coral");
 * ```
 *
 * @remarks
 * A tetradic color scheme consists of a color, its opposite, and a
 * second complementary pair of colors. They are also called dual
 * complementary schemes.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string, string]} The base hues for a tetradic color scheme
 */
export const tetradic = (color) => [
  hue(0, color),
  hue(60, color),
  hue(180, color),
  hue(60, hue(180, color)),
];

/** An alias for `tetradic()` */
export const dualComplementary = tetradic;
#+END_SRC

***** square

+ =square: (color: string) => [string, string, string, string]=
+ =color: string=: the base color to generate from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Creates a square color scheme from any valid CSS color.
 *
 * @example Creating a square color scheme
 *
 * ```ts
 * square("coral");
 * ```
 *
 * @remarks
 * A square color scheme consists of four colors positioned equally
 * around the color wheel; 90° apart.
 *
 * @param {string} color - the base color to generate from
 * @returns {[string, string, string, string]} The base hues for a square color scheme
 */
export const square = (color) => [
  hue(0, color),
  hue(90, color),
  hue(180, color),
  hue(270, color),
];
#+END_SRC

***** custom

+ =custom: (attrs: { hues: number, arc: number, offset?: number }, color: string) => string[]=
+ =attrs: { hues: number, arc: number, offset?: number }=
  - =hues: number=: the number of total hues to generate (minus values that overlap)
  - =arc: number=: the desired arc distance between each hue on the wheel
  - =offset?: number=: an optional rotation offset for generated hues (does not change origin)
+ =color: string=: the base color to generate custom scheme

#+BEGIN_SRC js :tangle "./color.js" :comments link
function generate({ hues, arc, offset = 0 }, color) {
  const values = Array(offset ? hues - 1 : hues + 1).fill(arc);
  const half = Math.ceil(values.length / 2);
  const [leftOfOrigin, rightOfOrigin] = [
    values.slice(0, half),
    values.slice(half, values.length),
  ];
  return offset
    ? [
      ...new Set([
        hue(0, color),
        ...leftOfOrigin.map((v, i) => hue(-(v * i) - offset, color)),
        ...rightOfOrigin.map((v, i) => hue(v * i + offset, color)),
      ]),
    ] // Must preserve the origin with offset
    : [
      ...new Set([
        ...leftOfOrigin.map((v, i) => hue(-(v * i) - offset, color)),
        ...rightOfOrigin.map((v, i) => hue(v * i + offset, color)),
      ]),
    ]; // Must add an extra hue to generate from origin
}

/**
 * A function for creating advanced schemes from any valid CSS color.
 *
 * @example Creating a five tone color scheme
 *
 * ```ts
 * custom({ hues: 5, arc: 72 }, "#e33a00");
 * ```
 *
 * @example Creating a six tone color scheme
 *
 * ```ts
 * custom({ hues: 6, arc: 60 }, "hsl(320grad, 75%, 50%)");
 * ```
 * @example  Creating an accented split complementary
 *
 * ```ts
 * custom({ hues: 4, arc: 30, offset: 150 }, "royalblue");
 * ```
 *
 * @remarks
 * This function is for generating schemes beyond basic configuration.
 *
 * It allows setting any number of hues but will only generate unique colors.
 * The arc is the distance between each color on the wheel. The offset defines
 * degree of rotation for the generated hues from the origin.
 *
 * @param {{ hues: number, arc: number, offset?: number }} attrs - A configuration object defining desired hues (minus overlapping values), arc distance between each hue from the origin, and optional rotation offset
 * @param {string} color - the base color to generate scheme
 * @returns {string[]} A collection of base hues for a custom scheme
 */
export const custom = (attrs, color) => generate(attrs, color);
#+END_SRC

***** Tests

****** Color Scheme Generation Assertions

#+BEGIN_SRC js :tangle "./tests/color_scheme_test.js" :comments link
import {
  analogous,
  complementary,
  custom,
  dualComplementary,
  splitComplementary,
  square,
  tetradic,
  triadic,
} from "../color.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test(
  "SPEC complementary: generate base hues for complementary scheme",
  function () {
    assertEquals(complementary("red"), ["#ff0000", "#00a9db"]);
    assertEquals(complementary("lime"), ["#00ff00", "#ff7dff"]);
    assertEquals(complementary("blue"), ["#0000ff", "#a02000"]);
  },
);

Deno.test(
  "SPEC analogous: generate base hues for analogous scheme",
  function () {
    assertEquals(analogous("red"), ["#ff0000", "#f50084", "#ef4600"]);
    assertEquals(analogous("lime"), ["#00ff00", "#dbe100", "#00ffbe"]);
    assertEquals(analogous("blue"), ["#0000ff", "#0053e4", "#6e00ec"]);
  },
);

Deno.test(
  "SPEC splitComplementary: generate base hues for split complementary scheme",
  function () {
    assertEquals(splitComplementary("red"), ["#ff0000", "#649bec", "#00b2b8"]);
    assertEquals(splitComplementary("lime"), ["#00ff00", "#ff70b9", "#ca93ff"]);
    assertEquals(splitComplementary("blue"), ["#0000ff", "#943800", "#9c194e"]);
  },
);

Deno.test("SPEC triadic: generate base hues for triadic scheme", function () {
  assertEquals(triadic("red"), ["#ff0000", "#00ae00", "#4f6fff"]);
  assertEquals(triadic("cyan"), ["#00ffff", "#ffbfff", "#ffd05c"]);
});

Deno.test("SPEC tetradic: generate base hues for tetradic scheme", function () {
  assertEquals(tetradic("red"), ["#ff0000", "#c57500", "#00a9db", "#978be8"]);
  assertEquals(tetradic("lime"), ["#00ff00", "#00ffff", "#ff7dff", "#ff7366"]);
  assertEquals(tetradic("blue"), ["#0000ff", "#9e00b2", "#a02000", "#775100"]);
});

Deno.test("ALIAS dualComplementary of tetradic", function () {
  assertEquals(dualComplementary("cyan"), [
    "#00ffff",
    "#96e3ff",
    "#ffb3bf",
    "#f2c18b",
  ]);
});

Deno.test("SPEC square: generate base hues for square scheme", function () {
  assertEquals(square("red"), ["#ff0000", "#7b9900", "#00a9db", "#a34fff"]);
  assertEquals(square("lime"), ["#00ff00", "#00e9ff", "#ff7dff", "#ff8300"]);
  assertEquals(square("blue"), ["#0000ff", "#c00061", "#a02000", "#008048"]);
});

Deno.test("SPEC custom: simulate complementary", function () {
  assertEquals(custom({ hues: 2, arc: 180 }, "red"), ["#ff0000", "#00a9db"]);
});

Deno.test("SPEC custom: simulate analogous", function () {
  assertEquals(custom({ hues: 3, arc: 30 }, "red"), [
    "#ff0000",
    "#f50084",
    "#ef4600",
  ]);
});

Deno.test("SPEC custom: simulate triadic", function () {
  assertEquals(custom({ hues: 3, arc: 120 }, "red"), [
    "#ff0000",
    "#4f6fff",
    "#00ae00",
  ]);
});

Deno.test("SPEC custom: simulate square", function () {
  assertEquals(custom({ hues: 4, arc: 90 }, "red"), [
    "#ff0000",
    "#a34fff",
    "#00a9db",
    "#7b9900",
  ]);
});

Deno.test("SPEC custom: dyad", function () {
  assertEquals(custom({ hues: 2, arc: 60 }, "red"), ["#ff0000", "#d62fd2"]);
});

Deno.test("SPEC custom: extended analogous", function () {
  assertEquals(custom({ hues: 4, arc: 30 }, "red"), [
    "#ff0000",
    "#f50084",
    "#d62fd2",
    "#ef4600",
  ]);
});

Deno.test("SPEC custom: accented triad", function () {
  assertEquals(custom({ hues: 5, arc: 60, offset: 120 }, "red"), [
    "#ff0000",
    "#4f6fff",
    "#00a9db",
    "#00ae00",
  ]);
});

Deno.test("SPEC custom: accented split complementary", function () {
  assertEquals(custom({ hues: 4, arc: 30, offset: 150 }, "red"), [
    "#ff0000",
    "#0090ff",
    "#00a9db",
    "#00b48c",
  ]);
});

Deno.test("EDGE: rejects invalid color", function () {
  const fns = [
    complementary,
    analogous,
    splitComplementary,
    triadic,
    tetradic,
    square,
  ];

  fns.map((fn) =>
    assertThrows(
      () => {
        throw fn("invalid");
      },
      undefined,
      "not a valid CSS color",
    )
  );
  assertThrows(
    () => {
      throw custom({ hues: 2, arc: 180 }, "invalid");
    },
    undefined,
    "not a valid CSS color",
  );
});
#+END_SRC

****** Color Scheme Generation Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/color_scheme_test.js)
#+END_SRC

#+NAME: scheme-test
#+begin_src shell
running 16 tests
test SPEC complementary: generate base hues for complementary scheme ... ok (18ms)
test SPEC analogous: generate base hues for analogous scheme ... ok (6ms)
test SPEC splitComplementary: generate base hues for split complementary scheme ... ok (8ms)
test SPEC triadic: generate base hues for triadic scheme ... ok (4ms)
test SPEC tetradic: generate base hues for tetradic scheme ... ok (8ms)
test ALIAS dualComplementary of tetradic ... ok (4ms)
test SPEC square: generate base hues for square scheme ... ok (6ms)
test SPEC custom: simulate complementary ... ok (3ms)
test SPEC custom: simulate analogous ... ok (3ms)
test SPEC custom: simulate triadic ... ok (4ms)
test SPEC custom: simulate square ... ok (3ms)
test SPEC custom: dyad ... ok (2ms)
test SPEC custom: extended analogous ... ok (4ms)
test SPEC custom: accented triad ... ok (4ms)
test SPEC custom: accented split complementary ... ok (3ms)
test EDGE: rejects invalid color ... ok (4ms)

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (86ms)

#+end_src

**** Color Scales

Color scales are useful for extending a base palette with variants. These include:

+ Tints: any color mixed with pure white
+ Tones: any color mixed with pure gray
+ Shades: any color mixed with pure black

First, I'm setting up a helper for generating scales.

#+BEGIN_SRC js :tangle "./color.js" :comments link
import { mix } from "./color.js";

const generate = (color, target, contrast, count) =>
  Array.from(Array(count).fill(color)).map((base, index) =>
    mix(contrast - (contrast / count) * index, target, base)
  );
#+END_SRC

***** tints

+ =tints: (count: number, contrast: number, color: string) => string[]=
+ =count: number=: number of tints to generate
+ =contrast: number=: contrast between generated values (as a percentage)
+ =color: string=: the base color to generate tints from

#+BEGIN_SRC js :tangle "./color.js" :comments link
import { pipe } from "./utilities.js";
import { extract } from "./internals/color/format/hwb.js";
import { hwb } from "./color.js";
import { preserve } from "./color.js";

/**
 * Generates tints from any valid CSS color.
 *
 * @example Generating 4 high contrast tints
 *
 * ```ts
 * tints(4, 98, "royalblue");
 * ```
 *
 * @remarks
 * A color mixed with pure white creates a tint of that color.
 *
 * @param {number} count - number of tints to generate
 * @param {number} contrast - contrast of palette (as a percentage)
 * @param {string} color - the base color to generate from
 * @returns {string[]} A generated scale of tints
 */
export const tints = (count, contrast, color) => [
  ...new Set([
    ...generate(color, "white", contrast, count)
      .map((color) => pipe(color, hwb, extract))
      .sort((a, b) => parseFloat(a[1]) - parseFloat(b[1]))
      .map(([H, W, B, A]) =>
        !A ? `hwb(${H} ${W} ${B})` : `hwb(${H} ${W} ${B} / ${A})`
      )
      .map((target) => preserve(target, color)),
  ]),
];
#+END_SRC

***** tones

+ =tones: (count: number, contrast: number, color: string) => string[]=
+ =count: number=: number of tones to generate
+ =contrast: number=: contrast between generated values (as a percentage)
+ =color: string=: the base color to generate tones from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Generates tones from any valid CSS color.
 *
 * @example Generating 4 high contrast tones
 *
 * ```ts
 * tones(4, 98, "royalblue");
 * ```
 *
 * @remarks
 * A color mixed with pure gray creates a tone of that color.
 *
 * Be aware that tone is also another way of referring to the hue.
 *
 * @param {number} count - number of tones to generate
 * @param {number} contrast - contrast of palette (as a percentage)
 * @param {string} color - the base color to generate from
 * @returns {string[]} A generated scale of tones
 */
export const tones = (count, contrast, color) => [
  ...new Set([
    ...generate(color, "gray", contrast, count)
      .map((color) => pipe(color, hwb, extract))
      .sort(
        (a, b) =>
          parseFloat(a[1]) +
          parseFloat(a[2]) -
          (parseFloat(b[1]) + parseFloat(b[2])),
      )
      .map(([H, W, B, A]) =>
        !A ? `hwb(${H} ${W} ${B})` : `hwb(${H} ${W} ${B} / ${A})`
      )
      .map((target) => preserve(target, color)),
  ]),
];
#+END_SRC

***** shades

+ =shades: (count: number, contrast: number, color: string) => string[]=
+ =count: number=: number of shades to generate
+ =contrast: number=: contrast between generated values (as a percentage)
+ =color: string=: the base color to generate shades from

#+BEGIN_SRC js :tangle "./color.js" :comments link
/**
 * Generates shades from any valid CSS color.
 *
 * @example Generating 4 high contrast shades
 *
 * ```ts
 * shades(4, 98, "royalblue");
 * ```
 *
 * @remarks
 * A color mixed with pure black creates a shade of that color.
 *
 * @param {number} count - number of shades to generate
 * @param {number} contrast - contrast of palette (as a percentage)
 * @param {string} color - the base color to generate from
 * @returns {string[]} A generated scale of shades
 */
export const shades = (count, contrast, color) => [
  ...new Set([
    ...generate(color, "black", contrast, count)
      .map((color) => pipe(color, hwb, extract))
      .sort((a, b) => parseFloat(a[2]) - parseFloat(b[2]))
      .map(([H, W, B, A]) =>
        !A ? `hwb(${H} ${W} ${B})` : `hwb(${H} ${W} ${B} / ${A})`
      )
      .map((target) => preserve(target, color)),
  ]),
];
#+END_SRC

***** Tests

****** Color Scale Assertions

#+BEGIN_SRC js :tangle "./tests/color_scale_test.js" :comments link
import { shades, tints, tones } from "../color.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC tints: can generate tints", function () {
  assertEquals(tints(2, 100, "red"), ["#ffa191", "#ffffff"]);
  assertEquals(tints(3, 100, "lime"), ["#8cff84", "#caffc5", "#ffffff"]);
  assertEquals(tints(4, 100, "blue"), [
    "#306fff",
    "#73a4ff",
    "#b8d2ff",
    "#ffffff",
  ]);
});

Deno.test("SPEC tones: can generate tones", function () {
  assertEquals(tones(2, 100, "red"), ["#c66356", "#808080"]);
  assertEquals(tones(3, 100, "lime"), ["#5ed558", "#77ab72", "#808080"]);
  assertEquals(tones(4, 100, "blue"), [
    "#144be2",
    "#3b64c4",
    "#5e75a4",
    "#808080",
  ]);
});

Deno.test("SPEC shades: can generate shades", function () {
  assertEquals(shades(2, 100, "red"), ["#630000", "#000000"]);
  assertEquals(shades(3, 100, "lime"), ["#009400", "#003600", "#000000"]);
  assertEquals(shades(4, 100, "blue"), [
    "#0000ae",
    "#000063",
    "#000022",
    "#000000",
  ]);
});
#+END_SRC

****** Color Scale Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/color_scale_test.js)
#+END_SRC

#+NAME: color-scale-test
#+begin_src shell
running 3 tests
test SPEC tints: can generate tints ... ok (26ms)
test SPEC tones: can generate tones ... ok (10ms)
test SPEC shades: can generate shades ... ok (10ms)

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (47ms)

#+end_src

**** Color Accessibility

Accessibility is a first-class concern for every modern web project. Quarks System Core
addresses this vital aspect of digital design with the following tools.

***** clrs

+ =clrs: (color: string) => string=
+ =color: string=: a valid name for a swatch in the Colors project

#+BEGIN_SRC js :tangle "./color.js" :comments link
import { ErrorTemplate } from "./internals/error.js";
import { A11yColors } from "./data/color/a11y.js";

const ColorUndefinedError = (output) =>
  ErrorTemplate({
    message: "color not defined in Colors",
    reason: `
This error triggers when the color does not match a defined color in
the Colors project.
`,
    suggestion: `
Pass in one of the below valid colors:

navy blue aqua teal
olive green lime
yellow orange red
maroon fuchsia purple
black
gray/grey silver
white
`,
    output,
  });

/**
 * A function for using better web defaults from the Colors project.
 *
 * @example Using a more accessible teal
 *
 * ```ts
 * clrs("teal");
 * ```
 *
 * @param { "navy" | "aqua" | "blue" | "teal" | "olive" | "green" | "lime" | "yellow" | "orange" | "red" | "maroon" | "fuchsia" | "purple" | "black" | "gray" | "grey" | "silver" | "white" } color - a valid color name in the Colors project
 * @returns {string} The targeted color from the Colors project
 */
export function clrs(color) {
  if (A11yColors.hasOwnProperty(color)) {
    return A11yColors[color];
  }

  return ColorUndefinedError(color);
}
#+END_SRC

A great base for accessible palettes is the Colors project. It provides a [[https://clrs.cc][curated collection of
better default colors]] optimized for high contrast interfaces.

***** contrast

+ =contrast: (opts: { rating: "AA" | "AAA", enhanced?: boolean }, color: string, targets: string[]) => string[]=
+ =opts: { rating: "AA" | "AAA", enhanced?: boolean }=: palette contrast filtering options
  - =rating: "AA" | "AAA"=: the desired minimum WCAG color contrast accessibility rating to process a palette
  - =enhanced?: boolean=: a flag to toggle the enhanced WCAG recommendations
+ =background: string=: the background color to check against
+ =palette: string[]=: the palette to filter

QSC allows a hefty degree of flexibility in defining and generating your palettes. It also provides
a necessary guardrail to keep color choices from running afoul of usability.

#+BEGIN_SRC js :tangle "./color.js" :comments link
import {
  calcFractionFromChannel,
  significant,
} from "./internals/color/convert/setup.js";
import { extract } from "./internals/color/format/rgb.js";
import { pipe } from "./utilities.js";
import { rgb } from "./color.js";

const precision = significant.bind(null, 3);

function calcRelativeLuminance(color) {
  const [R, G, B] = pipe(color, rgb, extract)
    .map((V) => pipe(V, parseFloat, calcFractionFromChannel))
    .map((V) => (V <= 0.03928 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4));

  return R * 0.2126 + 0.7152 * G + B * 0.0722;
}

function calcRatio(a, b) {
  const [L1, L2] = [a, b]
    .sort((a, b) => calcRelativeLuminance(b) - calcRelativeLuminance(a))
    .map((V) => calcRelativeLuminance(V));

  return precision((L1 + 0.05) / (L2 + 0.05));
}

/**
 * A function that filters a palette by the colors usable with a given background.
 *
 * Colors match only if they meet the WCAG color accessibility rating defined in opts.
 *
 * @example Filtering a palette to only contain the colors that can safely be
 * used with coral while satisfying the AA contrast rating.
 *
 * ```ts
 * contrast({ rating: "AA" }, "coral", palette);
 * ```
 *
 * @example Filtering a palette to only contain the colors that can safely be
 * used with dodgerblue while satisfying the AAA rating.
 *
 * ```ts
 * contrast({ rating: "AAA" }, "dodgerblue", palette);
 * ```
 *
 * @example Using the enhanced recommendations flag
 *
 * ```ts
 * contrast({ rating: "AA", enhanced: true}, "aliceblue", palette);
 * ```
 *
 * @param {{ rating: "AA" | "AAA", enhanced?: boolean }} opts - options for filtering the palette
 * @param {string} background - the background color to check against
 * @param {string[]} palette - a palette of colors to filter
 * @returns {string[]} A new palette of colors usable with the background while satisfying
 * accessibility standards
 */
export function contrast(opts, background, palette) {
  const { rating, enhanced = false } = opts;

  return palette.filter((foreground) => {
    const ratio = calcRatio(background, foreground);
    const max = ratio <= 21;

    if (rating === "AA") return (enhanced ? ratio >= 4.5 : ratio >= 3.1) && max;
    if (rating === "AAA") return (enhanced ? ratio >= 7 : ratio >= 4.5) && max;
  });
}
#+END_SRC

Now you can filter colors in your palette against another color. The main use of this function is to
ensure the usability of your palette against the actual context of how it'll be used.

***** Tests

****** Color Accessibility Assertions

#+BEGIN_SRC js :tangle "./tests/color_a11y_test.js" :comments link
import { clrs, contrast } from "../color.js";
import { shades, tints } from "../color.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const Colors = [
  ["navy", "#001f3f"],
  ["blue", "#0074d9"],
  ["aqua", "#7fdbff"],
  ["teal", "#39cccc"],
  ["olive", "#3d9970"],
  ["green", "#2ecc40"],
  ["lime", "#01ff70"],
  ["yellow", "#ffdc00"],
  ["orange", "#ff851b"],
  ["red", "#ff4136"],
  ["maroon", "#85144b"],
  ["fuchsia", "#f012be"],
  ["purple", "#b10dc9"],
  ["black", "#111111"],
  ["gray", "#aaaaaa"],
  ["grey", "#aaaaaa"],
  ["silver", "#dddddd"],
  ["white", "#ffffff"],
];

Colors.forEach(([name, value]) =>
  Deno.test(`SPEC clrs: "${name}" = ${value}`, function () {
    assertEquals(clrs(name), value);
  })
);

Deno.test("EDGE clrs: rejects undefined color", function () {
  assertThrows(
    () => {
      throw clrs("invalid");
    },
    undefined,
    "color not defined in Colors",
  );
});

Deno.test(
  "SPEC contrast: returns the colors from a palette that can be used with a background and satisfy AA usability",
  function () {
    const color = clrs("red");
    const [bg] = tints(5, 99, color).reverse();
    const dark = shades(5, 99, color);

    assertEquals(contrast({ rating: "AA" }, bg, dark), [
      "#be2e26",
      "#811b16",
      "#490c08",
      "#180201",
      "#000000",
    ]);
  },
);

Deno.test(
  "SPEC contrast: returns the colors that satisfy AAA usability",
  function () {
    const color = clrs("red");
    const [bg] = tints(5, 99, color).reverse();
    const dark = shades(5, 99, color);

    assertEquals(contrast({ rating: "AAA" }, bg, dark), [
      "#be2e26",
      "#811b16",
      "#490c08",
      "#180201",
      "#000000",
    ]);
  },
);

Deno.test(
  "SPEC contrast: respects the enhanced rating boolean property",
  function () {
    const color = clrs("red");
    const [bg] = tints(5, 99, color).reverse();
    const dark = shades(5, 99, color);

    assertEquals(contrast({ rating: "AA", enhanced: true }, bg, dark), [
      "#be2e26",
      "#811b16",
      "#490c08",
      "#180201",
      "#000000",
    ]);

    assertEquals(contrast({ rating: "AAA", enhanced: true }, bg, dark), [
      "#811b16",
      "#490c08",
      "#180201",
      "#000000",
    ]);
  },
);
#+END_SRC

****** Color Accessibility Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/color_a11y_test.js)
#+END_SRC

#+NAME: a11y-test
#+begin_src shell
running 22 tests
test SPEC clrs: "navy" = #001f3f ... ok (2ms)
test SPEC clrs: "blue" = #0074d9 ... ok (2ms)
test SPEC clrs: "aqua" = #7fdbff ... ok (2ms)
test SPEC clrs: "teal" = #39cccc ... ok (1ms)
test SPEC clrs: "olive" = #3d9970 ... ok (2ms)
test SPEC clrs: "green" = #2ecc40 ... ok (2ms)
test SPEC clrs: "lime" = #01ff70 ... ok (2ms)
test SPEC clrs: "yellow" = #ffdc00 ... ok (1ms)
test SPEC clrs: "orange" = #ff851b ... ok (1ms)
test SPEC clrs: "red" = #ff4136 ... ok (2ms)
test SPEC clrs: "maroon" = #85144b ... ok (2ms)
test SPEC clrs: "fuchsia" = #f012be ... ok (1ms)
test SPEC clrs: "purple" = #b10dc9 ... ok (1ms)
test SPEC clrs: "black" = #111111 ... ok (2ms)
test SPEC clrs: "gray" = #aaaaaa ... ok (2ms)
test SPEC clrs: "grey" = #aaaaaa ... ok (1ms)
test SPEC clrs: "silver" = #dddddd ... ok (2ms)
test SPEC clrs: "white" = #ffffff ... ok (2ms)
test EDGE clrs: rejects undefined color ... ok (3ms)
test SPEC contrast: returns the colors from a palette that can be used with a background and satisfy AA usability ... ok (29ms)
test SPEC contrast: returns the colors that satisfy AAA usability ... ok (13ms)
test SPEC contrast: respects the enhanced rating boolean property ... ok (15ms)

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (93ms)

#+end_src

*** Typography (=typography.js=)

Quarks System Core isn't focused much on typography at this point, but it does provide a single
function =systemfonts()= to aid [[https://systemfontstack.com][prototyping with system font stacks]]. I'll expand this module as
needed in step with the project's growth.

**** systemfonts

+ =systemfonts: (...families: ("san-serif" | "serif" | "monospace")[]) => string[]=
+ =...families: ("sans-serif" | "serif" | "monospace")[]=: keywords matching the available system font
  stacks

#+BEGIN_SRC js :tangle "./typography.js" :comments link
import { SystemFontStacks } from "./data/typography/system.js";
import { ErrorTemplate } from "./internals/error.js";

const SystemFamilyError = (output) =>
  ErrorTemplate({
    message: "key is not a system font stack family",
    reason: `
This error is triggered when one or more of the keys passed into
systemfonts() is invalid.
`,
    suggestion: `
Pass in valid system font stack keywords as strings.

Examples:

systemfonts("sans-serif", "monospace");
systemfonts("sans-serif", "serif");
systemfonts("sans-serif");
systemfonts("sans-serif", "serif", "monospace");
`,
    output,
  });

/**
 * Outputs a collection of system font stacks.
 *
 * @example Outputting a single family
 *
 * ```ts
 * systemfonts("sans-serif");
 * ```
 *
 * @example Outputting multiple families
 *
 * ```ts
 * systemfonts("sans-serif", "serif");
 * ```
 *
 * @example Outputting all families
 *
 * ```ts
 * systemfonts("sans-serif", "serif", "monospace");
 * ```
 *
 * @param {("sans-serif" | "serif" | "monospace")[]} families - keyword(s) matching available system font stacks
 * @returns {string[]} An array of system font stacks
 */
export function systemfonts(...families) {
  if (
    families.every((family) =>
      family === "sans-serif" || family === "serif" || family === "monospace"
    )
  ) {
    return families.map((family) => SystemFontStacks[family]);
  }

  return SystemFamilyError(families);
}
#+END_SRC

**** Tests

***** Typography Assertions

#+BEGIN_SRC js :tangle "./tests/typography_test.js" :comments link
import { systemfonts } from "../typography.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC systemfonts: can output a collection of system font stacks for prototyping", function () {
  assertEquals(systemfonts("sans-serif"), [
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  ]);
  assertEquals(systemfonts("sans-serif", "serif"), [
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  ]);
  assertEquals(systemfonts("sans-serif", "serif", "monospace"), [
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
  ]);
});

Deno.test("EGDE systemfonts: rejects invalid family keys", function () {
  assertThrows(
    () => {
      throw systemfonts("invalid");
    },
    undefined,
    "not a system font stack family",
  );
});
#+END_SRC

***** Typography Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/typography_test.js)
#+END_SRC

#+NAME: typography-test
#+begin_src shell
running 2 tests
test SPEC systemfonts: can output a collection of system font stacks for prototyping ... ok (6ms)
test EGDE systemfonts: rejects invalid family keys ... ok (3ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (10ms)

#+end_src

*** Modular Scale (=modular_scale.js=)

Now that I'm all set for color, I can begin thinking about sizing and proportion. Modular scales are
the best way to manage consistency between values. They can be used for:

+ typographical hierarchy
+ spacing
+ sizing
+ border widths

The Quarks System Core scale module is more or less unchanged from QuarkSuite 1 with the addition of
error handling to catch bad input.

It begins with creating a scale as a collection of raw values that the remaining utilities consume
and modify before finally attaching units for output.

**** create

+ =create: (values: number, ratio: number, base: number) => number[]=
+ =values: number=: the number of values to include (output range)
+ =ratio: number=: the ratio maintained between each value in the scale
+ =base: number=: initial scale value

The formula to calculate each value in the scale is straightforward. The array is first filled with
the base value, then multiplied with ratio to the nth of the current index.

Example: when =base = 1=, =ratio = 2=, =index = 2=, then ~base * ratio ** index === 1 * 2 ** 2 === 1 * 4 === 4~

#+BEGIN_SRC js :tangle "./modular_scale.js" :comments link
/**
 * Create a new modular scale.
 *
 * @example Create a 6 value scale from base of 1 with ratio of 1.5
 *
 * ```ts
 * create(6, 1.5, 1);
 * ```
 *
 * @param {number} values - the number of values to include (output range)
 * @param {number} ratio - the ratio maintained between each value
 * @param {number} base - the initial scale value
 * @returns {number[]} An array of raw modular scale values
 */
export const create = (values, ratio, base) =>
  Array(values).fill(base).map((base, index) => base * ratio ** index);
#+END_SRC

**** update

+ =update: (calc: (n: number) => number, scale: number[]) => number[]=
+ =calc: (: number) => number=: the desired calculation to modify each scale value
+ =scale: number[]=: the scale to update

This utility updates the values in created scales with a user-defined recalculation and outputs a
new scale from the results.

#+BEGIN_SRC js :tangle "./modular_scale.js" :comments link
import { ErrorTemplate } from "./internals/error.js";

const ScaleError = (output) =>
  ErrorTemplate({
    message: "not a modular scale",
    reason: `
This error triggers when the value passed in as scale is not actually
a modular scale.
`,
    suggestion: `
Ensure that you only use scale modification functions on modular scales.
Create one with create()

Example:

create(8, 2, 1);

  `,
    output,
  });

function unlessMS(body, data) {
  if (
    Array.isArray(data) && data.length &&
    data.every((n) => typeof n === "number")
  ) {
    return body;
  }

  return ScaleError(data);
}

/**
 * Update a scale with a calculation mapping to each value.
 *
 * @example Add ten to each scale value
 *
 * ```ts
 * update(n => n + 10, create(4, 2, 1));
 * ```
 *
 * @param {(n: number) => number} calc - the desired calculation to modify each scale value
 * @param {number[]} scale - the scale to update
 * @returns {number[]} A new scale with updated values
 */
export const update = (calc, scale) =>
  unlessMS(scale.map((n) => calc(n)), scale);
#+END_SRC

For each function beyond this point, I'll need to ensure that data passed in is a raw modular
scale. I wrote a template function to tell the interpreter that nothing should be done unless the
data is a modular scale and throw an error reminding the user to =create()= one if they haven't.

**** merge

+ =merge: (...scales: number[][]) => number[]=
+ =...scales: number[][]=: any number of scales to merge

#+BEGIN_SRC js :tangle "./modular_scale.js" :comments link
/**
 * Merge two or more scales into a scale of their unique values.
 *
 * @example Merge scale a with scale b
 *
 * ```ts
 * merge(create(5, 1.5, 1), create(8, 1.25, 1));
 * ```
 *
 * @param {number[][]} scales - the scales to merge
 * @returns {number[]} A new scale of unique values
 */
export const merge = (...scales) =>
  scales.every((scale) => unlessMS(scale, scale)) && [
    ...new Set(scales.reduce((acc, scale) => [...acc, ...scale], [])),
  ].sort((a, b) => a - b);
#+END_SRC

Using a Set guarantees that the merge will only return the unique values in each scale.

**** chunk

+ =chunk: (size: number, scale: number[]) => number[][]=
+ =size: number=: number of values to capture in each chunk
+ =scale: number[]=: the scale you want to chunk

#+BEGIN_SRC js :tangle "./modular_scale.js" :comments link
/**
 * Splits a scale into smaller scales of a given size.
 *
 * @example Split a 30 value scale into 6 chunks of 5 values
 *
 * ```ts
 * chunk(6, create(30, 1.414, 1));
 * ```
 *
 * @param {number} size - the number of values in each chunk
 * @param {number[]} scale - the scale to chunk
 * @returns {number[][]} A new scale of chunked scale values
 */
export const chunk = (size, scale) =>
  unlessMS(
    Array.from(scale).reduceRight(
      (acc, _v, _i, arr) => [...acc, arr.splice(0, size)],
      [],
    ),
    scale,
  );
#+END_SRC

**** units

+ =units: (unit: string, scale: number[]) => string[]=
+ =unit: string=: any valid CSS relative or absolute unit
+ =scale: number[]=: raw value scale for processing

#+BEGIN_SRC js :tangle "./modular_scale.js" :comments link
import { significant } from "./internals/color/convert/setup.js";

const precision = significant.bind(null, 4);

/**
 * Attach units to a raw scale to create a CSS-ready modular scale.
 *
 * @example Output a scale as rems
 *
 * ```ts
 * units("rem", create(7, 1.25, 1));
 * ```
 *
 * @param { "cm" | "mm" | "Q" | "in" | "pc" | "pt" | "px" | "em" | "ex" | "ch" | "rem" | "lh" | "vw" | "vh" | "vmin" | "vmax" } unit - any valid relative or absolute CSS unit
 * @param {number[]} scale - the raw scale to generate from
 * @returns {string[]} A finished modular scale now ready to use
 */
export const units = (unit, scale) =>
  unlessMS(scale.map((n) => `${precision(n)}${unit}`), scale);
#+END_SRC

**** Tests

***** Modular Scale Assertions

Alright. Time to test the scale creation flow and error handling.

#+BEGIN_SRC js :tangle "./tests/modular_scale_test.js" :comments link
import { chunk, create, merge, units, update } from "../modular_scale.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

Deno.test("SPEC create: can generate raw modular scales", function () {
  assertEquals(create(6, 1.25, 1), [
    1,
    1.25,
    1.5625,
    1.953125,
    2.44140625,
    3.0517578125,
  ]);
  assertEquals(create(8, 1.5, 1), [
    1,
    1.5,
    2.25,
    3.375,
    5.0625,
    7.59375,
    11.390625,
    17.0859375,
  ]);
  assertEquals(create(10, 2, 1), [
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
    512,
  ]);
});

Deno.test("SPEC update: can update values with an in-place recalculation", function () {
  const scale = create(8, 2, 1);

  assertEquals(update((n) => n + 16, scale), [
    17,
    18,
    20,
    24,
    32,
    48,
    80,
    144,
  ]);
  assertEquals(update((n) => n / 4, scale), [
    0.25,
    0.5,
    1,
    2,
    4,
    8,
    16,
    32,
  ]);
  assertEquals(update((n) => n * 2, scale), [
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
  ]);
});

Deno.test("SPEC merge: can combine values from multiple scales into one scale", function () {
  const a = create(8, 1.5, 1);
  const b = create(6, 1.25, 1);
  const c = create(4, 1.75, 1);

  assertEquals(merge(a, b), [
    1,
    1.25,
    1.5,
    1.5625,
    1.953125,
    2.25,
    2.44140625,
    3.0517578125,
    3.375,
    5.0625,
    7.59375,
    11.390625,
    17.0859375,
  ]);
  assertEquals(merge(a, c), [
    1,
    1.5,
    1.75,
    2.25,
    3.0625,
    3.375,
    5.0625,
    5.359375,
    7.59375,
    11.390625,
    17.0859375,
  ]);
  assertEquals(merge(b, c), [
    1,
    1.25,
    1.5625,
    1.75,
    1.953125,
    2.44140625,
    3.0517578125,
    3.0625,
    5.359375,
  ]);
});

Deno.test("SPEC chunk: can split a larger set of scale values into multiple scales of a given size", function () {
  const [first, second, third, ...rest] = chunk(5, create(24, 1.5, 1));

  assertEquals(first, [1, 1.5, 2.25, 3.375, 5.0625]);
  assertEquals(second, [
    7.59375,
    11.390625,
    17.0859375,
    25.62890625,
    38.443359375,
  ]);
  assertEquals(third, [
    57.6650390625,
    86.49755859375,
    129.746337890625,
    194.6195068359375,
    291.92926025390625,
  ]);
  assertEquals(rest, [
    [
      437.8938903808594,
      656.8408355712891,
      985.2612533569336,
      1477.8918800354004,
      2216.8378200531006,
    ],
    [
      3325.256730079651,
      4987.885095119476,
      7481.8276426792145,
      11222.741464018822,
    ],
  ]);
});

Deno.test("SPEC units: can attach units and output CSS-ready modular scales", function () {
  assertEquals(units("rem", create(6, 1.5, 1)), [
    "1rem",
    "1.5rem",
    "2.25rem",
    "3.375rem",
    "5.063rem",
    "7.594rem",
  ]);
  assertEquals(units("ex", create(4, 2, 1)), [
    "1ex",
    "2ex",
    "4ex",
    "8ex",
  ]);
  assertEquals(units("pt", create(5, 1.25, 12)), [
    "12pt",
    "15pt",
    "18.75pt",
    "23.44pt",
    "29.3pt",
  ]);
});

Deno.test("EDGE: scale modifiers (update, merge, chunk, units) reject empty scales", function () {
  assertThrows(
    () => {
      throw update((n) => n, []);
    },
    undefined,
    "not a modular scale",
  );
  assertThrows(
    () => {
      throw merge([], []);
    },
    undefined,
    "not a modular scale",
  );
  assertThrows(
    () => {
      throw chunk(3, []);
    },
    undefined,
    "not a modular scale",
  );
  assertThrows(
    () => {
      throw units("rem", []);
    },
    undefined,
    "not a modular scale",
  );
});
#+END_SRC

***** Modular Scale Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/modular_scale_test.js)
#+END_SRC

#+NAME: scale-test
#+begin_src shell
running 6 tests
test SPEC create: can generate raw modular scales ... ok (6ms)
test SPEC update: can update values with an in-place recalculation ... ok (2ms)
test SPEC merge: can combine values from multiple scales into one scale ... ok (1ms)
test SPEC chunk: can split a larger set of scale values into multiple scales of a given size ... ok (2ms)
test SPEC units: can attach units and output CSS-ready modular scales ... ok (3ms)
test EDGE: scale modifiers (update, merge, chunk, units) reject empty scales ... ok (3ms)

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (18ms)

#+end_src

*** Design Token Output Formats (=design_tokens.js=)

All the modules necessary to create a design system foundation are in place, but it wouldn't be very
useful or portable in its current form. Data has to be packaged as a Quarks System Dictionary
object and then transformed into design tokens with the below build functions.

#+BEGIN_QUOTE
Quarks System Core is the barest metal component and has no need for filesystem read/write
access. Therefore, the build functions limit themselves to formatting data to a /file-ready/ state.

If you want to /write/ the tokens to your filesystem, use the native filesystem API provided by your
JavaScript environment or a filesystem library of your choice.
#+END_QUOTE

**** CSS (=design_tokens.js=)

QuarkSuite is made from web technologies for the web platform, so CSS format support is
essential. Whether you like it vanilla or swear by preprocessors, it's covered.

The output has mostly cosmetic differences between the formats, so I'll set up a general
design token construction helper.

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
const formatter = ({
  padding = "",
  prefix = "--",
  operator = ": ",
  suffix = ";",
  eol = "\n",
}) =>
  (collector, key, value) =>
    collector.concat(padding, prefix, key, operator, value, suffix, eol);

const variable = (collected, current, delimiter) =>
  current === "base"
    ? collected
    : collected
    ? [collected, current].join(delimiter)
    : current;

function construct(opts, dict) {
  const aggregator = (head, node) =>
    Object.entries(node).reduce((product, [key, value]) => {
      const format = formatter(opts);
      const delimiter = "-";

      return typeof value === "object"
        ? product.concat(aggregator(variable(head, key, delimiter), value))
        : format(product, variable(head, key, delimiter), value);
    }, "");

  return "".concat("\n", aggregator("", dict));
}
#+END_SRC

The =formatter= queues up any syntax options that need to change between formats before assembling
the token itself. The =variable= is constructed by recursively walking the Quarks System Dictionary
object passed in, only returning when the value is found at the end of the chain.

***** css

+ =css: (dict: object) => string=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Transforms Quark System Dictionaries into CSS custom properties.
 *
 * @example
 *
 * ```ts
 * css(dict);
 * ```
 *
 * @remarks
 * This function does not actually build the files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as CSS custom properties (file-ready)
 */
export const css = (dict) => `\n:root {${construct({ padding: "  " }, dict)}}`;
#+END_SRC

***** sass

+ =sass: (dict: object) => string=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Transforms Quark System Dictionaries into Sass variables.
 *
 * @example
 *
 * ```ts
 * sass(dict);
 * ```
 *
 * @remarks
 * This function does not actually write files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as Sass variables (file-ready)
 */
export const sass = (dict) => construct({ prefix: "$" }, dict);
#+END_SRC

***** less

+ =less: (dict: object) => string=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Transforms Quark System Dictionaries into Less variables.
 *
 * @example
 *
 * ```ts
 * less(dict);
 * ```
 *
 * @remarks
 * This function does not actually write files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as Less variables (file-ready)
 */
export const less = (dict) => construct({ prefix: "@" }, dict);
#+END_SRC

***** styl

+ =styl: (dict: object) => string=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Transforms Quark System Dictionaries into Stylus variables.
 *
 * @example
 *
 * ```ts
 * styl(dict);
 * ```
 *
 * @remarks
 * This function does not actually write files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as Stylus variables (file-ready)
 */
export const styl = (dict) =>
  construct({ prefix: "", operator: " = ", suffix: "" }, dict);
#+END_SRC

***** Tests

****** CSS Format Assertions

#+BEGIN_SRC js :tangle "./tests/output_css_test.js" :comments link
import { css, less, sass, styl } from "../design_tokens.js";
import { clrs } from "../color.js";
import { triadic } from "../color.js";
import { shades, tints } from "../color.js";

import { assertStrictEquals } from "https://deno.land/std@0.86.0/testing/asserts.ts";

const swatch = clrs("red");
const [main, accent, highlight] = triadic(swatch);
const light = tints.bind(null, 3, 99);
const dark = shades.bind(null, 2, 99);

const dict = {
  color: {
    main: {
      base: main,
      light: light(main),
      dark: dark(main),
    },
    accent: {
      base: accent,
      dark: dark(accent),
    },
    highlight,
  },
};

Deno.test(
  "SPEC css: can process dictionary into CSS custom properties",
  function () {
    assertStrictEquals(
      css(dict),
      `
:root {
  --color-main: #ff4036;
  --color-main-light-0: #ff9d99;
  --color-main-light-1: #ffd3d2;
  --color-main-light-2: #fffefe;
  --color-main-dark-0: #b42d26;
  --color-main-dark-1: #1a0605;
  --color-accent: #4036ff;
  --color-accent-dark-0: #2d26b4;
  --color-accent-dark-1: #06051a;
  --color-highlight: #36ff40;
}`,
    );
  },
);

Deno.test(
  "SPEC sass: can process dictionary into Sass variables",
  function () {
    assertStrictEquals(
      sass(dict),
      `
$color-main: #ff4036;
$color-main-light-0: #ff9d99;
$color-main-light-1: #ffd3d2;
$color-main-light-2: #fffefe;
$color-main-dark-0: #b42d26;
$color-main-dark-1: #1a0605;
$color-accent: #4036ff;
$color-accent-dark-0: #2d26b4;
$color-accent-dark-1: #06051a;
$color-highlight: #36ff40;
`,
    );
  },
);

Deno.test(
  "SPEC less: can process dictionary into Less variables",
  function () {
    assertStrictEquals(
      less(dict),
      `
@color-main: #ff4036;
@color-main-light-0: #ff9d99;
@color-main-light-1: #ffd3d2;
@color-main-light-2: #fffefe;
@color-main-dark-0: #b42d26;
@color-main-dark-1: #1a0605;
@color-accent: #4036ff;
@color-accent-dark-0: #2d26b4;
@color-accent-dark-1: #06051a;
@color-highlight: #36ff40;
`,
    );
  },
);

Deno.test(
  "SPEC styl: can process dictionary into Stylus variables",
  function () {
    assertStrictEquals(
      styl(dict),
      `
color-main = #ff4036
color-main-light-0 = #ff9d99
color-main-light-1 = #ffd3d2
color-main-light-2 = #fffefe
color-main-dark-0 = #b42d26
color-main-dark-1 = #1a0605
color-accent = #4036ff
color-accent-dark-0 = #2d26b4
color-accent-dark-1 = #06051a
color-highlight = #36ff40
`,
    );
  },
);
#+END_SRC

****** CSS Format Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/output_css_test.js)
#+END_SRC

#+NAME: css-test
#+begin_src shell
running 4 tests
test SPEC css: can process dictionary into CSS custom properties ... ok (5ms)
test SPEC sass: can process dictionary into Sass variables ... ok (2ms)
test SPEC less: can process dictionary into Less variables ... ok (2ms)
test SPEC styl: can process dictionary into Stylus variables ... ok (2ms)

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (12ms)

#+end_src

**** Data Export (=design_tokens.js=)

Quarks System Core also supports exporting tokens in general data formats (raw JSON and YAML
supported as of this writing). This allows complete detachment from the core and the portability to
use system data outside of JavaScript environments.

***** raw

+ =raw: (dict: object) => object=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Transforms Quark System Dictionaries into raw JSON data.
 *
 * @example
 *
 * ```ts
 * raw(dict);
 * ```
 *
 * @remarks
 * This function does not actually write files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as raw JSON data (file-ready)
 */
export const raw = (dict) => JSON.stringify(dict, null, 2);
#+END_SRC

***** yaml

+ =yaml: (dict: object) => string=
+ =dict: object=: the dictionary to process

YAML is a whitespace-dependent data format, so I kept that in mind when constructing the helper
bits. The way it works: specific data builders execute when the function encounters the right kind
of data.

And then the main function recursively walks through the dictionary to completion.

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
const whitespace = 2;

const value = (level, str, key, value) =>
  str.concat("".padStart(level), key, ": ", value, "\n");

const scale = (level, str, key, value) =>
  str.concat(
    "".padStart(level),
    key,
    ":\n",
    value.reduce(
      (s, v) => s.concat("".padStart(level + whitespace), "- ", v, "\n"),
      "",
    ),
  );

const subcategory = (level, data) =>
  Object.entries(data).reduce((str, [key, v]) => {
    if (Array.isArray(v)) return scale(level, str, key, v);
    return value(level, str, key, v);
  }, "");

const assemble = (level, tree) =>
  Object.entries(tree).reduce((str, [key, data]) => {
    if (typeof data === "string") return value(level, str, key, data);
    if (Array.isArray(data)) return scale(level, str, key, data);
    if (key === "base") return subcategory(level, data);
    return str.concat(
      "".padStart(level),
      key,
      ":\n",
      assemble(level + whitespace, data),
    );
  }, "");

/**
 * Transforms Quark System Dictionaries into YAML data.
 *
 * @example
 *
 * ```ts
 * yaml(dict);
 * ```
 *
 * @remarks
 * This function does not actually write files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as yaml data (file-ready)
 */
export const yaml = (dict) =>
  Object.entries(dict)
    .reduce((str, [key, data]) => {
      if (typeof data === "string") return value(0, str, key, data);
      if (Array.isArray(data)) return scale(0, str, key, data);
      if (key === "base") return subcategory(0, data);
      return str.concat("\n", key, ":\n", assemble(whitespace, data));
    }, "")
    .trimEnd();
#+END_SRC

***** Tests

****** Data Export Assertions

#+BEGIN_SRC js :tangle "./tests/export_data_test.js" :comments link
import { raw, yaml } from "../design_tokens.js";
import { clrs } from "../color.js";
import { triadic } from "../color.js";
import { shades, tints } from "../color.js";

import { assertStrictEquals } from "https://deno.land/std@0.86.0/testing/asserts.ts";

const swatch = clrs("red");
const [main, accent, highlight] = triadic(swatch);
const light = tints.bind(null, 3, 99);
const dark = shades.bind(null, 2, 99);

const dict = {
  color: {
    main: {
      base: main,
      light: light(main),
      dark: dark(main),
    },
    accent: {
      base: accent,
      dark: dark(accent),
    },
    highlight,
  },
};

Deno.test(
  "SPEC raw: exports dictionary data as raw JSON",
  function () {
    assertStrictEquals(
      raw(dict),
      `{
  "color": {
    "main": {
      "base": "#ff4036",
      "light": [
        "#ff9d99",
        "#ffd3d2",
        "#fffefe"
      ],
      "dark": [
        "#b42d26",
        "#1a0605"
      ]
    },
    "accent": {
      "base": "#4036ff",
      "dark": [
        "#2d26b4",
        "#06051a"
      ]
    },
    "highlight": "#36ff40"
  }
}`,
    );
  },
);

Deno.test(
  "SPEC yaml: exports dictionary data as YAML",
  function () {
    assertStrictEquals(
      yaml(dict),
      `
color:
  main:
    base: #ff4036
    light:
      - #ff9d99
      - #ffd3d2
      - #fffefe
    dark:
      - #b42d26
      - #1a0605
  accent:
    base: #4036ff
    dark:
      - #2d26b4
      - #06051a
  highlight: #36ff40`,
    );
  },
);
#+END_SRC

****** Data Export Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/export_data_test.js)
#+END_SRC

#+NAME: export-test
#+begin_src shell
running 2 tests
test SPEC raw: transforms a dictionary into its raw JSON data ... ok (3ms)
test SPEC yaml: transforms a dictionary to YAML formatted data ... ok (2ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (6ms)

#+end_src

**** Data Transforms (=design_tokens.js=)

The final set of token formats are reserved for integrating with other tools that use and transform
design data. Currently, it supports tools that I use regularly in my own projects (TailwindCSS and
Style Dictionary), but more will be added as the project grows.

***** tailwind

+ =tailwind: (dict: object) => string=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Reformats Quark System Dictionaries as TailwindCSS theme data.
 *
 * @example
 *
 * ```ts
 * tailwind(dict);
 * ```
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as TailwindCSS theme data (file-ready)
 */
export const tailwind = (dict) =>
  Object.entries(dict).reduce((acc, [key, data]) => {
    if (key === "base") return { ...acc, DEFAULT: data };
    if (Array.isArray(data)) {
      return {
        ...acc,
        ...{
          ...data.reduce((a, v, i) => {
            return { ...a, [[key, i + 2].join("")]: v };
          }, {}),
        },
      };
    }
    if (typeof data === "object") return { ...acc, [key]: tailwind(data) };
    return { ...acc, [key]: data };
  }, {});
#+END_SRC

***** styledict

+ =styledict: (dict: object) => string=
+ =dict: object=: the dictionary to process

#+BEGIN_SRC js :tangle "./design_tokens.js" :comments link
/**
 * Reformats Quark System Dictionaries as Style Dictionary properties.
 *
 * @example
 *
 * ```ts
 * styledict(dict);
 * ```
 *
 * @remarks
 * This function does not actually write files as the core has no need
 * for read/write access.
 *
 * You'll want to use the native API or filesystem library of your choice in
 * your JavaScript environment to output the files.
 *
 * @param {object} dict - the dictionary data to process
 * @returns {string} The transformed dictionary as Style Dictionary properties (file-ready)
 */
export const styledict = (dict) =>
  Object.entries(dict).reduce((acc, [key, data]) => {
    if (typeof data === "object") {
      return { ...acc, [key]: styledict(data) };
    }
    return { ...acc, [key]: { value: String(data) } };
  }, {});
#+END_SRC

***** Tests

****** Data Transform Assertions

#+BEGIN_SRC js :tangle "./tests/transform_data_test.js" :comments link
import { styledict, tailwind } from "../design_tokens.js";
import { clrs } from "../color.js";
import { triadic } from "../color.js";
import { shades, tints } from "../color.js";

import { assertEquals } from "https://deno.land/std@0.86.0/testing/asserts.ts";

const swatch = clrs("red");
const [main, accent, highlight] = triadic(swatch);
const light = tints.bind(null, 3, 99);
const dark = shades.bind(null, 2, 99);

const dict = {
  color: {
    main: {
      base: main,
      light: light(main)[0],
      lighter: light(main)[1],
      lightest: light(main)[2],
      dark: dark(main)[0],
      darker: dark(main)[1],
    },
    accent: {
      base: accent,
      dark: dark(accent)[0],
      darker: dark(accent)[1],
    },
    highlight,
  },
};

Deno.test(
  "SPEC tailwind: transforms dictionary data into TailwindCSS theme",
  function () {
    assertEquals(tailwind(dict), {
      color: {
        main: {
          DEFAULT: "#ff4036",
          light: "#ff9d99",
          lighter: "#ffd3d2",
          lightest: "#fffefe",
          dark: "#b42d26",
          darker: "#1a0605",
        },
        accent: { DEFAULT: "#4036ff", dark: "#2d26b4", darker: "#06051a" },
        highlight: "#36ff40",
      },
    });
  },
);

Deno.test(
  "SPEC styledict: transforms dictionary data into Style Dictionary properties",
  function () {
    assertEquals(styledict(dict), {
      color: {
        main: {
          base: {
            value: "#ff4036",
          },
          dark: {
            value: "#b42d26",
          },
          darker: {
            value: "#1a0605",
          },
          light: {
            value: "#ff9d99",
          },
          lighter: {
            value: "#ffd3d2",
          },
          lightest: {
            value: "#fffefe",
          },
        },
        accent: {
          base: {
            value: "#4036ff",
          },
          dark: {
            value: "#2d26b4",
          },
          darker: {
            value: "#06051a",
          },
        },
        highlight: {
          value: "#36ff40",
        },
      },
    });
  },
);
#+END_SRC

****** Data Transform Results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./tests/data_transform_test.js)
#+END_SRC

#+NAME: transform-test
#+begin_src shell
running 2 tests
test SPEC tailwind: can reformat a dictionary as Tailwind theme data ... ok (6ms)
test SPEC styledict: can reformat a dictionary as Style Dictionary properties ... ok (13ms)

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (19ms)

#+end_src

** Internals

This section documents and implements useful internal functions that aid in developing the core
itself. They are not publicly accessible. The only reason you'd want to read this section is if
you're interested in the nuts and bolts of this project.

*** Error Handling (=internals/error.js=)

#+BEGIN_SRC js :tangle "./internals/error.js" :comments link
/** Error message template */
export function ErrorTemplate(
  { message, reason, suggestion, output } = {
    message: "something went wrong",
    reason: "here's why",
    suggestion: "try this",
    output: undefined,
  },
) {
  throw new Error(`
ERROR: ${message.trimEnd()}
${"=".repeat(60)}
REASON: ${reason.trimEnd()}
TRY: ${suggestion.trimEnd()}
${"-".repeat(60)}
OUTPUT: ${output};
`);
}
#+END_SRC

I believe in the power of good error messages in helping developers solve their own problems. Human-readable errors also decrease the likelihood that you'll need to consult documentation during your workflow.

The format of error messages thrown by the core is straightforward.

#+BEGIN_SRC text
ERROR: something went wrong
============================================================
REASON: here's why
TRY: troubleshooting suggestions
------------------------------------------------------------
OUTPUT: "and what actually happened";
#+END_SRC

*** Color
**** Supported Formats (=internals/color/formats.js=)

QuarkSuite is designed primarily for web technologies and handles all current (and upcoming) CSS color
formats. This section documents how the QSC validates colors and extracts color values.

It also includes a pseudo-implementation of a non-standard format for special purposes: Oklab.

***** Syntax Tokens

I recently refactored the validation logic through identifying the common tokens across CSS color
formats. So, I captured these repeating patterns as constants.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
// channel: float<0-100>% || int<0-255>
const CHANNEL_TOK =
  /(?:(?:100%|(?:\d\.?\d?){1,}%)|(?:25[0-5]|24[0-4][0-9]|1[0-9]{2}|\d{1,}|0))/;

// hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
const HUE_TOK = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;

// percentage: float<0-100>%
const PERCENT_TOK = /(?:(?:100%|(?:\d\.?\d?){1,}%))/;

// percentage: float<0->%
const CIE_LUM_TOK = /(?:(?:\d\.?\d?){1,}%)/;

// hue: -?<0-128>
const HUE_TOK_CIELAB = /(?:-?(?:128|(?:1[0-2][0-8]|(?:\d.?\d?){1,})))/;

// chroma: int<0-230>
const CHROMA_TOK = /(?:(?:230|(?:2[0-2][0-9]|1[0-9][0-9])|(?:\d.?\d?){1,}))/;

// transparency: float<0-1> || float<0-100>%
const PERCENT_TOK_DECIMAL = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;

// chroma: -?float<0-0.5>
const CHROMA_TOK_OKLAB = /(?:-?(?:0|0\.\d+|0.5))/;

// separators: ", " || " " || " /"
const DELIM = /(?:[\s,]+)/;
const ALPHA_DELIM = /(?:[\s,/]+)/;
const DELIM_CSS4 = /(?:[\s]+)/;
const ALPHA_DELIM_CSS4 = /(?:[\s/]+)/;
#+END_SRC

After that, I wrote a function to assemble these tokens into their valid color formats. The =RegExp=
object includes a property of =source= that allows regular expressions to be concatenated and
assigned to constants. This results in much more readable and configurable pattern matching
possibilities.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
function matchFunctionalFormat({ prefix, legacy = true }, tokens) {
  const tokenValues = tokens.map((tok) => tok.source);
  const ALPHA_TOK = PERCENT_TOK_DECIMAL;

  const DELIMITER = legacy ? DELIM : DELIM_CSS4;
  const ALPHA_DELIMITER = legacy ? ALPHA_DELIM : ALPHA_DELIM_CSS4;
  return new RegExp(
    `(?:^${prefix}\\(`.concat(
      tokenValues.join(DELIMITER.source),
      `(?:${[ALPHA_DELIMITER.source, ALPHA_TOK.source].join("")})?\\))`,
    ),
  );
}
#+END_SRC

***** Value Extractors

During the recent refactor, I also realized that having extractors for every single functional color
format was overkill as they expect many of the same tokens. =hexExtractor= stands alone for its
special purpose while =valueExtractor= handles every other format.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Extract RGB Hex values */
export const hexExtractor = (color) => expandHex(color).match(/[\da-f]{2}/g);

/** Extract functional color format components */
export const valueExtractor = (color) =>
  color.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

***** RGB Hex

In Quarks System Core, hex colors are treated as a universal color format. In all likelihood, if
software operates with color, it renders this format. So RGB Hex can be a reliable fallback when
nothing else works.

#+NAME: hex-samples
| Color   | Value     |
|---------+-----------|
| Black   | =#000000=   |
| Gray    | =#808080=   |
| White   | =#ffffff=   |
| Red     | =#ff0000=   |
| Yellow  | =#ffff00=   |
| Green   | =#00ff00=   |
| Cyan    | =#00ffff=   |
| Blue    | =#0000ff=   |
| Magenta | =#ff00ff=   |
| Etc.    | =#ace=      |
|         | =#bea=      |
|         | =#fed=      |
|         | =#face=     |
|         | =#cafe=     |
|         | =#deaded=   |
|         | =#c0ffee=   |
|         | =#4991ccaa= |
|         | =#abcdef68=  |

****** Hex Validator

The regular expression to validate a hex color is short.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: hex color */
const hexValidator = (color) => /^#([\da-f]{3,4}){1,2}$/i.test(color);
#+END_SRC

Let's see if all the colors defined in the table pass.

#+BEGIN_SRC js :results output code replace :allow read :var hexTable=hex-samples
const { hexValidator } = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = hexTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => hexValidator(color)))
#+END_SRC

#+NAME: valid-hex
#+begin_src js
const colors = [
  "#000000",   "#808080",
  "#ffffff",   "#ff0000",
  "#ffff00",   "#00ff00",
  "#00ffff",   "#0000ff",
  "#ff00ff",   "#ace",
  "#bea",      "#fed",
  "#face",     "#cafe",
  "#deaded",   "#c0ffee",
  "#4991ccaa", "#abcdef68"
]
#+end_src

****** Hex Value Extraction

Now, that I know I have valid hex colors, I need to be able to extract their RGB(A) channels.

The first step is enforcing uniformity. To prevent any surprises, I'm going to simply expand hex
color shorthand =#RGB(A)= to a full hex color =#RRGGBB(AA)=.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Expand hex shorthand into full hex color */
function expandHex(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

Having secured uniform input, I'm ready to extract the channel values for processing.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { hexExtractor } = await import (`${Deno.cwd()}/internals/color/formats.js`);

<<valid-hex>>

console.log("const colors =", colors.map((color) => ({color, values: hexExtractor(color)})));
#+END_SRC

#+NAME: hex-values
#+begin_src js
const colors = [
  { color: "#000000", values: [ "00", "00", "00" ] },
  { color: "#808080", values: [ "80", "80", "80" ] },
  { color: "#ffffff", values: [ "ff", "ff", "ff" ] },
  { color: "#ff0000", values: [ "ff", "00", "00" ] },
  { color: "#ffff00", values: [ "ff", "ff", "00" ] },
  { color: "#00ff00", values: [ "00", "ff", "00" ] },
  { color: "#00ffff", values: [ "00", "ff", "ff" ] },
  { color: "#0000ff", values: [ "00", "00", "ff" ] },
  { color: "#ff00ff", values: [ "ff", "00", "ff" ] },
  { color: "#ace", values: [ "aa", "cc", "ee" ] },
  { color: "#bea", values: [ "bb", "ee", "aa" ] },
  { color: "#fed", values: [ "ff", "ee", "dd" ] },
  { color: "#face", values: [ "ff", "aa", "cc", "ee" ] },
  { color: "#cafe", values: [ "cc", "aa", "ff", "ee" ] },
  { color: "#deaded", values: [ "de", "ad", "ed" ] },
  { color: "#c0ffee", values: [ "c0", "ff", "ee" ] },
  { color: "#4991ccaa", values: [ "49", "91", "cc", "aa" ] },
  { color: "#abcdef68", values: [ "ab", "cd", "ef", "68" ] }
]
#+end_src

***** Named Colors

Named colors are simple to validate. It's a matter of matching the name with its hex value in the
=X11Colors= lookup table as a boolean.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
import { X11Colors } from "../../data/color/w3c-x11.js";

/** Validate: W3C X11 named colors */
const namedValidator = (color) => !!X11Colors[color];
#+END_SRC

***** Functional RGB

Functional RGB is the second most common color format used on the web. It's a great option for if
you need a more human readable format with solid browser support.

#+NAME: rgb-samples
| Color   | Value                    |
|---------+--------------------------|
| Black   | =rgb(0, 0, 0)=             |
| Gray    | =rgb(128, 128, 128)=       |
| White   | =rgb(255, 255, 255)=       |
| Red     | =rgb(255, 0, 0)=           |
| Yellow  | =rgb(255, 255, 0)=         |
| Green   | =rgb(0, 255, 0)=           |
| Cyan    | =rgb(0, 255, 255)=         |
| Blue    | =rgb(0, 0, 255)=           |
| Magenta | =rgb(255, 0, 255)=         |
| Etc.    | =rgb(33, 199, 95)=         |
|         | =rgb(19, 114, 220)=        |
|         | =rgb(10%, 40.4%, 49.9%)=   |
|         | =rgb(200 138 39)=          |
|         | =rgb(31 88 49 / 0.8)=      |
|         | =rgba(110, 33, 110, 0.75)= |
|         | =rgba(10, 119, 30, 30%)=   |

****** RGB Validator

Since all supported color formats beyond RGB Hex are functional, I'm gonna used that
=matchFunctionalFormat= helper I whipped up to fill an array with three =CHANNEL_TOK= and then test
it against the input color. If it matches, it returns the color for further processing.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: functional RGB format */
const rgbValidator = (color) =>
  matchFunctionalFormat({ prefix: "rgba?" }, Array(3).fill(CHANNEL_TOK)).test(
    color,
  );
#+END_SRC

For now I'll check my table of colors.

#+BEGIN_SRC js :results output code replace :allow read :var rgbTable=rgb-samples
const { rgbValidator } = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = rgbTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => rgbValidator(color)))
#+END_SRC

#+NAME: valid-rgb
#+begin_src js
const colors = [
  "rgb(0, 0, 0)",
  "rgb(128, 128, 128)",
  "rgb(255, 255, 255)",
  "rgb(255, 0, 0)",
  "rgb(255, 255, 0)",
  "rgb(0, 255, 0)",
  "rgb(0, 255, 255)",
  "rgb(0, 0, 255)",
  "rgb(255, 0, 255)",
  "rgb(33, 199, 95)",
  "rgb(19, 114, 220)",
  "rgb(10%, 40.4%, 49.9%)",
  "rgb(200 138 39)",
  "rgb(31 88 49 / 0.8)",
  "rgba(110, 33, 110, 0.75)",
  "rgba(10, 119, 30, 30%)"
]
#+end_src

All clear!

****** RGB Value Extraction

Since, I've now implemented a universal functional format value extractor the only thing to do here
is test that it really does extract my values.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-rgb>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: rgb-values
#+begin_src js
const colors = [
  { color: "rgb(0, 0, 0)", values: [ "0", "0", "0" ] },
  { color: "rgb(128, 128, 128)", values: [ "128", "128", "128" ] },
  { color: "rgb(255, 255, 255)", values: [ "255", "255", "255" ] },
  { color: "rgb(255, 0, 0)", values: [ "255", "0", "0" ] },
  { color: "rgb(255, 255, 0)", values: [ "255", "255", "0" ] },
  { color: "rgb(0, 255, 0)", values: [ "0", "255", "0" ] },
  { color: "rgb(0, 255, 255)", values: [ "0", "255", "255" ] },
  { color: "rgb(0, 0, 255)", values: [ "0", "0", "255" ] },
  { color: "rgb(255, 0, 255)", values: [ "255", "0", "255" ] },
  { color: "rgb(33, 199, 95)", values: [ "33", "199", "95" ] },
  { color: "rgb(19, 114, 220)", values: [ "19", "114", "220" ] },
  { color: "rgb(10%, 40.4%, 49.9%)", values: [ "10%", "40.4%", "49.9%" ] },
  { color: "rgb(200 138 39)", values: [ "200", "138", "39" ] },
  { color: "rgb(31 88 49 / 0.8)", values: [ "31", "88", "49", "0.8" ] },
  { color: "rgba(110, 33, 110, 0.75)", values: [ "110", "33", "110", "0.75" ] },
  { color: "rgba(10, 119, 30, 30%)", values: [ "10", "119", "30", "30%" ] }
]
#+end_src

***** Functional HSL

HSL is well-loved by designers for being a lot more intuitive than RGB. It explicitly allows
setting:

+ Hue (H): An angle corresponding to a color's position on an RGB color wheel. =0= degrees
  means red, green sits at =120= degrees, and blue sits at =240=
+ Saturation (S): A percentage value corresponding to a color's vibrance or chroma. =0%= indicates a
  fully unsaturated color (yielding gray). =100%= indicates a fully saturated color
+ Lightness/Luminance (L): A percentage value corresponding to a color's brightness. At =50%= a color
  is normalized. =0%= yields pure black and =100%= yields pure white

#+NAME: hsl-samples
| Color   | Value                         |
|---------+-------------------------------|
| Black   | =hsl(0, 0%, 0%)=                |
| Gray    | =hsl(0, 0%, 50%)=               |
| White   | =hsl(0, 0%, 100%)=              |
| Red     | =hsl(0, 100%, 50%)=             |
| Yellow  | =hsl(60, 100%, 50%)=            |
| Green   | =hsl(120, 100%, 50%)=           |
| Cyan    | =hsl(180, 100%, 50%)=           |
| Blue    | =hsl(240, 100%, 50%)=           |
| Magenta | =hsl(300, 100%, 50%)=           |
| Etc.    | =hsl(38, 78%, 40%)=             |
|         | =hsl(3 88% 70%)=                |
|         | =hsl(189 63% 85% / 0.71)=       |
|         | =hsla(1.5rad, 73%, 10%, 0.831)= |
|         | =hsl(320grad 89% 36% / 79%)=    |
|         | =hsl(0.36turn 83% 90%)=       |

****** HSL Validator

This time the value tokens the validator checks for are =HUE_TOK= and two matching =PERCENT_TOK=.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: functional HSL format */
const hslValidator = (color) =>
  matchFunctionalFormat({ prefix: "hsla?" }, [
    HUE_TOK,
    ...Array(2).fill(PERCENT_TOK),
  ]).test(color);
#+END_SRC

Then I check the implementation against my color samples.

#+BEGIN_SRC js :results output code replace :allow read :var hslTable=hsl-samples
const { hslValidator} = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = hslTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => hslValidator(color)))
#+END_SRC

#+NAME: valid-hsl
#+begin_src js
const colors = [
  "hsl(0, 0%, 0%)",
  "hsl(0, 0%, 50%)",
  "hsl(0, 0%, 100%)",
  "hsl(0, 100%, 50%)",
  "hsl(60, 100%, 50%)",
  "hsl(120, 100%, 50%)",
  "hsl(180, 100%, 50%)",
  "hsl(240, 100%, 50%)",
  "hsl(300, 100%, 50%)",
  "hsl(38, 78%, 40%)",
  "hsl(3 88% 70%)",
  "hsl(189 63% 85% / 0.71)",
  "hsla(1.5rad, 73%, 10%, 0.831)",
  "hsl(320grad 89% 36% / 79%)",
  "hsl(0.36turn 83% 90%)"
]
#+end_src

****** HSL Value Extraction

Finally, I'll test that the universal extractor works with HSL.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-hsl>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: hsl-values
#+begin_src js
const colors = [
  { color: "hsl(0, 0%, 0%)", values: [ "0", "0%", "0%" ] },
  { color: "hsl(0, 0%, 50%)", values: [ "0", "0%", "50%" ] },
  { color: "hsl(0, 0%, 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hsl(0, 100%, 50%)", values: [ "0", "100%", "50%" ] },
  { color: "hsl(60, 100%, 50%)", values: [ "60", "100%", "50%" ] },
  { color: "hsl(120, 100%, 50%)", values: [ "120", "100%", "50%" ] },
  { color: "hsl(180, 100%, 50%)", values: [ "180", "100%", "50%" ] },
  { color: "hsl(240, 100%, 50%)", values: [ "240", "100%", "50%" ] },
  { color: "hsl(300, 100%, 50%)", values: [ "300", "100%", "50%" ] },
  { color: "hsl(38, 78%, 40%)", values: [ "38", "78%", "40%" ] },
  { color: "hsl(3 88% 70%)", values: [ "3", "88%", "70%" ] },
  { color: "hsl(189 63% 85% / 0.71)", values: [ "189", "63%", "85%", "0.71" ] },
  {
    color: "hsla(1.5rad, 73%, 10%, 0.831)",
    values: [ "1.5rad", "73%", "10%", "0.831" ]
  },
  { color: "hsl(320grad 89% 36% / 79%)", values: [ "320grad", "89%", "36%", "79%" ] },
  { color: "hsl(0.36turn 83% 90%)", values: [ "0.36turn", "83%", "90%" ] }
]
#+end_src

We're all set for validation and extraction of CSS color formats that are available in the browser,
so I'm moving on to the future formats being drafted in CSS Color Module 4.

***** Device CMYK

=device-cmyk()= is a prospective format documented in the [[https://www.w3.org/TR/css-color-4/#device-cmyk][current CSS Color Module 4 draft]]. CMYK in
general is a color space typically calibrated for printed media.

+ Cyan (C): the amount of cyan ink in the color
+ Magenta (M): the amount of magenta ink in the color
+ Yellow (Y): the amount of yellow ink in the color
+ BlacK (K): the amount of black ink in the color

It's important to note: as a newer CSS color functional format, =device-cmyk()= doesn't bother with
the older comma-separated syntax, so neither does the Quarks System Core. The same carries for all
formats beyond this point.

#+NAME: cmyk-samples
| Color   | Value                             |
|---------+-----------------------------------|
| Black   | =device-cmyk(0% 0% 0% 100%)=        |
| Gray    | =device-cmyk(0% 0% 0% 50%)=         |
| White   | =device-cmyk(0% 0% 0% 0%)=          |
| Red     | =device-cmyk(0% 100% 100% 0%)=      |
| Yellow  | =device-cmyk(0% 0% 100% 0%)=        |
| Green   | =device-cmyk(100% 0% 100% 0%)=      |
| Cyan    | =device-cmyk(100% 0% 0% 0%)=        |
| Blue    | =device-cmyk(100% 100% 0% 0%)=      |
| Magenta | =device-cmyk(0% 100% 0% 0%)=        |
| Etc.    | =device-cmyk(37% 63% 0 0)=          |
|         | =device-cmyk(50% 25% 10% 0)=        |
|         | =device-cmyk(0.77 0.33 0 0)=        |
|         | =device-cmyk(0.8 0 0.4 0.13 / 0.8)= |
|         | =device-cmyk(25% 75% 8% 3% / 81.3%)= |

****** CMYK Validator

The validator for CMYK is similar to RGB in that  =PERCENT_TOK_DECIMAL= simply fills out an array.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: CMYK format */
const cmykValidator = (color) =>
  matchFunctionalFormat(
    { prefix: "device-cmyk", legacy: false },
    Array(4).fill(PERCENT_TOK_DECIMAL),
  ).test(color);
#+END_SRC

Now, on to the format tests.

#+BEGIN_SRC js :results output code replace :allow read :var cmykTable=cmyk-samples
const cmyk = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = cmykTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => cmyk.validate(color)));
#+END_SRC

#+NAME: valid-cmyk
#+begin_src js
const colors = [
  "device-cmyk(0% 0% 0% 100%)",
  "device-cmyk(0% 0% 0% 50%)",
  "device-cmyk(0% 0% 0% 0%)",
  "device-cmyk(0% 100% 100% 0%)",
  "device-cmyk(0% 0% 100% 0%)",
  "device-cmyk(100% 0% 100% 0%)",
  "device-cmyk(100% 0% 0% 0%)",
  "device-cmyk(100% 100% 0% 0%)",
  "device-cmyk(0% 100% 0% 0%)",
  "device-cmyk(37% 63% 0 0)",
  "device-cmyk(50% 25% 10% 0)",
  "device-cmyk(0.77 0.33 0 0)",
  "device-cmyk(0.8 0 0.4 0.13 / 0.8)",
  "device-cmyk(25% 75% 8% 3% / 81.3%)"
]
#+end_src

****** CMYK Value Extraction

Time to test that the universal extractor behaves with CMYK.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-cmyk>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: cmyk-values
#+begin_src js
const colors = [
  { color: "device-cmyk(0% 0% 0% 100%)", values: [ "0%", "0%", "0%", "100%" ] },
  { color: "device-cmyk(0% 0% 0% 50%)", values: [ "0%", "0%", "0%", "50%" ] },
  { color: "device-cmyk(0% 0% 0% 0%)", values: [ "0%", "0%", "0%", "0%" ] },
  { color: "device-cmyk(0% 100% 100% 0%)", values: [ "0%", "100%", "100%", "0%" ] },
  { color: "device-cmyk(0% 0% 100% 0%)", values: [ "0%", "0%", "100%", "0%" ] },
  { color: "device-cmyk(100% 0% 100% 0%)", values: [ "100%", "0%", "100%", "0%" ] },
  { color: "device-cmyk(100% 0% 0% 0%)", values: [ "100%", "0%", "0%", "0%" ] },
  { color: "device-cmyk(100% 100% 0% 0%)", values: [ "100%", "100%", "0%", "0%" ] },
  { color: "device-cmyk(0% 100% 0% 0%)", values: [ "0%", "100%", "0%", "0%" ] },
  { color: "device-cmyk(37% 63% 0 0)", values: [ "37%", "63%", "0", "0" ] },
  { color: "device-cmyk(50% 25% 10% 0)", values: [ "50%", "25%", "10%", "0" ] },
  { color: "device-cmyk(0.77 0.33 0 0)", values: [ "0.77", "0.33", "0", "0" ] },
  {
    color: "device-cmyk(0.8 0 0.4 0.13 / 0.8)",
    values: [ "0.8", "0", "0.4", "0.13", "0.8" ]
  },
  {
    color: "device-cmyk(25% 75% 8% 3% / 81.3%)",
    values: [ "25%", "75%", "8%", "3%", "81.3%" ]
  }
]
#+end_src

And now it's on to the next one.

***** Functional HWB

HWB is short for Hue-Whiteness-Blackness. It's an [[https://www.w3.org/TR/css-color-4/#the-hwb-notation][upcoming color format similar to HSL]] but even
easier to use. It's the format of choice for a variety of browser color picker implementations.

+ Hue (H): works the same as it does in the HSL format
+ Whiteness (W): a percentage value corresponding with how much white to mix with the hue
+ Blackness (B): a percentage value corresponding with how much black to mix with the hue

When W and B are mixed equal amounts, they yield gray. When both are =100%=, the color is achromatic.

#+NAME: hwb-samples
| Color   | Value                     |
|---------+---------------------------|
| Black   | =hwb(0 0% 100%)=            |
| Gray    | =hwb(0 100% 100%)=          |
| White   | =hwb(0 100% 0%)=            |
| Red     | =hwb(0 0% 0%)=              |
| Yellow  | =hwb(60 0% 0%)=             |
| Green   | =hwb(120 0% 0%)=            |
| Cyan    | =hwb(180 0% 0%)=            |
| Blue    | =hwb(240 0% 0%)=            |
| Magenta | =hwb(300 0% 0%)=            |
| Etc.    | =hwb(188 20% 3%)=           |
|         | =hwb(3.1rad 50% 0%)=        |
|         | =hwb(183grad 5% 15% / 0.5)= |
|         | =hwb(0.8turn 38% 99%)=      |

****** HWB Validator

The HWB validator expression is essentially the HSL validator with a different prefix.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: functional HWB format */
function hwbValidator(color) {
  return matchFunctionalFormat({ prefix: "hwb", legacy: false }, [
    HUE_TOK,
    ...Array(2).fill(PERCENT_TOK),
  ]).test(color);
}
#+END_SRC

Alright, now the format tests.

#+BEGIN_SRC js :results output code replace :allow read :var hwbTable=hwb-samples
const { hwbValidator } = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = hwbTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => hwbValidator(color)))
#+END_SRC

#+NAME: valid-hwb
#+begin_src js
const colors = [
  "hwb(0 0% 100%)",
  "hwb(0 100% 100%)",
  "hwb(0 100% 0%)",
  "hwb(0 0% 0%)",
  "hwb(60 0% 0%)",
  "hwb(120 0% 0%)",
  "hwb(180 0% 0%)",
  "hwb(240 0% 0%)",
  "hwb(300 0% 0%)",
  "hwb(188 20% 3%)",
  "hwb(3.1rad 50% 0%)",
  "hwb(183grad 5% 15% / 0.5)",
  "hwb(0.8turn 38% 99%)"
]
#+end_src

****** HWB Value Extraction

Now I'll see how the universal extractor feels about this one.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-hwb>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: hwb-values
#+begin_src js
const colors = [
  { color: "hwb(0 0% 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hwb(0 100% 100%)", values: [ "0", "100%", "100%" ] },
  { color: "hwb(0 100% 0%)", values: [ "0", "100%", "0%" ] },
  { color: "hwb(0 0% 0%)", values: [ "0", "0%", "0%" ] },
  { color: "hwb(60 0% 0%)", values: [ "60", "0%", "0%" ] },
  { color: "hwb(120 0% 0%)", values: [ "120", "0%", "0%" ] },
  { color: "hwb(180 0% 0%)", values: [ "180", "0%", "0%" ] },
  { color: "hwb(240 0% 0%)", values: [ "240", "0%", "0%" ] },
  { color: "hwb(300 0% 0%)", values: [ "300", "0%", "0%" ] },
  { color: "hwb(188 20% 3%)", values: [ "188", "20%", "3%" ] },
  { color: "hwb(3.1rad 50% 0%)", values: [ "3.1rad", "50%", "0%" ] },
  { color: "hwb(183grad 5% 15% / 0.5)", values: [ "183grad", "5%", "15%", "0.5" ] },
  { color: "hwb(0.8turn 38% 99%)", values: [ "0.8turn", "38%", "99%" ] }
]
#+end_src

***** Functional CIELAB

The CSS Color Module Level 4 is currently drafting [[https://www.w3.org/TR/css-color-4/#lab-colors][support for device-independent color
formats]]. Quarks System Core supports both.

First up is the CIELAB (often called Lab for short) color format. The format specification is better
explained on the linked W3C page above, but I'll summarize the components:

+ Lightness (L): a percentage value which, unlike HSL, is /not/ capped at =100%= for this space
+ hues (*a): magenta-red when positive, its complement when negative
+ hues (*b): yellow when positive, its complement when negative

The hue axes are unbound, but for use with the RGB space /must/ cap at =±128=.

#+NAME: cielab-samples
| Color   | Value                           |
|---------+---------------------------------|
| Black   | =lab(0% 0 0)=                     |
| Gray    | =lab(53.59% 0 0)=                 |
| White   | =lab(100% 0 0)=                   |
| Red     | =lab(54.29% 80.81 69.89)=         |
| Yellow  | =lab(97.6% -15.75 93.39)=         |
| Green   | =lab(87.82% -79.29 80.99)=        |
| Cyan    | =lab(90.67% -50.67 -14.96)=       |
| Blue    | =lab(29.57% 68.3 -112.03)=        |
| Magenta | =lab(60.17% 93.55 -60.5)=         |
| Etc.    | =lab(49.18% 38.1 -110.33)=        |
|         | =lab(91.3% -93 14)=               |
|         | =lab(83.119% 49.34 -3.99 / 0.75)= |
|         | =lab(199% 38 13 / 78%)=         |

****** CIELAB Validator

The CIELAB validator consists of =CIE_LUM_TOK= and =HUE_TOK_CIELAB= filling out the rest of the components.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: functional CIELAB format */
export function cielabValidator(color) {
  return matchFunctionalFormat({ prefix: "lab", legacy: false }, [
    CIE_LUM_TOK,
    ...Array(2).fill(HUE_TOK_CIELAB),
  ]).test(color);
}
#+END_SRC

Now, it's validator testing time.

#+BEGIN_SRC js :results output code replace :allow read :var cielabTable=cielab-samples
const { cielabValidator } = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = cielabTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => cielabValidator(color)))
#+END_SRC

#+NAME: valid-cielab
#+begin_src js
const colors = [
  "lab(0% 0 0)",
  "lab(53.59% 0 0)",
  "lab(100% 0 0)",
  "lab(54.29% 80.81 69.89)",
  "lab(97.6% -15.75 93.39)",
  "lab(87.82% -79.29 80.99)",
  "lab(90.67% -50.67 -14.96)",
  "lab(29.57% 68.3 -112.03)",
  "lab(60.17% 93.55 -60.5)",
  "lab(49.18% 38.1 -110.33)",
  "lab(91.3% -93 14)",
  "lab(83.119% 49.34 -3.99 / 0.75)",
  "lab(199% 38 13 / 78%)"
]
#+end_src

Good to go.

****** CIELAB Value Extraction

Calling upon my trusty universal extractor once again.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-lab>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: lab-values
#+begin_src js
const colors = [
  { color: "lab(0% 0 0)", values: [ "0%", "0", "0" ] },
  { color: "lab(53.59% 0 0)", values: [ "53.59%", "0", "0" ] },
  { color: "lab(100% 0 0)", values: [ "100%", "0", "0" ] },
  { color: "lab(54.29% 80.81 69.89)", values: [ "54.29%", "80.81", "69.89" ] },
  { color: "lab(97.6% -15.75 93.39)", values: [ "97.6%", "-15.75", "93.39" ] },
  { color: "lab(87.82% -79.29 80.99)", values: [ "87.82%", "-79.29", "80.99" ] },
  { color: "lab(90.67% -50.67 -14.96)", values: [ "90.67%", "-50.67", "-14.96" ] },
  { color: "lab(29.57% 68.3 -112.03)", values: [ "29.57%", "68.3", "-112.03" ] },
  { color: "lab(60.17% 93.55 -60.5)", values: [ "60.17%", "93.55", "-60.5" ] },
  { color: "lab(49.18% 38.1 -110.33)", values: [ "49.18%", "38.1", "-110.33" ] },
  { color: "lab(91.3% -93 14)", values: [ "91.3%", "-93", "14" ] },
  {
    color: "lab(83.119% 49.34 -3.99 / 0.75)",
    values: [ "83.119%", "49.34", "-3.99", "0.75" ]
  },
  { color: "lab(199% 38 13 / 78%)", values: [ "199%", "38", "13", "78%" ] }
]
#+end_src

***** Functional CIELCh(ab)

The CIELCh(ab) color space is another device-independent color format with added support in the CSS
Color Module Level 4 spec. It's CIELAB converted directly to polar coordinates. It consists of:

+ Lightness (L): a percentage value interpreted identically to CIELAB lightness
+ Chroma (C): a value corresponding to the amount of color desired
+ Hue (h): interpreted similar to HSL, but the angles map to the *a/*b axes

The chroma is theoretically boundless, but in everyday use caps at =230=. The hues at =0deg= and =180deg=
map to magenta-red and green-cyan, respectively. The hues at =90deg= and =270deg= map to a mustard
yellow and sky blue, respectively.

#+NAME: cielch-samples
| Color   | Value                              |
|---------+------------------------------------|
| Black   | =lch(0% 0 0)=                        |
| Gray    | =lch(53.59% 0 0)=                    |
| White   | =lch(100% 0 0)=                      |
| Red     | =lch(54.29% 106.84 40.855)=          |
| Yellow  | =lch(97.6% 94.709 99.573)=           |
| Green   | =lch(87.82% 113.34 134.39)=          |
| Cyan    | =lch(90.67% 52.832 196.45)=          |
| Blue    | =lch(29.57% 131.21 301.369)=         |
| Magenta | =lch(60.17% 111.41 327.109)=         |
| Etc.    | =lch(53.31% 89.31 200)=              |
|         | =lch(89.1% 167.34 3.6rad / 0.99)=    |
|         | =lch(24.494% 74.9 193grad)=          |
|         | =lch(47.39% 111.193 0.62turn / 75%)= |

****** CIELCh(ab) Validator

The CIELCh(ab) validator maps a =CIE_LUM_TOK=, a =CHROMA_TOK=, and a =HUE_TOK=.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: functional CIELCh(ab) format */
function cielchValidator(color) {
  return matchFunctionalFormat({ prefix: "lch", legacy: false }, [
    CIE_LUM_TOK,
    CHROMA_TOK,
    HUE_TOK,
  ]).test(color);
}
#+END_SRC

And when I test the color table:

#+BEGIN_SRC js :results output code replace :allow read :var cielchTable=cielch-samples
const { cielchValidator } = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = cielchTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => cielchValidator(color)))
#+END_SRC

#+NAME: valid-cielch
#+begin_src js
const colors = [
  "lch(0% 0 0)",
  "lch(53.59% 0 0)",
  "lch(100% 0 0)",
  "lch(54.29% 106.84 40.855)",
  "lch(97.6% 94.709 99.573)",
  "lch(87.82% 113.34 134.39)",
  "lch(90.67% 52.832 196.45)",
  "lch(29.57% 131.21 301.369)",
  "lch(60.17% 111.41 327.109)",
  "lch(53.31% 89.31 200)",
  "lch(89.1% 167.34 3.6rad / 0.99)",
  "lch(24.494% 74.9 193grad)",
  "lch(47.39% 111.193 0.62turn / 75%)"
]
#+end_src

****** CIELCh(ab) Value Extraction

Now, I'll set up some extraction tests.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-lch>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: lch-values
#+begin_src js
const colors = [
  { color: "lch(0% 0 0)", values: [ "0%", "0", "0" ] },
  { color: "lch(53.59% 0 0)", values: [ "53.59%", "0", "0" ] },
  { color: "lch(100% 0 0)", values: [ "100%", "0", "0" ] },
  { color: "lch(54.29% 106.84 40.855)", values: [ "54.29%", "106.84", "40.855" ] },
  { color: "lch(97.6% 94.709 99.573)", values: [ "97.6%", "94.709", "99.573" ] },
  { color: "lch(87.82% 113.34 134.39)", values: [ "87.82%", "113.34", "134.39" ] },
  { color: "lch(90.67% 52.832 196.45)", values: [ "90.67%", "52.832", "196.45" ] },
  { color: "lch(29.57% 131.21 301.369)", values: [ "29.57%", "131.21", "301.369" ] },
  { color: "lch(60.17% 111.41 327.109)", values: [ "60.17%", "111.41", "327.109" ] },
  { color: "lch(53.31% 89.31 200)", values: [ "53.31%", "89.31", "200" ] },
  {
    color: "lch(89.1% 167.34 3.6rad / 0.99)",
    values: [ "89.1%", "167.34", "3.6rad", "0.99" ]
  },
  { color: "lch(24.494% 74.9 193grad)", values: [ "24.494%", "74.9", "193grad" ] },
  {
    color: "lch(47.39% 111.193 0.62turn / 75%)",
    values: [ "47.39%", "111.193", "0.62turn", "75%" ]
  }
]
#+end_src

And that's it. Full support for validating and extracting the values of all current (and future) CSS
color formats. Not very useful  by itself, so I'm going to write functionality to convert between them.

***** Oklab (LCh)

Oklab is a non-standard perceptual color space created by Björn Ottosson. It's a derivative of
CIELAB that fixes some of its shortcomings in predicting hue and especially sudden hue shifting of
blues toward purple.

I decided to support it after realizing that HSL is a terrible space to make color adjustments in
and standard CIELCh(ab) fell just short of my expectations for color scheme and variant generation.

It was this [[https://observablehq.com/@joshdata/perceptually-valid-color-scales][demonstration of perceptually valid color scales]] that finally convinced me that Oklab
had that special sauce.

As a bonus, it's simple to implement.

Quarks System Core processes Oklab colors in its polar coordinates form similar to CIELCh(ab) to
ease value extraction and adjustment.

Though, I should note that the chroma component uses a different range (=0-0.5=).

#+NAME: oklab-samples
| Color   | Value                       |
|---------+-----------------------------|
| Black   | =oklab(0% 0 0)=             |
| Gray    | =oklab(59.987% 0 0)=        |
| White   | =oklab(100% 0 0)=           |
| Red     | =oklab(62.795% 0.25768 29.234)= |
| Yellow  | =oklab(96.768% 0.21101 109.77)= |
| Green   | =oklab(86.644% 0.29483 142.5)= |
| Cyan    | =oklab(90.54% 0.15455 194.77)= |
| Blue    | =oklab(45.201% 0.31321 264.052)= |
| Magenta | =oklab(70.167% 0.32249 328.363)= |
| Etc.    | =oklab(37.119% 0.482 90)=   |
|         | =oklab(29.11% 0.25 180)=    |
|         | =oklab(53.33% 0.5 270)=     |
|         | =oklab(84% 0.1043 350.31)=  |
|         | =oklab(25.14% 0.44 60 / 0.8)= |

****** Oklab (LCh) Validator

The Oklab validator is similar to the standard CIELCh(ab) validator but the chroma token is replaced
with =CHROMA_TOK_OKLAB=.

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
/** Validate: Oklab (LCh) format */
function oklabValidator(color) {
  return matchFunctionalFormat({ prefix: "oklab", legacy: false }, [
    CIE_LUM_TOK,
    CHROMA_TOK_OKLAB,
    HUE_TOK,
  ]).test(color);
}
#+END_SRC

Now for some tests.

#+BEGIN_SRC js :results output code replace :allow read :var oklabTable=oklab-samples
const { oklabValidator } = await import(`${Deno.cwd()}/internals/color/formats.js`);
const colors = oklabTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.filter((color) => oklabValidator(color)))
#+END_SRC

#+NAME: valid-oklab
#+begin_src deno
const colors = [
  "oklab(0% 0 0)",
  "oklab(59.987% 0 0)",
  "oklab(100% 0 0)",
  "oklab(62.795% 0.25768 29.234)",
  "oklab(96.768% 0.21101 109.77)",
  "oklab(86.644% 0.29483 142.5)",
  "oklab(90.54% 0.15455 194.77)",
  "oklab(45.201% 0.31321 264.052)",
  "oklab(70.167% 0.32249 328.363)",
  "oklab(37.119% 0.482 90)",
  "oklab(29.11% 0.25 180)",
  "oklab(53.33% 0.5 270)",
  "oklab(84% 0.1043 350.31)",
  "oklab(25.14% 0.44 60 / 0.8)"
]
#+end_src

****** Oklab (LCh) Value Extraction

Now, I'll make sure the values are properly extracted.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { valueExtractor } = await import(`${Deno.cwd()}/internals/color/formats.js`);

<<valid-oklab>>

console.log("const colors =", colors.map((color) => ({ color, values: valueExtractor(color) })));
#+END_SRC

#+NAME: oklab-values
#+begin_src deno
const colors = [
  { color: "oklab(0% 0 0)", values: [ "0%", "0", "0" ] },
  { color: "oklab(59.987% 0 0)", values: [ "59.987%", "0", "0" ] },
  { color: "oklab(100% 0 0)", values: [ "100%", "0", "0" ] },
  {
    color: "oklab(62.795% 0.25768 29.234)",
    values: [ "62.795%", "0.25768", "29.234" ]
  },
  {
    color: "oklab(96.768% 0.21101 109.77)",
    values: [ "96.768%", "0.21101", "109.77" ]
  },
  {
    color: "oklab(86.644% 0.29483 142.5)",
    values: [ "86.644%", "0.29483", "142.5" ]
  },
  {
    color: "oklab(90.54% 0.15455 194.77)",
    values: [ "90.54%", "0.15455", "194.77" ]
  },
  {
    color: "oklab(45.201% 0.31321 264.052)",
    values: [ "45.201%", "0.31321", "264.052" ]
  },
  {
    color: "oklab(70.167% 0.32249 328.363)",
    values: [ "70.167%", "0.32249", "328.363" ]
  },
  { color: "oklab(37.119% 0.482 90)", values: [ "37.119%", "0.482", "90" ] },
  { color: "oklab(29.11% 0.25 180)", values: [ "29.11%", "0.25", "180" ] },
  { color: "oklab(53.33% 0.5 270)", values: [ "53.33%", "0.5", "270" ] },
  { color: "oklab(84% 0.1043 350.31)", values: [ "84%", "0.1043", "350.31" ] },
  { color: "oklab(25.14% 0.44 60 / 0.8)", values: [ "25.14%", "0.44", "60", "0.8" ] }
]
#+end_src

***** Batch Validation

Now I wrap the validators as a default export. This allows me to cherry pick the extractors as
they're needed in =conversions.js= but /iterate/ over the validators to break the process down to a
boolean condition: is this a color or not?

#+BEGIN_SRC js :tangle "./internals/color/formats.js" :comments link
export default new Map([
  ["named", namedValidator],
  ["hex", hexValidator],
  ["rgb", rgbValidator],
  ["hsl", hslValidator],
  ["cmyk", cmykValidator],
  ["hwb", hwbValidator],
  ["cielab", cielabValidator],
  ["cielch", cielchValidator],
  ["oklab", oklabValidator],
]);
#+END_SRC

**** Format Conversions (=internals/color/conversions.js=)

I refactored the conversion functions to eliminate that isolated value extraction step so that I
don't have to account for that explicitly in my conversion chains.

Instead of extracted values, they now work with colors directly. It was a totally unnecessary
"optimization" that I've since corrected.

I also discarded the previous =inputFormat.outputFormat(color)= structure in favor of a more
intentional naming convention.

+ =inputFormatToOutputFormat(color)=: indicates a forward conversion
+ =outputFormatFromInputFormat(color)=: indicates a back conversion

Finally, I flattened the whole thing down to a single file to minimize HTTP requests when importing
the library from its package URL.

***** RGB Hex Conversions

To reiterate, a hex color is the primitive color value. They may convert /to/ another format,
but can only be converted /from/ named colors.

****** RGB Hex to Functional RGB

Converting RGB Hex to functional RGB is a matter of extracting each channel hex fragment and
converting them to their equivalent integers. And then converting the alpha channel /if/ it exists.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
import { calcFractionFromChannel, hexFragmentToChannel } from "./math.js";
import { hexExtractor, valueExtractor } from "./formats.js";

/** RGB Hex to Functional RGB */
function hexToRGB(color) {
  const [r, g, b, a] = hexExtractor(color);

  const [R, G, B] = [r, g, b].map((hex) => hexFragmentToChannel(hex));
  const A = (a && calcFractionFromChannel(hexFragmentToChannel(a ?? "ff"))) ||
    1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

For testing my implementation, I'll reuse the extracted hex results above.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { hexToRGB } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-hex>>

console.log(colors.map((color) => ({input: color, output: hexToRGB(color) })));
#+END_SRC

#+NAME: hex-to-rgb
#+begin_src js
[
  { input: "#000000", output: "rgb(0, 0, 0)" },
  { input: "#808080", output: "rgb(128, 128, 128)" },
  { input: "#ffffff", output: "rgb(255, 255, 255)" },
  { input: "#ff0000", output: "rgb(255, 0, 0)" },
  { input: "#ffff00", output: "rgb(255, 255, 0)" },
  { input: "#00ff00", output: "rgb(0, 255, 0)" },
  { input: "#00ffff", output: "rgb(0, 255, 255)" },
  { input: "#0000ff", output: "rgb(0, 0, 255)" },
  { input: "#ff00ff", output: "rgb(255, 0, 255)" },
  { input: "#ace", output: "rgb(170, 204, 238)" },
  { input: "#bea", output: "rgb(187, 238, 170)" },
  { input: "#fed", output: "rgb(255, 238, 221)" },
  { input: "#face", output: "rgba(255, 170, 204, 0.9333)" },
  { input: "#cafe", output: "rgba(204, 170, 255, 0.9333)" },
  { input: "#deaded", output: "rgb(222, 173, 237)" },
  { input: "#c0ffee", output: "rgb(192, 255, 238)" },
  { input: "#4991ccaa", output: "rgba(73, 145, 204, 0.6667)" },
  { input: "#abcdef68", output: "rgba(171, 205, 239, 0.4078)" }
]
#+end_src

Success!

***** Named Color Conversion

****** RGB Hex from Named Color

After validation, the only possible conversion for a CSS named color is a query for its hex value.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
import { X11Colors } from "../../data/color/w3c-x11.js";

/** RGB HEX <- W3C-X11 */
const hexFromNamed = (color) => X11Colors[color];
#+END_SRC

***** Functional RGB Conversion

Functional RGB operates as a nexus bridging the many formats supported by Quarks System Core. This
is because when designing for screens, every converted color must generally fall within the sRGB gamut.

Functional RGB conversions are slightly more complex than RGB Hex conversions, so they require a bit
of extra math. Luckily, I defined those arithmetic helpers, so I'll pull in the necessary ones.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
import {
  calcChannelFromPercent,
  calcFractionFromPercent,
  calcHexFragmentFromAlpha,
  calcHueFromRad,
  calcPercentFromFraction,
  channelToHexFragment,
  correctHueCounterClockwise,
  enforcePrecision,
  normalize,
} from "./math.js";
#+END_SRC

After that, I need to write a function to ensure that the RGB(A) values I use for calculation are uniform.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** A helper function to prep RGB values for calculations */
function parseRGB(color) {
  const [r, g, b, alpha] = valueExtractor(color);
  const value = (s) => parseFloat(s);

  const [R, G, B] = [r, g, b].map((channel) =>
    channel.endsWith("%")
      ? enforcePrecision(calcChannelFromPercent(value(channel)))
      : enforcePrecision(value(channel))
  );

  const a = value(alpha);
  const A = a != null
    ? (a > 1 ? enforcePrecision(calcFractionFromPercent(a)) : a)
    : 1;

  return A === 1 ? [R, G, B] : [R, G, B, A];
}
#+END_SRC

****** RGB Hex from Functional RGB

A regressive conversion is one that breaks a color down. Since an RGB color begins the chain to
higher conversions, that leaves RGB Hex as the only possible regression.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** RGB Hex from Functional RGB */
function hexFromRGB(color) {
  const [r, g, b, alpha] = parseRGB(color);

  const [R, G, B] = [r, g, b].map((channel) => channelToHexFragment(channel));
  // Alpha is defined and not null
  const A = (alpha && calcHexFragmentFromAlpha(alpha)) || "ff";

  return A === "ff" ? `#${R}${G}${B}` : `#${R}${G}${B}${A}`;
}
#+END_SRC

Now, I'll use the RGB output defined earlier to test my conversions for accuracy.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { hexFromRGB } = await import(`${Js.cwd()}/internals/color/conversions.js`);

<<valid-rgb>>

console.log(colors.map((color) => ({ input: color, output: hexFromRGB(color) })));
#+END_SRC

#+NAME: hex-from-rgb
#+begin_src js
[
  { input: "rgb(0, 0, 0)", output: "#000000" },
  { input: "rgb(128, 128, 128)", output: "#808080" },
  { input: "rgb(255, 255, 255)", output: "#ffffff" },
  { input: "rgb(255, 0, 0)", output: "#ff0000" },
  { input: "rgb(255, 255, 0)", output: "#ffff00" },
  { input: "rgb(0, 255, 0)", output: "#00ff00" },
  { input: "rgb(0, 255, 255)", output: "#00ffff" },
  { input: "rgb(0, 0, 255)", output: "#0000ff" },
  { input: "rgb(255, 0, 255)", output: "#ff00ff" },
  { input: "rgb(33, 199, 95)", output: "#21c75f" },
  { input: "rgb(19, 114, 220)", output: "#1372dc" },
  { input: "rgb(10%, 40.4%, 49.9%)", output: "#1a677f" },
  { input: "rgb(200 138 39)", output: "#c88a27" },
  { input: "rgb(31 88 49 / 0.8)", output: "#1f5831cc" },
  { input: "rgba(110, 33, 110, 0.75)", output: "#6e216ebf" },
  { input: "rgba(10, 119, 30, 30%)", output: "#0a771e4d" }
]
#+end_src

****** Functional RGB to Functional HSL

Functional RGB to Functional HSL conversion was supported in QuarkSuite 1, so the algorithm hasn't
changed its implementation. First, it requires a little prep.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
// https://www.rapidtables.com/convert/color/rgb-to-hsl.html
const calcHue = (R, G, B, cmax, delta) =>
  new Map([
    [0, delta === 0],
    [60 * (((G - B) / delta) % 6), cmax === R],
    [60 * ((B - R) / delta + 2), cmax === G],
    [60 * ((R - G) / delta + 4), cmax === B],
  ]);

const calcSat = (delta, L) =>
  delta === 0 ? 0 : delta / (1 - Math.abs(2 * L - 1));

const calcLightness = (cmin, cmax) => (cmax + cmin) / 2;

function calcHSL(r, g, b) {
  const [R, G, B] = [r, g, b].map((channel) =>
    calcFractionFromChannel(channel)
  );

  const cmin = Math.min(R, G, B);
  const cmax = Math.max(R, G, B);
  const delta = cmax - cmin;

  const [H] = Array.from(calcHue(R, G, B, cmax, delta))
    .filter(([, condition]) => condition)
    .flatMap(([value]) => Math.round(value));

  const L = calcLightness(cmin, cmax);

  const S = calcSat(delta, L);

  return [Math.sign(H) === -1 ? correctHueCounterClockwise(H) : H, S, L];
}
#+END_SRC

And now the actual conversion algorithm:

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB to Functional HSL */
function rgbToHSL(color) {
  const [r, g, b, alpha] = parseRGB(color);
  const [h, s, l] = calcHSL(r, g, b);

  const [H, S, L] = [
    h,
    enforcePrecision(calcPercentFromFraction(s)),
    enforcePrecision(calcPercentFromFraction(l)),
  ];
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `hsl(${H}, ${S}%, ${L}%)` : `hsla(${H}, ${S}%, ${L}%, ${A})`;
}
#+END_SRC

Time for some color conversion tests!

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbToHSL } = await import(`${Js.cwd()}/internals/color/conversions.js`);

<<valid-rgb>>

console.log(colors.map((color) => ({input: color, output: rgbToHSL(color)})));
#+END_SRC

#+NAME: rgb-to-hsl
#+begin_src js
[
  { input: "rgb(0, 0, 0)", output: "hsl(0, 0%, 0%)" },
  { input: "rgb(128, 128, 128)", output: "hsl(0, 0%, 50.2%)" },
  { input: "rgb(255, 255, 255)", output: "hsl(0, 0%, 100%)" },
  { input: "rgb(255, 0, 0)", output: "hsl(0, 100%, 50%)" },
  { input: "rgb(255, 255, 0)", output: "hsl(60, 100%, 50%)" },
  { input: "rgb(0, 255, 0)", output: "hsl(120, 100%, 50%)" },
  { input: "rgb(0, 255, 255)", output: "hsl(180, 100%, 50%)" },
  { input: "rgb(0, 0, 255)", output: "hsl(240, 100%, 50%)" },
  { input: "rgb(255, 0, 255)", output: "hsl(300, 100%, 50%)" },
  { input: "rgb(33, 199, 95)", output: "hsl(142, 71.55%, 45.49%)" },
  { input: "rgb(19, 114, 220)", output: "hsl(212, 84.1%, 46.86%)" },
  { input: "rgb(10%, 40.4%, 49.9%)", output: "hsl(194, 66.6%, 29.94%)" },
  { input: "rgb(200 138 39)", output: "hsl(37, 67.37%, 46.86%)" },
  { input: "rgb(31 88 49 / 0.8)", output: "hsla(139, 47.89%, 23.34%, 0.8)" },
  { input: "rgba(110, 33, 110, 0.75)", output: "hsla(300, 53.85%, 28.04%, 0.75)" },
  { input: "rgba(10, 119, 30, 30%)", output: "hsla(131, 84.5%, 25.3%, 0.3)" }
]
#+end_src

Booyah!

****** Functional RGB to Device CMYK

And now I drift again into unfamiliar terrain, but RapidTables is there again to provide a map.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB to Device CMYK */
function rgbToCMYK(color) {
  const [r, g, b, alpha] = parseRGB(color);
  const [R, G, B] = [r, g, b].map((channel) =>
    calcFractionFromChannel(channel)
  );

  // https://www.rapidtables.com/convert/color/rgb-to-cmyk.html
  const k = 1 - Math.max(R, G, B);
  const [c, m, y] = [R, G, B].map((channel) => (1 - channel - k) / (1 - k));
  const A = (alpha && (alpha ?? 1)) || 1;

  // Many examples in the CSS Color Module Level 4 use the percentage format,
  // so I'm assuming that's the preferred format in conversions.
  const [C, M, Y, K] = [c, m, y, k].map((component) =>
    isNaN(component) ? 0 : enforcePrecision(calcPercentFromFraction(component))
  );

  return A === 1
    ? `device-cmyk(${C}% ${M}% ${Y}% ${K}%)`
    : `device-cmyk(${C}% ${M}% ${Y}% ${K}% / ${A})`;
}
#+END_SRC

Now, I'm checking the math.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbToCMYK } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-rgb>>

console.log(colors.map((color) => ({input: color, output: rgbToCMYK(color)})));
#+END_SRC

#+NAME: rgb-to-cmyk
#+begin_src js
[
  { input: "rgb(0, 0, 0)", output: "device-cmyk(0% 0% 0% 100%)" },
  { input: "rgb(128, 128, 128)", output: "device-cmyk(0% 0% 0% 49.8%)" },
  { input: "rgb(255, 255, 255)", output: "device-cmyk(0% 0% 0% 0%)" },
  { input: "rgb(255, 0, 0)", output: "device-cmyk(0% 100% 100% 0%)" },
  { input: "rgb(255, 255, 0)", output: "device-cmyk(0% 0% 100% 0%)" },
  { input: "rgb(0, 255, 0)", output: "device-cmyk(100% 0% 100% 0%)" },
  { input: "rgb(0, 255, 255)", output: "device-cmyk(100% 0% 0% 0%)" },
  { input: "rgb(0, 0, 255)", output: "device-cmyk(100% 100% 0% 0%)" },
  { input: "rgb(255, 0, 255)", output: "device-cmyk(0% 100% 0% 0%)" },
  { input: "rgb(33, 199, 95)", output: "device-cmyk(83.42% 0% 52.27% 21.96%)" },
  { input: "rgb(19, 114, 220)", output: "device-cmyk(91.36% 48.17% 0% 13.73%)" },
  { input: "rgb(10%, 40.4%, 49.9%)", output: "device-cmyk(79.52% 18.9% 0% 50.2%)" },
  { input: "rgb(200 138 39)", output: "device-cmyk(0% 31% 80.5% 21.57%)" },
  {
    input: "rgb(31 88 49 / 0.8)",
    output: "device-cmyk(64.76% 0% 44.31% 65.49% / 0.8)"
  },
  {
    input: "rgba(110, 33, 110, 0.75)",
    output: "device-cmyk(0% 70% 0% 56.86% / 0.75)"
  },
  {
    input: "rgba(10, 119, 30, 30%)",
    output: "device-cmyk(91.6% 0% 74.8% 53.33% / 0.3)"
  }
]
#+end_src

Seems to check out, but I'm going to implement some visual tests soon.

****** Functional RGB to Functional HWB

The conversion of RGB to HWB is a little unorthodox. It's technically a /composite/ conversion. The
hue is first calculated via partial HSL conversion, and then the amount of white and black is
calculated via a [[https://www.w3.org/TR/css-color-4/#rgb-to-hwb][modified formula from the spec itself]].

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB to Functional HWB */
function rgbToHWB(color) {
  const [r, g, b, alpha] = parseRGB(color);
  const [R, G, B] = [r, g, b].map((channel) =>
    calcFractionFromChannel(channel)
  );

  const [H] = calcHSL(r, g, b);
  const [W, BLK] = [
    enforcePrecision(calcPercentFromFraction(Math.min(R, G, B))),
    enforcePrecision(calcPercentFromFraction(1 - Math.max(R, G, B))),
  ];
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `hwb(${H} ${W}% ${BLK}%)` : `hwb(${H} ${W}% ${BLK}% / ${A})`;
}
#+END_SRC

I'm suspicious of the math here, so let's see the proof.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbToHWB } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-rgb>>

console.log(colors.map((color) => ({input: color, output: rgbToHWB(color)})));
#+END_SRC

#+NAME: rgb-to-hwb
#+begin_src js
[
  { input: "rgb(0, 0, 0)", output: "hwb(0 0% 100%)" },
  { input: "rgb(128, 128, 128)", output: "hwb(0 50.2% 49.8%)" },
  { input: "rgb(255, 255, 255)", output: "hwb(0 100% 0%)" },
  { input: "rgb(255, 0, 0)", output: "hwb(0 0% 0%)" },
  { input: "rgb(255, 255, 0)", output: "hwb(60 0% 0%)" },
  { input: "rgb(0, 255, 0)", output: "hwb(120 0% 0%)" },
  { input: "rgb(0, 255, 255)", output: "hwb(180 0% 0%)" },
  { input: "rgb(0, 0, 255)", output: "hwb(240 0% 0%)" },
  { input: "rgb(255, 0, 255)", output: "hwb(300 0% 0%)" },
  { input: "rgb(33, 199, 95)", output: "hwb(142 12.94% 21.96%)" },
  { input: "rgb(19, 114, 220)", output: "hwb(212 7.451% 13.73%)" },
  { input: "rgb(10%, 40.4%, 49.9%)", output: "hwb(194 10.2% 50.2%)" },
  { input: "rgb(200 138 39)", output: "hwb(37 15.29% 21.57%)" },
  { input: "rgb(31 88 49 / 0.8)", output: "hwb(139 12.16% 65.49% / 0.8)" },
  { input: "rgba(110, 33, 110, 0.75)", output: "hwb(300 12.94% 56.86% / 0.75)" },
  { input: "rgba(10, 119, 30, 30%)", output: "hwb(131 3.922% 53.33% / 0.3)" }
]
#+end_src

I'll test this more , but the results are about what I'd expect.

****** Functional RGB to Functional CIELAB

CIEXYZ is a necessary waypoint on the road to CIELAB conversion indicating a set of general
coordinates based on the range of colors perceptible by the human eye.

Linear RGB is RGB with the gamma removed as that would throw off the calculation of CIEXYZ.

You can [[https://www.image-engineering.de/library/technotes/958-how-to-convert-between-srgb-and-ciexyz][read more about the actual formula]] if you're curious.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB >-< Linear RGB */
const removeGamma = (rgb) =>
  rgb.map((v) => {
    const V = calcFractionFromChannel(v);
    return V <= 0.04045 ? V / 12.92 : ((V + 0.055) / 1.055) ** 2.4;
  });
#+END_SRC

Now, to convert the ungamma-ed RGB to XYZ data, we have to pass it through a transformation matrix
of values representing the D65 reference white point defined in sRGB, which CSS uses.

After, I need to apply the [[http://www.brucelindbloom.com/Eqn_ChromAdapt.html][Bradford method of chromatic adaptation]] to convert the illuminant from
D65 to D50.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Linear RGB to CIE XYZ */
function calcXYZ(rgb) {
  const [R, G, B] = removeGamma(rgb);
  const [X, Y, Z] = [
    R * 0.4124564 + G * 0.3575761 + B * 0.1804375,
    R * 0.2126729 + G * 0.7151522 + B * 0.072175,
    R * 0.0193339 + G * 0.119192 + B * 0.9503041,
  ];

  /*
   * D50 matrix
   * =============================
   * 1.0478112  0.0228866 -0.0501270
   * 0.0295424  0.9904844 -0.0170491
   * -0.0092345  0.0150436  0.7521316
   * =============================
   */
  return [
    X * 1.0478112 + Y * 0.0228866 + Z * -0.050127,
    X * 0.0295424 + Y * 0.9904844 + Z * -0.0170491,
    X * -0.0092345 + Y * 0.0150436 + Z * 0.7521316,
  ];
}
#+END_SRC

And then I need to apply the actual [[http://www.brucelindbloom.com/index.html?Equations.html][conversion formula]].

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB to Functional CIELAB */
function rgbToCielab(color) {
  const [r, g, b, alpha] = parseRGB(color);
  const [x, y, z] = calcXYZ([r, g, b]);

  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const white = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Calculating XYZ scaled relative to white
  const [X, Y, Z] = [x, y, z].map((v, i) => v / white[i]);
  // Calculating F for each value
  const [FX, FY, FZ] = [X, Y, Z].map((V) =>
    V > ε ? Math.cbrt(V) : (κ * V + 16) / 116
  );

  // Calculating Lab values and limiting the precision
  const [L, aHue, bHue] = [
    enforcePrecision(116 * FY - 16),
    enforcePrecision(500 * (FX - FY)),
    enforcePrecision(200 * (FY - FZ)),
  ].map((V) => (Math.sign(Math.round(V)) === 0 ? 0 : V));
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1
    ? `lab(${L}% ${aHue} ${bHue})`
    : `lab(${L}% ${aHue} ${bHue} / ${A})`;
}
#+END_SRC

That was a lot, so I'm going to run my tests now.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbToCielab } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-rgb>>

console.log(colors.map((color) => ({input: color, output: rgbToCielab(color)})));
#+END_SRC

#+NAME: rgb-to-cielab
#+begin_src js
[
  { input: "rgb(0, 0, 0)", output: "lab(0% 0 0)" },
  { input: "rgb(128, 128, 128)", output: "lab(53.59% 0 0)" },
  { input: "rgb(255, 255, 255)", output: "lab(100% 0 0)" },
  { input: "rgb(255, 0, 0)", output: "lab(54.29% 80.81 69.89)" },
  { input: "rgb(255, 255, 0)", output: "lab(97.61% -15.75 93.39)" },
  { input: "rgb(0, 255, 0)", output: "lab(87.82% -79.29 80.99)" },
  { input: "rgb(0, 255, 255)", output: "lab(90.67% -50.67 -14.96)" },
  { input: "rgb(0, 0, 255)", output: "lab(29.57% 68.3 -112)" },
  { input: "rgb(255, 0, 255)", output: "lab(60.17% 93.55 -60.5)" },
  { input: "rgb(33, 199, 95)", output: "lab(70.85% -58.58 39.73)" },
  { input: "rgb(19, 114, 220)", output: "lab(47.69% 5.882 -62.48)" },
  { input: "rgb(10%, 40.4%, 49.9%)", output: "lab(39.98% -16.95 -20.4)" },
  { input: "rgb(200 138 39)", output: "lab(62.67% 18.46 58.58)" },
  { input: "rgb(31 88 49 / 0.8)", output: "lab(32.89% -26.87 16.88 / 0.8)" },
  { input: "rgba(110, 33, 110, 0.75)", output: "lab(28.13% 41.67 -27.61 / 0.75)" },
  { input: "rgba(10, 119, 30, 30%)", output: "lab(43.32% -42.99 38.13 / 0.3)" }
]
#+end_src

Awesome.

****** Functional RGB to Oklab (LCh)

[[https://bottoson.github.io/posts/oklab][Oklab]] is a perceptual color space for image processing created by Björn Ottosson. It has all the
advantages of CIELAB but fewer of its drawbacks in hue shifting (especially with blues).

This makes it excellent for adjusting color properties and blending colors.

I specifically use the formulas for converting Linear RGB to/from Oklab to convert to Oklab (LCh)
and ensure the output stays within the sRGB gamut.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function calcOklab(r, g, b) {
  const [R, G, B] = removeGamma([r, g, b]);

  // Convert to LMS cone activations and apply non-linearity
  const [L, M, S] = [
    R * 0.4122214708 + G * 0.5363325363 + B * 0.0514459929,
    R * 0.2119034982 + G * 0.6806995451 + B * 0.1073969566,
    R * 0.0883024619 + G * 0.2817188376 + B * 0.6299787005,
  ].map((V) => Math.cbrt(V));

  // Calculate Oklab values
  return [
    L * 0.2104542553 + M * 0.793617785 - S * 0.0040720468,
    L * 1.9779984951 - M * 2.428592205 + S * 0.4505937099,
    L * 0.0259040371 + M * 0.7827717662 - S * 0.808675766,
  ];
}

function rgbToOklab(color) {
  const [r, g, b, alpha] = parseRGB(color);
  const [l, aHue, bHue] = calcOklab(r, g, b);

  const L = `${enforcePrecision(calcPercentFromFraction(l))}%`;
  const c = enforcePrecision(Math.sqrt(aHue ** 2 + bHue ** 2));
  const h = enforcePrecision(Math.atan2(bHue, aHue) * (180 / Math.PI));

  const C = Math.sign(Math.round(c)) === 0 ? 0 : c; // Ensure negative values lock at 0
  const H = Math.sign(h) === -1 ? correctHueCounterClockwise(h) : h;

  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `oklab(${L} ${C} ${H})` : `oklab(${L} ${C} ${H} / ${A})`;
}
#+END_SRC

Now, I'll do some quick tests.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbToOklab } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-rgb>>

console.log(colors.map((color) => ({input: color, output: rgbToOklab(color)})));
#+END_SRC

#+NAME: rgb-to-oklab
#+begin_src js
[
  { input: "rgb(0, 0, 0)", output: "oklab(0% 0 0)" },
  { input: "rgb(128, 128, 128)", output: "oklab(59.99% 0 89.88)" },
  { input: "rgb(255, 255, 255)", output: "oklab(100% 0 89.88)" },
  { input: "rgb(255, 0, 0)", output: "oklab(62.8% 0 29.23)" },
  { input: "rgb(255, 255, 0)", output: "oklab(96.8% 0 109.8)" },
  { input: "rgb(0, 255, 0)", output: "oklab(86.64% 0 142.5)" },
  { input: "rgb(0, 255, 255)", output: "oklab(90.54% 0 194.8)" },
  { input: "rgb(0, 0, 255)", output: "oklab(45.2% 0 264.1)" },
  { input: "rgb(255, 0, 255)", output: "oklab(70.17% 0 328.4)" },
  { input: "rgb(33, 199, 95)", output: "oklab(72.8% 0 149.6)" },
  { input: "rgb(19, 114, 220)", output: "oklab(56.18% 0 255.9)" },
  { input: "rgb(10%, 40.4%, 49.9%)", output: "oklab(47.98% 0 223.7)" },
  { input: "rgb(200 138 39)", output: "oklab(67.96% 0 73.68)" },
  { input: "rgb(31 88 49 / 0.8)", output: "oklab(41.18% 0 151 / 0.8)" },
  { input: "rgba(110, 33, 110, 0.75)", output: "oklab(39.98% 0 327.9 / 0.75)" },
  { input: "rgba(10, 119, 30, 30%)", output: "oklab(49.59% 0 144.6 / 0.3)" }
]
#+end_src

***** Functional HSL Conversion

HSL is a polar coordinate translation of RGB so you can only derive an RGB color from it.

****** Functional RGB from Functional HSL

First, the extracted values require some prepping before calculations are predictable.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
import {
  calcChannelFromFraction,
  calcHueFromGrad,
  calcHueFromTurn,
  correctHueClockwise,
} from "./math.js";

// https://www.rapidtables.com/convert/color/hsl-to-rgb.html
const calcChannels = (C, X, H) =>
  new Map([
    [[C, X, 0], 0 <= H && H < 60],
    [[X, C, 0], 60 <= H && H < 120],
    [[0, C, X], 120 <= H && H < 180],
    [[0, X, C], 180 <= H && H < 240],
    [[X, 0, C], 240 <= H && H < 300],
    [[C, 0, X], 300 <= H && H < 360],
  ]);

function parseHSL(color) {
  const [h, s, l, alpha] = valueExtractor(color);

  const [H] = [h].map((value) => {
    const n = parseFloat(value);
    const isNegative = (n) => Math.sign(n) === -1;
    let hue;

    // Set hue based on unit
    if (value.endsWith("grad")) {
      hue = isNegative(n) ? calcHueFromGrad(n + 400) : calcHueFromGrad(n);
    } else if (value.endsWith("rad")) {
      hue = isNegative(n) ? calcHueFromRad(n + 6.28319) : calcHueFromRad(n);
    } else if (value.endsWith("turn")) {
      hue = isNegative(n) ? calcHueFromTurn(n + 1) : calcHueFromTurn(n);
    } else {
      hue = n;
    }

    // hue correction
    let degrees;
    if (hue >= 360) {
      degrees = correctHueClockwise(hue);
    } else if (isNegative(hue)) {
      degrees = correctHueClockwise(correctHueCounterClockwise(hue));
    } else {
      degrees = hue;
    }

    return degrees;
  });

  const [S, L] = [s, l].map((value) => {
    const n = parseFloat(value);
    return calcFractionFromPercent(n);
  });

  const a = parseFloat(alpha);
  const A = a != null ? (a > 1 ? calcFractionFromPercent(a) : a) : 1;

  return A === 1 ? [H, S, L] : [H, S, L, A];
}

function calcRGB(h, s, l) {
  // Calculate chroma
  const C = (1 - Math.abs(2 * l - 1)) * s;
  const X = C * (1 - Math.abs(((h / 60) % 2) - 1));
  const m = l - C / 2;

  // Evaluate channels
  const [R, G, B] = Array.from(calcChannels(C, X, h))
    .filter(([, condition]) => condition)
    .flatMap(([evaluation]) => evaluation)
    .map((channel) => Math.round(calcChannelFromFraction(channel + m)));

  return [R, G, B];
}
#+END_SRC

Phew. Now for the actual conversion function, it's an inversion.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB from Functional HSL */
function rgbFromHSL(color) {
  const [h, s, l, alpha] = parseHSL(color);
  const [R, G, B] = calcRGB(h, s, l);

  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

Now, the tests with my extracted HSL to verify that the math checks out.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbFromHSL } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-hsl>>

console.log(colors.map((color) => ({input: color, output: rgbFromHSL(color)})));
#+END_SRC

#+NAME: rgb-from-hsl
#+begin_src js
[
  { input: "hsl(0, 0%, 0%)", output: "rgb(0, 0, 0)" },
  { input: "hsl(0, 0%, 50%)", output: "rgb(128, 128, 128)" },
  { input: "hsl(0, 0%, 100%)", output: "rgb(255, 255, 255)" },
  { input: "hsl(0, 100%, 50%)", output: "rgb(255, 0, 0)" },
  { input: "hsl(60, 100%, 50%)", output: "rgb(255, 255, 0)" },
  { input: "hsl(120, 100%, 50%)", output: "rgb(0, 255, 0)" },
  { input: "hsl(180, 100%, 50%)", output: "rgb(0, 255, 255)" },
  { input: "hsl(240, 100%, 50%)", output: "rgb(0, 0, 255)" },
  { input: "hsl(300, 100%, 50%)", output: "rgb(255, 0, 255)" },
  { input: "hsl(38, 78%, 40%)", output: "rgb(182, 123, 22)" },
  { input: "hsl(3 88% 70%)", output: "rgb(246, 118, 111)" },
  { input: "hsl(189 63% 85% / 0.71)", output: "rgba(193, 234, 241, 0.71)" },
  { input: "hsla(1.5rad, 73%, 10%, 0.831)", output: "rgba(28, 44, 7, 0.831)" },
  { input: "hsl(320grad 89% 36% / 79%)", output: "rgba(141, 10, 174, 0.79)" },
  { input: "hsl(0.36turn 83% 90%)", output: "rgb(208, 251, 215)" }
]
#+end_src

***** Device CMYK Conversion

CMYK is like HSL in that it's another endpoint where the only way to continue a conversion chain is
to derive an RGB color from it.

****** Functional RGB from Device CMYK

First, I'm gonna enforce some uniformity in my values.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function parseCMYK(color) {
  const [c, m, y, k, alpha] = valueExtractor(color);
  const value = (s) => parseFloat(s);
  const [C, M, Y, K] = [c, m, y, k].map((component) =>
    component.endsWith("%")
      ? calcFractionFromPercent(value(component))
      : value(component)
  );

  const a = value(alpha);
  const A = a != null ? (a > 1 ? calcFractionFromPercent(a) : a) : 1;

  return A === 1 ? [C, M, Y, K] : [C, M, Y, K, A];
}
#+END_SRC

For the conversion algorithm, it's RapidTables coming again with the assist.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB from Device CMYK */
function rgbFromCMYK(color) {
  const [C, M, Y, K, alpha] = parseCMYK(color);

  const [R, G, B] = [C, M, Y].map((component) =>
    Math.round(calcChannelFromFraction((1 - component) * (1 - K)))
  );
  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

Time to see if the math stacks up.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbFromCMYK } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-cmyk>>

console.log(colors.map((color) => ({input: color, output: rgbFromCMYK(color)})));
#+END_SRC

#+NAME: rgb-from-cmyk
#+begin_src js
[
  { input: "device-cmyk(0% 0% 0% 100%)", output: "rgb(0, 0, 0)" },
  { input: "device-cmyk(0% 0% 0% 50%)", output: "rgb(128, 128, 128)" },
  { input: "device-cmyk(0% 0% 0% 0%)", output: "rgb(255, 255, 255)" },
  { input: "device-cmyk(0% 100% 100% 0%)", output: "rgb(255, 0, 0)" },
  { input: "device-cmyk(0% 0% 100% 0%)", output: "rgb(255, 255, 0)" },
  { input: "device-cmyk(100% 0% 100% 0%)", output: "rgb(0, 255, 0)" },
  { input: "device-cmyk(100% 0% 0% 0%)", output: "rgb(0, 255, 255)" },
  { input: "device-cmyk(100% 100% 0% 0%)", output: "rgb(0, 0, 255)" },
  { input: "device-cmyk(0% 100% 0% 0%)", output: "rgb(255, 0, 255)" },
  { input: "device-cmyk(37% 63% 0 0)", output: "rgb(161, 94, 255)" },
  { input: "device-cmyk(50% 25% 10% 0)", output: "rgb(128, 191, 230)" },
  { input: "device-cmyk(0.77 0.33 0 0)", output: "rgb(59, 171, 255)" },
  { input: "device-cmyk(0.8 0 0.4 0.13 / 0.8)", output: "rgba(44, 222, 133, 0.8)" },
  {
    input: "device-cmyk(25% 75% 8% 3% / 81.3%)",
    output: "rgba(186, 62, 228, 0.813)"
  }
]
#+end_src

***** Functional HWB Conversion

HWB is another polar coordinate translation in the RGB space meaning that the only way forward is back.

****** Functional RGB from Functional HWB

As with the progressive conversion, the regressive conversion is a composite. It first splits the
hue with a call to =calcRGB()= from the HSL conversion module, setting the saturation and lightness to
return a pure hue, then modifies the result with the given amount of white and black.

Again, the implementation uses [[https://www.w3.org/TR/css-color-4/#hwb-to-rgb][a formula ripped straight from the spec]] with some modifications.

First, ensuring uniform output:

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function parseHWB(color) {
  const [h, w, blk, alpha] = valueExtractor(color);
  const [H] = parseHSL(`hsl(${h}, 50%, 50%)`); // free hue correction
  const [W, BLK] = [w, blk].map((component) =>
    calcFractionFromPercent(parseFloat(component))
  );

  const a = parseFloat(alpha);
  const A = a != null ? (a > 1 ? calcFractionFromPercent(a) : a) : 1;

  return A === 1 ? [H, W, BLK] : [H, W, BLK, A];
}
#+END_SRC

And now for the conversion algorithm.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional RGB from Functional HWB */
function rgbFromHWB(color) {
  const [h, w, blk, alpha] = parseHWB(color);
  const [r, g, b] = calcRGB(h, 1, 0.5);

  const A = (alpha && (alpha ?? 1)) || 1;

  // Achromatic
  if (w + blk >= 1) {
    const GRAY = Math.round(calcChannelFromFraction(w / (w + blk)));
    return A === 1
      ? `rgb(${GRAY}, ${GRAY}, ${GRAY})`
      : `rgba(${GRAY}, ${GRAY}, ${GRAY}, ${A})`;
  }

  const [R, G, B] = [r, g, b].map((channel) =>
    Math.round(
      calcChannelFromFraction(
        calcFractionFromChannel(channel) * (1 - w - blk) + w,
      ),
    )
  );

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

Now the fun part: seeing if anything breaks.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbFromHWB } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-hwb>>

console.log(colors.map((color) => ({input: color, output: rgbFromHWB(color)})));
#+END_SRC

#+NAME: rgb-from-hwb
#+begin_src js
[
  { input: "hwb(0 0% 100%)", output: "rgb(0, 0, 0)" },
  { input: "hwb(0 100% 100%)", output: "rgb(128, 128, 128)" },
  { input: "hwb(0 100% 0%)", output: "rgb(255, 255, 255)" },
  { input: "hwb(0 0% 0%)", output: "rgb(255, 0, 0)" },
  { input: "hwb(60 0% 0%)", output: "rgb(255, 255, 0)" },
  { input: "hwb(120 0% 0%)", output: "rgb(0, 255, 0)" },
  { input: "hwb(180 0% 0%)", output: "rgb(0, 255, 255)" },
  { input: "hwb(240 0% 0%)", output: "rgb(0, 0, 255)" },
  { input: "hwb(300 0% 0%)", output: "rgb(255, 0, 255)" },
  { input: "hwb(188 20% 3%)", output: "rgb(51, 221, 247)" },
  { input: "hwb(3.1rad 50% 0%)", output: "rgb(128, 255, 250)" },
  { input: "hwb(183grad 5% 15% / 0.5)", output: "rgba(13, 217, 165, 0.5)" },
  { input: "hwb(0.8turn 38% 99%)", output: "rgb(71, 71, 71)" }
]
#+end_src

Looks like we're golden.

***** Functional CIELAB Conversion

CIELAB is a fork in the road: you can convert to its polar coordinate CIELCh(ab) or derive an RGB
color from it.

****** Functional RGB from Functional CIELAB

The [[http://www.brucelindbloom.com/index.html?Equations.html][formula for regressing CIELAB to CIE XYZ]] is cleanly outlined. So, I'll follow that.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function calcXYZLab(l, a, b) {
  const [L, A, B] = [l, a, b].map((v) => parseFloat(v));

  // CIE standards
  const ε = 216 / 24389;
  const κ = 24389 / 27;
  const white = [0.96422, 1.0, 0.82521]; // D50 reference white

  // Compute the values of F
  const Fy = (L + 16) / 116;
  const Fx = A / 500 + Fy;
  const Fz = Fy - B / 200;

  // Calculate xyz
  const [x, y, z] = [
    Fx ** 3 > ε ? Fx ** 3 : (116 * Fx - 16) / κ,
    L > κ * ε ? Fy ** 3 : L / κ,
    Fz ** 3 > ε ? Fz ** 3 : (116 * Fz - 16) / κ,
  ];

  return [x, y, z].map((V, i) => V * white[i]);
}
#+END_SRC

The next step is converting the D50 XYZ to sRGB native D65 XYZ via chromatic adaptation.

And /then/ passing it through the inverse transformation matrix to get linear RGB.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function calcLinearRGB(l, a, b) {
  const [x, y, z] = calcXYZLab(l, a, b);

  /**
   * D65 transformation matrix
   * =============================
   * 0.9555766 -0.0230393  0.0631636
   * -0.0282895  1.0099416  0.0210077
   * 0.0122982 -0.0204830  1.3299098
   * =============================
   */
  const [X, Y, Z] = [
    x * 0.9555766 + y * -0.0230393 + z * 0.0631636,
    x * -0.0282895 + y * 1.0099416 + z * 0.0210077,
    x * 0.0122982 + y * -0.020483 + z * 1.3299098,
  ];

  /**
   * linear sRGB transformation matrix (inverse)
   * =============================
   *  3.2404542 -1.5371385 -0.4985314
   * -0.9692660  1.8760108  0.0415560
   *  0.0556434 -0.2040259  1.0572252
   * =============================
   */
  return [
    X * 3.2404542 + Y * -1.5371385 + Z * -0.4985314,
    X * -0.969266 + Y * 1.8760108 + Z * 0.041556,
    X * 0.0556434 + Y * -0.2040259 + Z * 1.0572252,
  ];
}
#+END_SRC

Gamma application is the finishing touch before converting the channel values to the expected =0-255=
range.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
const applyGamma = (lrgb) =>
  lrgb.map((V) => V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055);

/** Functional CIELAB from Functional RGB */
export function rgbFromCielab(color) {
  const [l, aHue, bHue, alpha] = valueExtractor(color);
  const [r, g, b] = calcLinearRGB(l, aHue, bHue);

  const [R, G, B] = applyGamma([r, g, b]).map((channel) =>
    Math.round(normalize(0, calcChannelFromFraction(channel), 255))
  );
  const A = (alpha &&
    (alpha.endsWith("%")
      ? calcFractionFromPercent(parseFloat(alpha))
      : alpha)) ||
    1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

That was a lot to parse. Time to see if the calculations check out.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbFromCielab } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-cielab>>

console.log(colors.map((color) => ({input: color, output: rgbFromCielab(color)})));
#+END_SRC

#+RESULTS:
#+begin_src js
[
  { input: "lab(0% 0 0)", output: "rgb(0, 0, 0)" },
  { input: "lab(53.59% 0 0)", output: "rgb(128, 128, 128)" },
  { input: "lab(100% 0 0)", output: "rgb(255, 255, 255)" },
  { input: "lab(54.29% 80.81 69.89)", output: "rgb(255, 0, 0)" },
  { input: "lab(97.6% -15.75 93.39)", output: "rgb(255, 255, 0)" },
  { input: "lab(87.82% -79.29 80.99)", output: "rgb(0, 255, 0)" },
  { input: "lab(90.67% -50.67 -14.96)", output: "rgb(0, 255, 255)" },
  { input: "lab(29.57% 68.3 -112.03)", output: "rgb(0, 0, 255)" },
  { input: "lab(60.17% 93.55 -60.5)", output: "rgb(255, 0, 255)" },
  { input: "lab(49.18% 38.1 -110.33)", output: "rgb(0, 102, 255)" },
  { input: "lab(91.3% -93 14)", output: "rgb(0, 255, 199)" },
  { input: "lab(83.119% 49.34 -3.99 / 0.75)", output: "rgba(255, 169, 217, 0.75)" },
  { input: "lab(199% 38 13 / 78%)", output: "rgba(255, 255, 255, 0.78)" }
]
#+end_src

I'll stamp this as Good Enough™.

****** Functional CIELAB to Functional CIELCh(ab)

The final bridge is a progressive conversion of CIELAB to CIELCh(ab). With this, all known and proposed
CSS color formats are supported by the Quarks System Core.

And thankfully, [[http://www.brucelindbloom.com/Eqn_Lab_to_LCH.html][the formula]] is a dead simple conversion of rectangle coordinates to polar coordinates.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional CIELAB to Functional CIELCh(ab) */
function cielabToCielch(color) {
  const [L, a, b, alpha] = valueExtractor(color);
  const [C, h] = [
    enforcePrecision(Math.sqrt(parseFloat(a) ** 2 + parseFloat(b) ** 2)),
    enforcePrecision(
      Math.atan2(parseFloat(b), parseFloat(a)) * (180 / Math.PI),
    ),
  ];

  const H = Math.sign(h) === -1 ? h + 360 : h;

  const A = (alpha &&
    (alpha.endsWith("%")
      ? calcFractionFromPercent(parseFloat(alpha))
      : alpha)) ||
    1;

  return A === 1 ? `lch(${L} ${C} ${H})` : `lch(${L} ${C} ${H} / ${A})`;
}
#+END_SRC

Now to make sure it returns what I expect.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { cielabToCielch } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-cielab>>

console.log(colors.map((color) => ({input: color, output: cielabToCielch(color)})));
#+END_SRC

#+NAME: cielab-to-cielch
#+begin_src js
[
  { input: "lab(0% 0 0)", output: "lch(0% 0 0)" },
  { input: "lab(53.59% 0 0)", output: "lch(53.59% 0 0)" },
  { input: "lab(100% 0 0)", output: "lch(100% 0 0)" },
  { input: "lab(54.29% 80.81 69.89)", output: "lch(54.29% 106.8 40.86)" },
  { input: "lab(97.6% -15.75 93.39)", output: "lch(97.6% 94.71 99.57)" },
  { input: "lab(87.82% -79.29 80.99)", output: "lch(87.82% 113.3 134.4)" },
  { input: "lab(90.67% -50.67 -14.96)", output: "lch(90.67% 52.83 196.4)" },
  { input: "lab(29.57% 68.3 -112.03)", output: "lch(29.57% 131.2 301.37)" },
  { input: "lab(60.17% 93.55 -60.5)", output: "lch(60.17% 111.4 327.11)" },
  { input: "lab(49.18% 38.1 -110.33)", output: "lch(49.18% 116.7 289.05)" },
  { input: "lab(91.3% -93 14)", output: "lch(91.3% 94.05 171.4)" },
  {
    input: "lab(83.119% 49.34 -3.99 / 0.75)",
    output: "lch(83.119% 49.5 355.377 / 0.75)"
  },
  { input: "lab(199% 38 13 / 78%)", output: "lch(199% 40.16 18.89 / 0.78)" }
]
#+end_src

That'll do it.

***** Functional CIELCh Conversion

This final conversion ends the chain and allows any supported format to convert to and from any
other supported format.

****** Functional CIELAB from Functional CIELCh(ab)

It's necessary for the hue component of CIELCh(ab) to use the same possible hue inputs as HSL, because
that's what's allowed in the spec.

The [[http://www.brucelindbloom.com/Eqn_LCH_to_Lab.html][conversion algorithm itself]] is short and sweet.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
/** Functional CIELAB from Functional CIELCh(ab) */
function cielabFromCielch(color) {
  const [L, c, h, alpha] = valueExtractor(color);
  const C = parseFloat(c);
  const [H] = parseHSL(`hsl(${h}, 50%, 50%)`);

  const [a, b] = [
    enforcePrecision(C * Math.cos(H * (Math.PI / 180))),
    enforcePrecision(C * Math.sin(H * (Math.PI / 180))),
  ];

  const A = (alpha &&
    (alpha.endsWith("%")
      ? calcFractionFromPercent(parseFloat(alpha))
      : alpha)) ||
    1;

  return A === 1 ? `lab(${L} ${a} ${b})` : `lab(${L} ${a} ${b} / ${A})`;
}
#+END_SRC

Alright, time to test the CIELCh(ab) color table.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { cielabFromCielch } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-cielch>>

console.log(colors.map((color) => ({input: color, output: cielabFromCielch(color)})));
#+END_SRC

#+NAME: cielab-from-cielch
#+begin_src js
[
  { input: "lch(0% 0 0)", output: "lab(0% 0 0)" },
  { input: "lch(53.59% 0 0)", output: "lab(53.59% 0 0)" },
  { input: "lch(100% 0 0)", output: "lab(100% 0 0)" },
  { input: "lch(54.29% 106.84 40.855)", output: "lab(54.29% 80.81 69.89)" },
  { input: "lch(97.6% 94.709 99.573)", output: "lab(97.6% -15.75 93.39)" },
  { input: "lch(87.82% 113.34 134.39)", output: "lab(87.82% -79.29 80.99)" },
  { input: "lch(90.67% 52.832 196.45)", output: "lab(90.67% -50.67 -14.96)" },
  { input: "lch(29.57% 131.21 301.369)", output: "lab(29.57% 68.3 -112)" },
  { input: "lch(60.17% 111.41 327.109)", output: "lab(60.17% 93.55 -60.5)" },
  { input: "lch(53.31% 89.31 200)", output: "lab(53.31% -83.92 -30.55)" },
  {
    input: "lch(89.1% 167.34 3.6rad / 0.99)",
    output: "lab(89.1% -150 -74.14 / 0.99)"
  },
  { input: "lch(24.494% 74.9 193grad)", output: "lab(24.494% -74.45 8.219)" },
  {
    input: "lch(47.39% 111.193 0.62turn / 75%)",
    output: "lab(47.39% -81.06 -76.12 / 0.75)"
  }
]
#+end_src

And that's it for color conversion with standard formats.

***** Oklab (LCh) Conversion

Now I need to allow for a regressive conversion of Oklab (LCh) back to sRGB. This creates a bridge
back to standard supported formats and closes the loop.

First, I'll need to convert Oklab (LCh) values back to raw Oklab values.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function parseOklab(color) {
  const [l, c, h, alpha] = valueExtractor(color);

  // Convert values back to their raw Oklab form
  const L = calcFractionFromPercent(parseFloat(l));
  const C = c;
  const [hue] = parseHSL(`hsl(${h}, 50%, 50%)`);
  const H = 2 * Math.PI * (hue / 360); // degrees to radians

  // Calculate a, b
  const [a, b] = [C * Math.cos(H), C * Math.sin(H)];

  return [L, a, b, alpha];
}
#+END_SRC

Having done that, I can now use the conversion formula to convert to linear sRGB.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function calcLinearRGBOklab(l, a, b) {
  // Calculate LMS cone activations
  const [L, M, S] = [
    l + a * 0.3963377774 + b * 0.2158037573,
    l - a * 0.1055613458 - b * 0.0638541728,
    l - a * 0.0894841775 - b * 1.291485548,
  ].map((V) => V ** 3);

  // Calculate linear RGB
  return [
    L * 4.076416621 - M * 3.3077115913 + S * 0.2309699292,
    L * -1.2684380046 + M * 2.6097574011 - S * 0.3413193965,
    L * -0.0041960863 - M * 0.7034186147 + S * 1.707614701,
  ];
}
#+END_SRC

Next, I apply the gamma, normalize the channels, and return the color.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
function rgbFromOklab(color) {
  const [l, aHue, bHue, alpha] = parseOklab(color);
  const [r, g, b] = calcLinearRGBOklab(l, aHue, bHue);

  const [R, G, B] = [r, g, b]
    .map((V) => (V <= 0.0031308 ? 12.92 * V : 1.055 * V ** (1 / 2.4) - 0.055))
    .map((V) => Math.round(normalize(0, calcChannelFromFraction(V), 255)));

  const A = (alpha && (alpha ?? 1)) || 1;

  return A === 1 ? `rgb(${R}, ${G}, ${B})` : `rgba(${R}, ${G}, ${B}, ${A})`;
}
#+END_SRC

That was a straightforward process, but I'm going to check that it works.

#+BEGIN_SRC js :results output code replace :allow read :noweb yes
const { rgbFromOklab } = await import(`${Deno.cwd()}/internals/color/conversions.js`);

<<valid-oklab>>

console.log(colors.map((color) => ({input: color, output: rgbFromOklab(color)})));
#+END_SRC

#+NAME: rgb-from-oklab
#+begin_src js
[
  { input: "oklab(0% 0 0)", output: "rgb(0, 0, 0)" },
  { input: "oklab(59.987% 0 0)", output: "rgb(128, 128, 128)" },
  { input: "oklab(100% 0 0)", output: "rgb(255, 255, 255)" },
  { input: "oklab(62.795% 0.25768 29.234)", output: "rgb(255, 0, 0)" },
  { input: "oklab(96.768% 0.21101 109.77)", output: "rgb(255, 255, 0)" },
  { input: "oklab(86.644% 0.29483 142.5)", output: "rgb(0, 255, 0)" },
  { input: "oklab(90.54% 0.15455 194.77)", output: "rgb(0, 255, 255)" },
  { input: "oklab(45.201% 0.31321 264.052)", output: "rgb(0, 0, 255)" },
  { input: "oklab(70.167% 0.32249 328.363)", output: "rgb(255, 0, 255)" },
  { input: "oklab(37.119% 0.482 90)", output: "rgb(150, 0, 0)" },
  { input: "oklab(29.11% 0.25 180)", output: "rgb(0, 72, 48)" },
  { input: "oklab(53.33% 0.5 270)", output: "rgb(87, 0, 255)" },
  { input: "oklab(84% 0.1043 350.31)", output: "rgb(255, 175, 212)" },
  { input: "oklab(25.14% 0.44 60 / 0.8)", output: "rgba(142, 0, 0, 0.8)" }
]
#+end_src

And that completes the implementation for each format.

***** Batch Conversion

Same as with validation, I'll wrap these in a default export for use in the improved public API.

#+BEGIN_SRC js :tangle "./internals/color/conversions.js" :comments link
export default {
  hexToRGB,
  hexFromRGB,
  hexFromNamed,
  rgbToHSL,
  rgbFromHSL,
  rgbToCMYK,
  rgbFromCMYK,
  rgbToHWB,
  rgbFromHWB,
  rgbToCielab,
  rgbFromCielab,
  rgbToOklab,
  rgbFromOklab,
  cielabToCielch,
  cielabFromCielch,
};
#+END_SRC

**** Math (=internals/color/math.js=)

As I wrote earlier, I consider hex colors on the web color primitives. They're the starting point
of all conversions because hex colors can only be directly converted to functional RGB which begins
the conversion chain to other formats.

#+BEGIN_SRC js :tangle "./internals/color/math.js" :comments link
/** Helper for converting hextoint */
export const hexFragmentToChannel = (fragment) => parseInt(fragment, 16);

/** Helper for converting inttohex */
export const channelToHexFragment = (channel) =>
  channel.toString(16).padStart(2, "0");
#+END_SRC

Before I write the functions for actual conversion, I need to write some basic arithmetic helpers.

#+BEGIN_SRC js :tangle "./internals/color/math.js" :comments link
const significant = (digits, value) => +value.toPrecision(digits);

/** Helper to set a universal precision */
export const enforcePrecision = significant.bind(null, 4);

/** x + y */
const sum = (y, x) => enforcePrecision(x + y);

/** x ✕ y */
const product = (y, x) => enforcePrecision(x * y);

/** x ÷ y */
const quotient = (y, x) => enforcePrecision(x / y);

/** x % y */
const remainder = (y, x) => enforcePrecision(x % y);

// Hrad, Hgrad, Hturn to hue

/** Formula: n° = n㎭ ✕ 180∕π */
export const calcHueFromRad = (radians) =>
  product(quotient(Math.PI, 180), radians);

/** Formula: n° = nᵍ✕ 180∕200 */
export const calcHueFromGrad = (gradians) =>
  product(quotient(200, 180), gradians);

/** Formula: n° = n% ✕ 360 */
export const calcHueFromTurn = (turn) => product(360, turn);

// Hue correction

/** Formula: n° = -n + 360 */
export const correctHueCounterClockwise = (hue) => sum(360, hue);

/** Formula: n° = n % 360 */
export const correctHueClockwise = (hue) => remainder(360, hue);

// Saturation, lightness

/** Formula: n = n%∕100 */
export const calcFractionFromPercent = (percentage) =>
  quotient(100, percentage);

/** Formula: n = n ✕ 100 */
export const calcPercentFromFraction = (fraction) => product(100, fraction);

// RGB calculations

/** Formula: n = n ✕ 255 */
export const calcChannelFromFraction = (fraction) => product(255, fraction);

/** Formula: n = n∕255 */
export const calcFractionFromChannel = (channel) => quotient(255, channel);

/** Formula: n = n%∕100 ✕ 255 */
export const calcChannelFromPercent = (percentage) =>
  Math.round(calcChannelFromFraction(calcFractionFromPercent(percentage)));

/** Normalization to define boundaries */
export const normalize = (a, x, b) =>
  enforcePrecision(Math.min(Math.max(x, a), b));

// Alpha

/** Helper to convert alpha value to hex fragment */
export const calcHexFragmentFromAlpha = (alpha) =>
  channelToHexFragment(Math.round(calcChannelFromFraction(alpha)));
#+END_SRC

** Data

This section documents lookup tables and other hardcoded bits of data used by the core modules.

*** Color

**** W3C X11 Color Definitions (=data/color/w3c-x11.js=)

This is a lookup table for [[http://www.w3.org/TR/css3-color/#svg-color][all named CSS colors]] as of the CSS4 module updates.

#+BEGIN_SRC js :tangle "./data/color/w3c-x11.js" :comments link
/** X11 color names: https://www.w3.org/TR/css3-color/#svg-color */
export const X11Colors = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
#+END_SRC

**** Accesible Web Defaults (=data/color/a11y.js=)

This is a lookup table for [[http://clrs.cc][better web defaults]] optimized for accessibility.

#+BEGIN_SRC js :tangle "./data/color/a11y.js" :comments link
/** Better web default colors: http://clrs.cc */
export const A11yColors = {
  navy: "#001f3f",
  blue: "#0074d9",
  aqua: "#7fdbff",
  teal: "#39cccc",
  olive: "#3d9970",
  green: "#2ecc40",
  lime: "#01ff70",
  yellow: "#ffdc00",
  orange: "#ff851b",
  red: "#ff4136",
  maroon: "#85144b",
  fuchsia: "#f012be",
  purple: "#b10dc9",
  black: "#111111",
  gray: "#aaaaaa",
  grey: "#aaaaaa",
  silver: "#dddddd",
  white: "#ffffff",
};
#+END_SRC

*** Typography

**** System Font Stacks (=data/typography/system.js=)

This is a lookup table for [[https://systemfontstack.com][system font stacks]] for use by themselves or attached to the end of a font
stack to provide better fallbacks than =sans-serif=, =serif=, or =monospace=.

#+BEGIN_SRC js :tangle "./data/typography/system.js" :comments link
/** System font stacks: https://systemfontstack.com */
export const SystemFontStacks = {
  "sans-serif":
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  serif:
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  monospace:
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
};
#+END_SRC
