#+TITLE: Quarks System Core (QSC)
#+AUTHOR: Chatman R. Jr
#+DATE: <2021-02-18 Thu>
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:deno :results output none
#+PROPERTY: header-args:shell :results output code

* Intro :noexport:

This repository is part of a of toolkit for creating, assembling, and distributing design
systems. The whole kit lives under the umbrella of the QuarkSuite name.

Other appendages of QuarkSuite include:

+ Quarks System Language (QSL): A domain-specific language for codifying design language into design systems
+ Quarks System User Interface (QSUI): A UI kit for design system documentation and visual development
+ Quarks System Development Environment (QSDE): A complete development environment integrating all
  of the above and some extras

If you're interested in how this project evolved, feel free to browse the repository for QuarkSuite 1.

* Summary :noexport:

The Quarks System Core is the oldest and most mature part of QuarkSuite. It's been refined from
QuarkSuite 1 to serve as an engine powering the rest of the kit.

That said, it can still be used as a standalone library if your needs are simple, you require
absolute control, or you want to develop your own design system workflow with a QSC foundation.

* Installation :noexport:
* Features :noexport:
* Source Code Index                                                   :TOC@4:
- [[#api][API]]
  - [[#how-to-read-the-api][How to Read the API]]
  - [[#utilities-srcutilitiesindexjs][Utilities (=src/utilities/index.js=)]]
    - [[#compose-srcutilitiescomposejs][compose (=src/utilities/compose.js=)]]
    - [[#pipe-srcutilitiespipejs][pipe (=src/utilities/pipe.js=)]]
    - [[#bind-srcutilitiesbindjs][bind (=src/utilities/bind.js=)]]
    - [[#tests][Tests]]
      - [[#assertions][assertions]]
      - [[#results][results]]
    - [[#scenarios][Scenarios]]
- [[#internals][Internals]]
  - [[#error-handling-srcinternalserrorjs][Error Handling (=src/internals/error.js=)]]
  - [[#color][Color]]
    - [[#formats-srcinternalscolorformatindexjs][Formats (=src/internals/color/format/index.js=)]]
      - [[#rgb-hex-srcinternalscolorformathexjs][RGB Hex (=src/internals/color/format/hex.js=)]]
      - [[#w3c-x11-srcinternalscolorformatnamedjs][W3C-X11 (=src/internals/color/format/named.js=)]]
      - [[#functional-rgb-srcinternalscolorformatrgbjs][Functional RGB (=src/internals/color/format/rgb.js=)]]
      - [[#functional-hsl-srcinternalscolorformathsljs][Functional HSL (=src/internals/color/format/hsl.js=)]]
      - [[#device-cmyk-srcinternalscolorformatdevice-cmykjs][Device CMYK (=src/internals/color/format/device-cmyk.js=)]]
      - [[#functional-hwb-srcinternalscolorformathwbjs][Functional HWB (=src/internals/color/format/hwb.js=)]]
      - [[#functional-cielab-srcinternalscolorformatlabjs][Functional CIELAB (=src/internals/color/format/lab.js=)]]
      - [[#functional-lch-srcinternalscolorformatlchjs][Functional LCH (=src/internals/color/format/lch.js=)]]
    - [[#conversion][Conversion]]
- [[#data][Data]]
  - [[#color-1][Color]]
    - [[#w3c-x11-color-definitions-srcdatacolorw3c-x11js][W3C X11 Color Definitions (=src/data/color/w3c-x11.js=)]]
    - [[#accesible-web-defaults-srcdatacolora11yjs][Accesible Web Defaults (=src/data/color/a11y.js=)]]
  - [[#typography][Typography]]
    - [[#system-font-stacks-srcdatatypographysystemjs][System Font Stacks (=src/data/typography/system.js=)]]

* API

The API is organized by the kind of data each function accepts.

This means you can jump right to the section for what you need to do. The literate style isn't for
everyone, so headings are appropriately marked with their source location in the repo if you prefer
to get right into code.

** How to Read the API

Each section is broken down into:

+ functions: the actual function definitions with developer commentary
+ Tests: proving each function does its job and doesn't choke on the unexpected
+ Scenarios: demonstrating use and applicable design patterns

** Utilities (=src/utilities/index.js=)

#+BEGIN_SRC deno :tangle "./src/utilities/index.js" :comments link
/** Functional Utilities */
export * from "./compose.js";
export * from "./pipe.js";
export * from "./bind.js";
#+END_SRC

The Quarks System Core rests on a functional foundation. It uses a data-last architecture and the following
utilities are designed to take full advantage of this decision.

*** compose (=src/utilities/compose.js=)

+ =compose: (...operators) => (data) => unknown=
+ =operators: Array<(data: unknown) => unknown>=: a sequence of data operators

#+BEGIN_SRC deno :tangle "./src/utilities/compose.js" :comments link
import { ErrorTemplate } from "../internals/error.js";

// Error handling
const isFunction = (x) => typeof x === "function";
const hasArity1 = (x) => x.length === 1;

/** Error thrown when value is not a function. */
const FuncError = (output) =>
  ErrorTemplate({
    message: "not a function",
    reason: `
This error indicates that one or more of the values is not a
function, so it can't be composed.
`,
    suggestion: `
Check that every value in your composition chain is a function.
`,
    output,
  });

/** Error thrown when function has a modifier or arity > 1 */
const ArityError = (output) =>
  ErrorTemplate({
    message: "not a data operator",
    reason: `
This error indicates that one or more of the functions is
not a data operator. That is, not a single argument function.
`,
    suggestion: `
Check that every function in your composition chain has an arity of 1.
Ex: (data: any) => any
`,
    output,
  });

/**
 * A higher order function that accepts a sequence of data operators and combines them
 * into a new function waiting for data.
 *
 * ```ts
 *  const upper = (data) => data.toUpperCase();
 *  const split = (data) => data.split("");
 *
 *  const splitCapitalLetters = compose(upper, split);
 *
 *  splitCapitalLetters("hello"); // ["H", "E", "L", "L", "O"]
 * ```
 *
 * @remark
 * A data operator is also called a unary function. These are both ways of saying a function
 * takes a single argument.
 *
 * @param {((data: unknown) => unknown)[]} operators - a sequence of functions to combine
 * @returns {(data: unknown) => unknown} the composed function waiting for data  */
export function compose(...operators) {
  return (data) =>
    operators.reduce((value, func) => {
      if (!isFunction(func)) return FuncError(func);
      if (!hasArity1(func)) return ArityError(func);
      return func(value);
    }, data);
}
#+END_SRC

Two conditions must be met for compose to work:

+ all operators must be functions
+ all operations must have a signature of =(data: unknown) => unknown=

*** pipe (=src/utilities/pipe.js=)

+ =(data, ...operators) => unknown=
+ =data: unknown=: the data to pass through the pipeline
+ =...operators: Array<(data: unknown) => unknown>=: a sequence of data operators

#+BEGIN_SRC deno :tangle "./src/utilities/pipe.js" :comments link
import { compose } from "./compose.js";

/**
 * A higher order function that pipes data through a sequence of functions and
 * outputs the result.
 *
 * ```ts
 * const upper = (data) => data.toUpperCase();
 * const split = (data) => data.split("");
 *
 * pipe("hello", upper, split); // ["H", "E", "L", "L", "O"]
 * ```
 *
 * @remarks
 * This function simply inverts `compose` so that the data is immediately transformed
 * instead of combining the functions.
 *
 * @param {unknown} data - the data to pass through the pipeline
 * @param {((data: unknown) => unknown)[]} operators - the sequence of functions to transform data
 * @returns {unknown} The transformed data
 */
export function pipe(data, ...operators) {
  return compose(...operators)(data);
}
#+END_SRC

=pipe= inverts the relationship between data and its operators. This is crucial: data pipelines,
because of the way they're defined can /themselves/ be bound. Data, rather than being the remaining
argument, becomes the /initial/ argument and its operators can be applied freely after.

As you can see, it's a reimplementation of =compose= but with the data as the initial argument and
immediately executes on call.

*** bind (=src/utilities/bind.js=)

+ =(func, ...initial) => (...remaining) => unknown=
+ =func: (...args: unknown) => unknown=: the function to initialize
+ =initial: unknown[]=: the initial arguments to bind

#+BEGIN_SRC deno :tangle "./src/utilities/bind.js" :comments link
/**
 * A higher order function that accepts a function and some of its arguments;
 * returning a function waiting for the rest of its arguments.
 *
 * ```ts
 * const add = (y, x) => x + y;
 * const add8 = bind(add, 8);
 *
 * add8(2) // 10
 * ```
 *
 * @remarks
 * `bind` is essential for converting complex utilities into preset data
 * operators which can then be `compose`d and `pipe`d.
 *
 * Additionally, you can chain bind to approximate a full curry of a function:
 * `(z, y, x) => unknown` to `(z) => (y) => (x) => unknown`
 *
 * @param {(...args: unknown[]) => unknown} func - a variadic function to initialize
 * @param {unknown[]} initial - the arguments to apply
 * @returns {((...remaining: unknown) => unknown) | unknown} A function waiing for remaining arguments or the result of calling the function if `initial = total arguments`  */
export function bind(func, ...initial) {
  return func.length === initial.length
    ? func(...initial)
    : (...remaining) => func(...initial, ...remaining);
}
#+END_SRC

Composition and data piping work out of the box for simple unary functions, but what about
functions with more than one argument?

In a data-last architecture, the final argument of a function is /always/ its data.

Any preceding arguments are *data modifiers*.

Using the =bind= utility, a function with a signature of =(z, y, x) => any= will break down to: =(z,
y) => (x) => any= or =(z) => (y) => (x) => any=.

The remaining data operation satisfies the =parity = 1= clause for composition.

*** Tests

**** assertions

#+BEGIN_SRC deno :tangle "./src/utilities/index_test.js" :comments link
import { bind, compose, pipe } from "./index.js";

import {
  assertEquals,
  assertThrows,
} from "https://deno.land/std@0.86.0/testing/asserts.ts";

const isString = (x) => typeof x === "string";
const isArray = (x) => Array.isArray(x);

const upper = (x) => isString(x) && x.toUpperCase();
const lower = (x) => isString(x) && x.toLowerCase();

const trim = (x) => isString(x) && x.trim();

const split = (x) => isString(x) && x.split("");

const box = (x) => [x];
const unbox = (x) => isArray(x) && x.toString();

Deno.test("SPEC compose: combines two data operators", function () {
  const splitSafe = compose(split, unbox);
  assertEquals(splitSafe("hello"), "h,e,l,l,o");
});

Deno.test("SPEC compose: can combine a chain of data operators", function () {
  const upperSplitSafe = compose(trim, upper, split);
  assertEquals(upperSplitSafe("   hello      "), ["H", "E", "L", "L", "O"]);
});

Deno.test("EDGE compose: rejects values that are not functions", function () {
  const failsFuncClause = compose(split, 5);
  assertThrows(
    () => {
      throw failsFuncClause("hello");
    },
    undefined,
    "not a function",
  );
});

Deno.test(
  "EDGE compose: rejects functions that are not data operators",
  function () {
    const add = (y, x) => x + y;
    const failsUnaryClause = compose(split, upper, add);
    assertThrows(
      () => {
        throw failsUnaryClause("hello");
      },
      undefined,
      "not a data operator",
    );
  },
);

Deno.test("SPEC pipe: can transform data", function () {
  assertEquals(pipe("hello", upper), "HELLO");
});

Deno.test("SPEC pipe: can chain operators", function () {
  assertEquals(
    pipe(
      "hello",
      split,
      (x) => x.map((xs) => xs.charCodeAt(0)),
      (x) => x.map((xs) => xs + 16),
      (x) => x.map((xs) => String.fromCharCode(xs)),
      (x) => x.join(""),
    ),
    "xu||\x7f",
  );
});

const splitWith = (delimiter, x) => isString(x) && x.split(delimiter);
const filterAs = (condition, x) => isArray(x) && x.filter(condition);
const map = (transform, x) => box(x).map(transform);

const normalize = (b, a, x) => Math.round(Math.min(Math.max(x, a), b));

Deno.test("SPEC bind: can initialize arguments and wait for remaining", function () {
  const filterEven = bind(filterAs, (x) => x % 2 === 0);
  assertEquals(filterEven([1, 2, 3, 4, 5, 6, 7, 8, 9]), [2, 4, 6, 8]);
});

Deno.test("SPEC bind: initialize arguments in sequence for a full curry", function () {
  const limit = bind(normalize, 240);
  const threshold = bind(limit, 160);
  assertEquals(threshold(320), 240);
});

Deno.test("SPEC bind: when initial arguments match function arity, simply execute", function () {
  const boundMap = bind(map, (x, i) => `mapped ${x} at ${i}`, [
    ...Array(8).fill("hi"),
  ]);
  const standardMap = map((x, i) => `mapped ${x} at ${i}`, [
    ...Array(8).fill("hi"),
  ]);
  assertEquals(boundMap, standardMap);
});
#+END_SRC

**** results

#+BEGIN_SRC shell
printf '%s\n' (NO_COLOR=true deno test ./src/utilities/index_test.js)
#+END_SRC

#+begin_src shell
running 9 tests
test SPEC compose: combines two data operators ... ok (4ms)
test SPEC compose: can combine a chain of data operators ... ok (1ms)
test EDGE compose: rejects values that are not functions ... ok (2ms)
test EDGE compose: rejects functions that are not data operators ... ok (2ms)
test SPEC pipe: can transform data ... ok (2ms)
test SPEC pipe: can chain operators ... ok (1ms)
test SPEC bind: can initialize arguments and wait for remaining ... ok (2ms)
test SPEC bind: initialize arguments in sequence for a full curry ... ok (1ms)
test SPEC bind: when initial arguments match function arity, simply execute ... ok (2ms)

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (20ms)

#+end_src

*** Scenarios
* Internals

This section documents and implements useful internal functions that aid in developing the core
itself. They are not publicly accessible. The only reason you'd want to read this section is if
you're interested in the nuts and bolts of this project.

** Error Handling (=src/internals/error.js=)

#+BEGIN_SRC deno :tangle "./src/internals/error.js" :comments link
/** Error message template */
export function ErrorTemplate(
  { message, reason, suggestion, output } = {
    message: "something went wrong",
    reason: "here's why",
    suggestion: "try this",
    output: undefined,
  },
) {
  throw new Error(`
ERROR: ${message.trimEnd()}
${"=".repeat(60)}
REASON: ${reason.trimEnd()}
TRY: ${suggestion.trimEnd()}
${"-".repeat(60)}
OUTPUT: ${output};
`);
}
#+END_SRC

I believe in the power of good error messages in helping developers solve their own problems. Human-readable errors also decrease the likelihood that you'll need to consult documentation during your workflow.

The format of error messages thrown by the core is straightforward.

#+BEGIN_SRC text
ERROR: something went wrong
============================================================
REASON: here's why
TRY: troubleshooting suggestions
------------------------------------------------------------
OUTPUT: "and what actually happened";
#+END_SRC

** Color
*** Formats (=src/internals/color/format/index.js=)

QuarkSuite is designed primarily for web technologies and handles all current (and upcoming) CSS color
formats. This section documents how the QSC validates colors and extracts color values.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/index.js" :comments link
/** Internal color utilities */
export * from "./hex.js";
export * from "./named.js";
export * from "./rgb.js";
export * from "./hsl.js";
export * from "./device-cmyk.js";
export * from "./hwb.js";
export * from "./lab.js";
export * from "./lch.js";
#+END_SRC

From the format index, you can see at a glance which color formats are currently supported.

**** RGB Hex (=src/internals/color/format/hex.js=)

Hexadecimal colors are the most common format on the web. Below is a table showing the acceptable
formats in CSS and some examples. I also think of them as color primitives, because hex /begins/ the
conversion chain to other formats.

#+NAME: hex-formats
| Formats   | Example   |
|-----------+-----------|
| =#RGB=      | =#000=      |
| =#RRGGBB=   | =#fff=      |
| =#RGBA=     | =#000000=   |
| =#RRGGBBAA= | =#ffffff=   |
|           | =#ace=      |
|           | =#bea=      |
|           | =#fed=      |
|           | =#deaded=   |
|           | =#bada55=   |
|           | =#c0ffee=   |
|           | =#caf3c0=   |
|           | =#000f=     |
|           | =#ffff=     |
|           | =#face=     |
|           | =#ca57=     |
|           | =#000000ff= |
|           | =#ffffffff= |
|           | =#abcede79= |
|           | =#33a0c9c3= |
|           | =#eecc99dd= |

***** Hex Validator

The regular expression to validate a hex color is short.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hex.js" :comments link
/** Validate: hex color */
export const validate = (color) => /^#([\da-f]{3,4}){1,2}$/i.test(color);
#+END_SRC

Let's see if all the colors defined in the format table pass:

#+BEGIN_SRC deno :results output code replace :allow read :var hexTable=hex-formats
const hex = await import(`${Deno.cwd()}/src/internals/color/format/hex.js`);
const [, ...colors] = hexTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isHex: hex.validate(color)})))
#+END_SRC

#+NAME: valid-hex
#+begin_src deno
const colors = [
  { color: "#000", isHex: true },
  { color: "#fff", isHex: true },
  { color: "#000000", isHex: true },
  { color: "#ffffff", isHex: true },
  { color: "#ace", isHex: true },
  { color: "#bea", isHex: true },
  { color: "#fed", isHex: true },
  { color: "#deaded", isHex: true },
  { color: "#bada55", isHex: true },
  { color: "#c0ffee", isHex: true },
  { color: "#caf3c0", isHex: true },
  { color: "#000f", isHex: true },
  { color: "#ffff", isHex: true },
  { color: "#face", isHex: true },
  { color: "#ca57", isHex: true },
  { color: "#000000ff", isHex: true },
  { color: "#ffffffff", isHex: true },
  { color: "#abcede79", isHex: true },
  { color: "#33a0c9c3", isHex: true },
  { color: "#eecc99dd", isHex: true }
]
#+end_src

***** Hex Value Extractor

Now, that I know I have valid hex colors, I need to be able to extract their RGB(A) channels.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hex.js" :comments link
/** Expand hex shorthand into full hex color */
export function expander(color) {
  const [, ...values] = color;

  if (values.length === 3 || values.length === 4) {
    return `#${values.map((channel) => channel.repeat(2)).join("")}`;
  }

  return color;
}
#+END_SRC

The first step is enforcing uniformity. To prevent any surprises, I'm going to simply expand hex
color shorthand =#RGB(A)= to a full hex color =#RRGGBB(AA)=.

Making sure that works:

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hex = await import(`${Deno.cwd()}/src/internals/color/format/hex.js`);

<<valid-hex>>

console.log("const colors =", colors.map(({ color }) => ({ color, expanded: hex.expander(color) })))
#+END_SRC

#+NAME: expanded-hex
#+begin_src deno
const colors = [
  { color: "#000", expanded: "#000000" },
  { color: "#fff", expanded: "#ffffff" },
  { color: "#000000", expanded: "#000000" },
  { color: "#ffffff", expanded: "#ffffff" },
  { color: "#ace", expanded: "#aaccee" },
  { color: "#bea", expanded: "#bbeeaa" },
  { color: "#fed", expanded: "#ffeedd" },
  { color: "#deaded", expanded: "#deaded" },
  { color: "#bada55", expanded: "#bada55" },
  { color: "#c0ffee", expanded: "#c0ffee" },
  { color: "#caf3c0", expanded: "#caf3c0" },
  { color: "#000f", expanded: "#000000ff" },
  { color: "#ffff", expanded: "#ffffffff" },
  { color: "#face", expanded: "#ffaaccee" },
  { color: "#ca57", expanded: "#ccaa5577" },
  { color: "#000000ff", expanded: "#000000ff" },
  { color: "#ffffffff", expanded: "#ffffffff" },
  { color: "#abcede79", expanded: "#abcede79" },
  { color: "#33a0c9c3", expanded: "#33a0c9c3" },
  { color: "#eecc99dd", expanded: "#eecc99dd" }
]
#+end_src

Having secured uniform input, I'm ready to extract the channel values for processing.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hex.js" :comments link
/** Extract: hex channel values */
export const extract = (hex) => hex.match(/[\da-f]{2}/g);
#+END_SRC

The only thing to do here is remove the =#= and match the channel values with a regular expression.

Then, I'm going to test that the channel values are extracted as =[R, G, B, A]=:

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hex = await import (`${Deno.cwd()}/src/internals/color/format/hex.js`);

<<expanded-hex>>

console.log("const colors =", colors.map(({ expanded }) => ({color: expanded, values: hex.extract(expanded) })));
#+END_SRC

#+NAME: extracted-hex
#+begin_src deno
const colors = [
  { color: "#000000", values: [ "00", "00", "00" ] },
  { color: "#ffffff", values: [ "ff", "ff", "ff" ] },
  { color: "#000000", values: [ "00", "00", "00" ] },
  { color: "#ffffff", values: [ "ff", "ff", "ff" ] },
  { color: "#aaccee", values: [ "aa", "cc", "ee" ] },
  { color: "#bbeeaa", values: [ "bb", "ee", "aa" ] },
  { color: "#ffeedd", values: [ "ff", "ee", "dd" ] },
  { color: "#deaded", values: [ "de", "ad", "ed" ] },
  { color: "#bada55", values: [ "ba", "da", "55" ] },
  { color: "#c0ffee", values: [ "c0", "ff", "ee" ] },
  { color: "#caf3c0", values: [ "ca", "f3", "c0" ] },
  { color: "#000000ff", values: [ "00", "00", "00", "ff" ] },
  { color: "#ffffffff", values: [ "ff", "ff", "ff", "ff" ] },
  { color: "#ffaaccee", values: [ "ff", "aa", "cc", "ee" ] },
  { color: "#ccaa5577", values: [ "cc", "aa", "55", "77" ] },
  { color: "#000000ff", values: [ "00", "00", "00", "ff" ] },
  { color: "#ffffffff", values: [ "ff", "ff", "ff", "ff" ] },
  { color: "#abcede79", values: [ "ab", "ce", "de", "79" ] },
  { color: "#33a0c9c3", values: [ "33", "a0", "c9", "c3" ] },
  { color: "#eecc99dd", values: [ "ee", "cc", "99", "dd" ] }
]
#+end_src
**** W3C-X11 (=src/internals/color/format/named.js=)

Named colors are simple to validate. It's a matter of matching the name with its hex value in the
=X11Colors= lookup table as a boolean.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/named.js" :comments link
import { X11Colors } from "../../../data/color/w3c-x11.js";

/** Validate: W3C X11 named colors */
export const validate = (color) => !!X11Colors[color];
#+END_SRC

**** Functional RGB (=src/internals/color/format/rgb.js=)

The functional RGB syntax is more complex and allows for more variation in the format. Quarks System
Core supports the legacy format as well as the newer space-separated ones.

#+NAME: rgb-formats
| Formats          | Examples                  |
|------------------+---------------------------|
| =rgb(R, G, B)=     | =rgb(0, 0, 0)=              |
| =rgba(R, G, B, A)= | =rgb(255, 255, 255)=        |
| =rgb(R G B)=       | =rgb(110, 22, 33)=          |
| =rgb(R G B / A)=   | =rgb(30, 220, 140)=         |
| =rgba(R G B / A)=  | =rgb(148, 129, 240)=        |
|                  | =rgb(31 33 100)=            |
|                  | =rgb(200 210 131)=          |
|                  | =rgb(0%, 0%, 0%)=           |
|                  | =rgb(100%, 100%, 100%)=     |
|                  | =rgb(31%, 15%, 4%)=         |
|                  | =rgb(20%, 70.3%, 49%)=      |
|                  | =rgb(10% 30% 95%)=          |
|                  | rgb(33% 24% 44%)          |
|                  | =rgba(0, 0, 0, 1)=          |
|                  | =rgba(255, 255, 255, 1)=    |
|                  | =rgba(230, 110, 0, 0.8)=    |
|                  | =rgba(120, 178, 34, 0.719)= |
|                  | =rgba(34, 199, 249, 0.3)=   |
|                  | =rgb(10 110 200 / 73%)=     |
|                  | =rgba(34 225 110 / 25.9%)=  |
|                  | =rgb(10% 33% 19% / 0.35)=   |

***** RGB Validator

Validating the functional RGB is similarly complex but the regular expression can be broken down to
its unique and repeating parts and then assembled with the =RegExp.source= property as a new =RegExp=
object.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/rgb.js" :comments link
/** Validate: functional RGB format */
export function validate(color) {
  // RGB regexp

  // prefix: "rgb(" || "rgba("
  // R && G && B: float<0-100>% || int<0-255>
  let R, G, B;
  R = G = B =
    /(?:(?:100%|(?:\d\.?\d?){1,}%)|(?:25[0-5]|24[0-4][0-9]|1[0-9]{2}|\d{1,}|0))/;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: ", " || " " || " /"
  const channelSep = /(?:[\s,]+)/;
  const alphaSep = /(?:[,\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^rgba?\\(",
      R.source,
      channelSep.source,
      G.source,
      channelSep.source,
      B.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Next up is seeing if the format tests pass.

#+BEGIN_SRC deno :results output code replace :allow read :var rgbTable=rgb-formats
const rgb = await import(`${Deno.cwd()}/src/internals/color/format/rgb.js`);
const colors = rgbTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isRGB: rgb.validate(color)})))
#+END_SRC

#+NAME: valid-rgb
#+begin_src deno
const colors = [
  { color: "rgb(0, 0, 0)", isRGB: true },
  { color: "rgb(255, 255, 255)", isRGB: true },
  { color: "rgb(110, 22, 33)", isRGB: true },
  { color: "rgb(30, 220, 140)", isRGB: true },
  { color: "rgb(148, 129, 240)", isRGB: true },
  { color: "rgb(31 33 100)", isRGB: true },
  { color: "rgb(200 210 131)", isRGB: true },
  { color: "rgb(0%, 0%, 0%)", isRGB: true },
  { color: "rgb(100%, 100%, 100%)", isRGB: true },
  { color: "rgb(31%, 15%, 4%)", isRGB: true },
  { color: "rgb(20%, 70.3%, 49%)", isRGB: true },
  { color: "rgb(10% 30% 95%)", isRGB: true },
  { color: "rgb(33% 24% 44%)", isRGB: true },
  { color: "rgba(0, 0, 0, 1)", isRGB: true },
  { color: "rgba(255, 255, 255, 1)", isRGB: true },
  { color: "rgba(230, 110, 0, 0.8)", isRGB: true },
  { color: "rgba(120, 178, 34, 0.719)", isRGB: true },
  { color: "rgba(34, 199, 249, 0.3)", isRGB: true },
  { color: "rgb(10 110 200 / 73%)", isRGB: true },
  { color: "rgba(34 225 110 / 25.9%)", isRGB: true },
  { color: "rgb(10% 33% 19% / 0.35)", isRGB: true }
]
#+end_src

All clear!

***** RGB Extractor

The next step is ensuring the channel/alpha values can be extracted.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/rgb.js" :comments link
/** Extract: RGB channel/alpha values */
export const extract = (rgb) => rgb.match(/([\d.]%?)+/g);
#+END_SRC

The extractor preserves the =%= because it will be properly converted to a fraction for later
calculations. Since the extractor is only used with valid RGB colors, the match pattern does not
need to be intensive.

Now, I'll test that the values are properly pulled.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const rgb = await import(`${Deno.cwd()}/src/internals/color/format/rgb.js`);

<<valid-rgb>>

console.log("const colors =", colors.map(({ color }) => ({ color, values: rgb.extract(color) })));
#+END_SRC

#+NAME: extracted-rgb
#+begin_src deno
const colors = [
  { color: "rgb(0, 0, 0)", values: [ "0", "0", "0" ] },
  { color: "rgb(255, 255, 255)", values: [ "255", "255", "255" ] },
  { color: "rgb(110, 22, 33)", values: [ "110", "22", "33" ] },
  { color: "rgb(30, 220, 140)", values: [ "30", "220", "140" ] },
  { color: "rgb(148, 129, 240)", values: [ "148", "129", "240" ] },
  { color: "rgb(31 33 100)", values: [ "31", "33", "100" ] },
  { color: "rgb(200 210 131)", values: [ "200", "210", "131" ] },
  { color: "rgb(0%, 0%, 0%)", values: [ "0%", "0%", "0%" ] },
  { color: "rgb(100%, 100%, 100%)", values: [ "100%", "100%", "100%" ] },
  { color: "rgb(31%, 15%, 4%)", values: [ "31%", "15%", "4%" ] },
  { color: "rgb(20%, 70.3%, 49%)", values: [ "20%", "70.3%", "49%" ] },
  { color: "rgb(10% 30% 95%)", values: [ "10%", "30%", "95%" ] },
  { color: "rgb(33% 24% 44%)", values: [ "33%", "24%", "44%" ] },
  { color: "rgba(0, 0, 0, 1)", values: [ "0", "0", "0", "1" ] },
  { color: "rgba(255, 255, 255, 1)", values: [ "255", "255", "255", "1" ] },
  { color: "rgba(230, 110, 0, 0.8)", values: [ "230", "110", "0", "0.8" ] },
  { color: "rgba(120, 178, 34, 0.719)", values: [ "120", "178", "34", "0.719" ] },
  { color: "rgba(34, 199, 249, 0.3)", values: [ "34", "199", "249", "0.3" ] },
  { color: "rgb(10 110 200 / 73%)", values: [ "10", "110", "200", "73%" ] },
  { color: "rgba(34 225 110 / 25.9%)", values: [ "34", "225", "110", "25.9%" ] },
  { color: "rgb(10% 33% 19% / 0.35)", values: [ "10%", "33%", "19%", "0.35" ] }
]
#+end_src

**** Functional HSL (=src/internals/color/format/hsl.js=)

HSL is well-loved by designers for being a lot more intuitive than RGB. It explicitly allows
setting:

+ Hue (H): An angle corresponding to a color's position on an RGB color wheel. =0= degrees
  means red, green sits at =120= degrees, and blue sits at =240=
+ Saturation (S): A percentage value corresponding to a color's vibrance or chroma. =0%= indicates a
  fully unsaturated color (yielding gray). =100%= indicates a fully saturated color
+ Lightness/Luminance (L): A percentage value corresponding to a color's brightness. At =50%= a color
  is normalized. =0%= yields pure black and =100%= yields pure white

CSS also defines several rotational units for the hue. All of which QuarkSuite supports.

#+NAME: hsl-formats
| Examples         | Formats                        |
|------------------+--------------------------------|
| =hsl(H, S, L)=     | =hsl(0, 0%, 0%)=                 |
| =hsla(H, S, L, A)= | =hsl(0, 0%, 50%)=                |
| =hsl(H S L)=       | =hsl(0, 0%, 100%)=               |
| =hsl(H S L / A)=   | =hsl(0 0% 0%)=                   |
| =hsla(H S L / A)=  | =hsl(0 0% 50%)=                  |
|                  | =hsl(0 0% 100%)=                 |
|                  | =hsl(120, 74%, 63%)=             |
|                  | =hsl(64deg, 85%, 50%)=           |
|                  | =hsl(200rad, 42%, 81%)=          |
|                  | =hsl(2.3grad, 50%, 50%)=         |
|                  | =hsl(0.25turn, 39%, 73%)=        |
|                  | =hsl(-135, 69%, 94%)=            |
|                  | =hsl(189 35% 82%)=               |
|                  | =hsl(161deg 50% 78%)=            |
|                  | =hsl(380rad 75% 13%)=            |
|                  | =hsl(1.6grad 100% 48%)=          |
|                  | =hsl(0.13turn 58% 20%)=          |
|                  | =hsl(-1.9grad 33% 80%)=          |
|                  | =hsla(0, 0%, 0%, 1)=             |
|                  | =hsla(0, 0%, 50%, 1)=            |
|                  | =hsla(0, 0%, 100%, 1)=           |
|                  | =hsla(0 0% 0% / 1)=              |
|                  | =hsla(0 0% 50% / 1)=             |
|                  | =hsla(0 0% 100% / 1)=            |
|                  | =hsla(34, 73%, 89%, 0.7)=        |
|                  | =hsla(67deg, 99%, 38%, 0.25)=    |
|                  | =hsla(393rad, 85%, 18%, 0.493)=  |
|                  | =hsla(5.2grad, 39%, 58%, 0.5)=   |
|                  | =hsla(0.34turn, 19%, 36%, 0.39)= |
|                  | =hsl(100 40% 39% / 73%)=         |
|                  | =hsl(90deg 89% 61% / 0.3)=       |
|                  | =hsla(48rad 74% 38% / 39%)=      |
|                  | =hsl(4.8grad 37% 100% / 0.47)=   |
|                  | =hsla(0.134turn 33% 88% / 40%)=  |

***** HSL Validator

From here, you'll start seeing a lot of repetition in the validation expressions.

Validating HSL has a similar pattern to validating RGB. In fact, many of the regular expression
fragments are the same.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hsl.js" :comments link
/** Validate: functional HSL format */
export function validate(color) {
  // HSL regexp

  // prefix: "hsl(" || "hsla("
  // hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
  const hue = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;
  // saturation && lightness: float<0-100>%
  const saturation = /(?:(?:100%|(?:\d\.?\d?){1,}%))/;
  const lightness = saturation;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: ", " || " " || " /"
  const valueSep = /(?:[\s,]+)/;
  const alphaSep = /(?:[,\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^hsla?\\(",
      hue.source,
      valueSep.source,
      saturation.source,
      valueSep.source,
      lightness.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Now, I'll perform the tests:

#+BEGIN_SRC deno :results output code replace :allow read :var hslTable=hsl-formats
const hsl = await import(`${Deno.cwd()}/src/internals/color/format/hsl.js`);
const colors = hslTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isHSL: hsl.validate(color)})))
#+END_SRC

#+NAME: valid-hsl
#+begin_src deno
const colors = [
  { color: "hsl(0, 0%, 0%)", isHSL: true },
  { color: "hsl(0, 0%, 50%)", isHSL: true },
  { color: "hsl(0, 0%, 100%)", isHSL: true },
  { color: "hsl(0 0% 0%)", isHSL: true },
  { color: "hsl(0 0% 50%)", isHSL: true },
  { color: "hsl(0 0% 100%)", isHSL: true },
  { color: "hsl(120, 74%, 63%)", isHSL: true },
  { color: "hsl(64deg, 85%, 50%)", isHSL: true },
  { color: "hsl(200rad, 42%, 81%)", isHSL: true },
  { color: "hsl(2.3grad, 50%, 50%)", isHSL: true },
  { color: "hsl(0.25turn, 39%, 73%)", isHSL: true },
  { color: "hsl(-135, 69%, 94%)", isHSL: true },
  { color: "hsl(189 35% 82%)", isHSL: true },
  { color: "hsl(161deg 50% 78%)", isHSL: true },
  { color: "hsl(380rad 75% 13%)", isHSL: true },
  { color: "hsl(1.6grad 100% 48%)", isHSL: true },
  { color: "hsl(0.13turn 58% 20%)", isHSL: true },
  { color: "hsl(-1.9grad 33% 80%)", isHSL: true },
  { color: "hsla(0, 0%, 0%, 1)", isHSL: true },
  { color: "hsla(0, 0%, 50%, 1)", isHSL: true },
  { color: "hsla(0, 0%, 100%, 1)", isHSL: true },
  { color: "hsla(0 0% 0% / 1)", isHSL: true },
  { color: "hsla(0 0% 50% / 1)", isHSL: true },
  { color: "hsla(0 0% 100% / 1)", isHSL: true },
  { color: "hsla(34, 73%, 89%, 0.7)", isHSL: true },
  { color: "hsla(67deg, 99%, 38%, 0.25)", isHSL: true },
  { color: "hsla(393rad, 85%, 18%, 0.493)", isHSL: true },
  { color: "hsla(5.2grad, 39%, 58%, 0.5)", isHSL: true },
  { color: "hsla(0.34turn, 19%, 36%, 0.39)", isHSL: true },
  { color: "hsl(100 40% 39% / 73%)", isHSL: true },
  { color: "hsl(90deg 89% 61% / 0.3)", isHSL: true },
  { color: "hsla(48rad 74% 38% / 39%)", isHSL: true },
  { color: "hsl(4.8grad 37% 100% / 0.47)", isHSL: true },
  { color: "hsla(0.134turn 33% 88% / 40%)", isHSL: true }
]
#+end_src

***** HSL Extractor

Next, I need to be able extract HSL values.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hsl.js" :comments link
/** Extract: HSL values */
export const extract = (hsl) => hsl.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

Again, the HSL extractor is very similar to the RGB extractor. The only difference being that I'm
extracting the hue units along with percentages.

Finally, I'll test that the values are extracted.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hsl = await import(`${Deno.cwd()}/src/internals/color/format/hsl.js`);

<<valid-hsl>>

console.log("const colors =", colors.map(({ color }) => ({ color, values: hsl.extract(color) })));
#+END_SRC

#+NAME: extracted-hsl
#+begin_src deno
const colors = [
  { color: "hsl(0, 0%, 0%)", values: [ "0", "0%", "0%" ] },
  { color: "hsl(0, 0%, 50%)", values: [ "0", "0%", "50%" ] },
  { color: "hsl(0, 0%, 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hsl(0 0% 0%)", values: [ "0", "0%", "0%" ] },
  { color: "hsl(0 0% 50%)", values: [ "0", "0%", "50%" ] },
  { color: "hsl(0 0% 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hsl(120, 74%, 63%)", values: [ "120", "74%", "63%" ] },
  { color: "hsl(64deg, 85%, 50%)", values: [ "64deg", "85%", "50%" ] },
  { color: "hsl(200rad, 42%, 81%)", values: [ "200rad", "42%", "81%" ] },
  { color: "hsl(2.3grad, 50%, 50%)", values: [ "2.3grad", "50%", "50%" ] },
  { color: "hsl(0.25turn, 39%, 73%)", values: [ "0.25turn", "39%", "73%" ] },
  { color: "hsl(-135, 69%, 94%)", values: [ "-135", "69%", "94%" ] },
  { color: "hsl(189 35% 82%)", values: [ "189", "35%", "82%" ] },
  { color: "hsl(161deg 50% 78%)", values: [ "161deg", "50%", "78%" ] },
  { color: "hsl(380rad 75% 13%)", values: [ "380rad", "75%", "13%" ] },
  { color: "hsl(1.6grad 100% 48%)", values: [ "1.6grad", "100%", "48%" ] },
  { color: "hsl(0.13turn 58% 20%)", values: [ "0.13turn", "58%", "20%" ] },
  { color: "hsl(-1.9grad 33% 80%)", values: [ "-1.9grad", "33%", "80%" ] },
  { color: "hsla(0, 0%, 0%, 1)", values: [ "0", "0%", "0%", "1" ] },
  { color: "hsla(0, 0%, 50%, 1)", values: [ "0", "0%", "50%", "1" ] },
  { color: "hsla(0, 0%, 100%, 1)", values: [ "0", "0%", "100%", "1" ] },
  { color: "hsla(0 0% 0% / 1)", values: [ "0", "0%", "0%", "1" ] },
  { color: "hsla(0 0% 50% / 1)", values: [ "0", "0%", "50%", "1" ] },
  { color: "hsla(0 0% 100% / 1)", values: [ "0", "0%", "100%", "1" ] },
  { color: "hsla(34, 73%, 89%, 0.7)", values: [ "34", "73%", "89%", "0.7" ] },
  { color: "hsla(67deg, 99%, 38%, 0.25)", values: [ "67deg", "99%", "38%", "0.25" ] },
  {
    color: "hsla(393rad, 85%, 18%, 0.493)",
    values: [ "393rad", "85%", "18%", "0.493" ]
  },
  {
    color: "hsla(5.2grad, 39%, 58%, 0.5)",
    values: [ "5.2grad", "39%", "58%", "0.5" ]
  },
  {
    color: "hsla(0.34turn, 19%, 36%, 0.39)",
    values: [ "0.34turn", "19%", "36%", "0.39" ]
  },
  { color: "hsl(100 40% 39% / 73%)", values: [ "100", "40%", "39%", "73%" ] },
  { color: "hsl(90deg 89% 61% / 0.3)", values: [ "90deg", "89%", "61%", "0.3" ] },
  { color: "hsla(48rad 74% 38% / 39%)", values: [ "48rad", "74%", "38%", "39%" ] },
  {
    color: "hsl(4.8grad 37% 100% / 0.47)",
    values: [ "4.8grad", "37%", "100%", "0.47" ]
  },
  {
    color: "hsla(0.134turn 33% 88% / 40%)",
    values: [ "0.134turn", "33%", "88%", "40%" ]
  }
]
#+end_src

The formats documented beyond this point are brand new territory for the core module and unsupported
in QuarkSuite 1.

**** Device CMYK (=src/internals/color/format/device-cmyk.js=)

=device-cmyk()= is a prospective format documented in the [[https://www.w3.org/TR/css-color-4/#device-cmyk][current CSS Color Module 4 draft]]. CMYK in
general is a color space typically calibrated for printed media.

+ Cyan (C): the amount of cyan ink in the color
+ Magenta (M): the amount of magenta ink in the color
+ Yellow (Y): the amount of yellow ink in the color
+ BlacK (K): the amount of black ink in the color

It's important to note: as a newer CSS color functional format, =device-cmyk()= doesn't bother with
the older comma-separated syntax, so neither does the Quarks System Core. The same carries for all
color formats beyond this point.

#+NAME: cmyk-formats
| Format                        | Examples                          |
|-------------------------------+-----------------------------------|
| =device-cmyk(C M Y K)=          | =device-cmyk(0 0 0 0)=              |
| =device-cmyk(C% M% Y% K%)=      | =device-cmyk(1 1 1 1)=              |
| =device-cmyk(C M Y K / A)=      | =device-cmyk(0% 0% 0% 0%)=          |
| =device-cmyk(C% M% Y% K% / A%)= | =device-cmyk(100% 100% 100% 100%)=  |
|                               | =device-cmyk(0 0.4 0.8 0.25)=       |
|                               | =device-cmyk(30% 49% 0 20%)=        |
|                               | =device-cmyk(19% 30% 83% 0 / 0.31)= |
|                               | =device-cmyk(0.9 0.25 0 0 / 73%)= |

***** CMYK Validator

The validation for CMYK in CSS is thankfully simple.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/device-cmyk.js" :comments link
/** Validate: CMYK format */
export function validate(color) {
  // CMYK regexp

  // prefix: "device-cymk("
  // c & m & y & k & a: float<0-1> || float<0-100>%
  let c, m, y, k, alpha;
  c = m = y = k = alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s]+)/;
  const alphaSep = /(?:[\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^device-cmyk\\(",
      c.source,
      valueSep.source,
      m.source,
      valueSep.source,
      y.source,
      valueSep.source,
      k.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Now, on to the format tests.

#+BEGIN_SRC deno :results output code replace :allow read :var cmykTable=cmyk-formats
const cmyk = await import(`${Deno.cwd()}/src/internals/color/format/device-cmyk.js`);
const colors = cmykTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isCMYK: cmyk.validate(color)})))
#+END_SRC

#+NAME: valid-cmyk
#+begin_src deno
const colors = [
  { color: "device-cmyk(0 0 0 0)", isCMYK: true },
  { color: "device-cmyk(1 1 1 1)", isCMYK: true },
  { color: "device-cmyk(0% 0% 0% 0%)", isCMYK: true },
  { color: "device-cmyk(100% 100% 100% 100%)", isCMYK: true },
  { color: "device-cmyk(0 0.4 0.8 0.25)", isCMYK: true },
  { color: "device-cmyk(30% 49% 0 20%)", isCMYK: true },
  { color: "device-cmyk(19% 30% 83% 0 / 0.31)", isCMYK: true },
  { color: "device-cmyk(0.9 0.25 0 0 / 73%)", isCMYK: true }
]
#+end_src

***** CMYK Extractor

From here, the extractor is another one-liner.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/device-cmyk.js" :comments link
/** Extract: CMYK values */
export const extract = (cmyk) => cmyk.match(/([\d.]+)%?/g);
#+END_SRC

Finally, the extraction tests:

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const cmyk = await import(`${Deno.cwd()}/src/internals/color/format/device-cmyk.js`);

<<valid-cmyk>>

console.log("const colors =", colors.map(({ color }) => ({ color, values: cmyk.extract(color) })));
#+END_SRC

#+NAME: extracted-cmyk
#+begin_src deno
const colors = [
  { color: "device-cmyk(0 0 0 0)", values: [ "0", "0", "0", "0" ] },
  { color: "device-cmyk(1 1 1 1)", values: [ "1", "1", "1", "1" ] },
  { color: "device-cmyk(0% 0% 0% 0%)", values: [ "0%", "0%", "0%", "0%" ] },
  {
    color: "device-cmyk(100% 100% 100% 100%)",
    values: [ "100%", "100%", "100%", "100%" ]
  },
  { color: "device-cmyk(0 0.4 0.8 0.25)", values: [ "0", "0.4", "0.8", "0.25" ] },
  { color: "device-cmyk(30% 49% 0 20%)", values: [ "30%", "49%", "0", "20%" ] },
  {
    color: "device-cmyk(19% 30% 83% 0 / 0.31)",
    values: [ "19%", "30%", "83%", "0", "0.31" ]
  },
  {
    color: "device-cmyk(0.9 0.25 0 0 / 73%)",
    values: [ "0.9", "0.25", "0", "0", "73%" ]
  }
]
#+end_src

And now it's on to the next one.

**** Functional HWB (=src/internals/color/format/hwb.js=)

HWB is short for Hue-Whiteness-Blackness. It's an [[https://www.w3.org/TR/css-color-4/#the-hwb-notation][upcoming color format similar to HSL]] but even
easier to use. It's actually the format of choice for lot of browser color picker implementations.

+ Hue (H): works the same as it does in the HSL format
+ Whiteness (W): a percentage value corresponding with how much white to mix with the hue
+ Blackness (B): a percentage value corresponding with how much black to mix with the hue

When W and B are mixed equal amounts, they yield gray. When both are =100%=, the color is achromatic.

#+NAME: hwb-formats
| Formats           | Examples                 |
|-------------------+--------------------------|
| =hwb(H W% B%)=      | =hwb(0 0% 0%)=             |
| =hwb(Hdeg W% B%)=   | =hwb(0 100% 0%)=           |
| =hwb(Hrad W% B%)=   | =hwb(0 0% 100%)=           |
| =hwb(Hgrad W% B%)=  | =hwb(0 100% 100%)=         |
| =hwb(Hturn W% B%)=  | =hwb(47 37% 40%)=          |
| =hwb(H W% B% / A)=  | =hwb(180deg 50% 3%)=       |
| =hwb(H W% B% / A%)= | =hwb(172rad 25% 15%)=      |
|                   | =hwb(3.1grad 0% 30%)=      |
|                   | =hwb(0.28turn 49% 10%)=    |
|                   | =hwb(310 78% 0% / 0.5)=    |
|                   | =hwb(89rad 10% 90% / 83%)= |

***** HWB Validator

The HWB validator expressions are nearly identical to the HSL validator.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hwb.js" :comments link
/** Validate: functional HWB format */
export function validate(color) {
  // HWB regexp

  // prefix: "hwb("
  // hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
  const hue = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;
  // whitness && blackness: float<0-100>%
  const whiteness = /(?:(?:100%|(?:\d\.?\d?){1,}%))/;
  const blackness = whiteness;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s,]+)/;
  const alphaSep = /(?:[,\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^hwb\\(",
      hue.source,
      valueSep.source,
      whiteness.source,
      valueSep.source,
      blackness.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Alright, now the format tests.

#+BEGIN_SRC deno :results output code replace :allow read :var hwbTable=hwb-formats
const hwb = await import(`${Deno.cwd()}/src/internals/color/format/hwb.js`);
const [, ...colors] = hwbTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isHWB: hwb.validate(color)})))
#+END_SRC

#+NAME: valid-hwb
#+begin_src deno
const colors = [
  { color: "hwb(0 100% 0%)", isHWB: true },
  { color: "hwb(0 0% 100%)", isHWB: true },
  { color: "hwb(0 100% 100%)", isHWB: true },
  { color: "hwb(47 37% 40%)", isHWB: true },
  { color: "hwb(180deg 50% 3%)", isHWB: true },
  { color: "hwb(172rad 25% 15%)", isHWB: true },
  { color: "hwb(3.1grad 0% 30%)", isHWB: true },
  { color: "hwb(0.28turn 49% 10%)", isHWB: true },
  { color: "hwb(310 78% 0% / 0.5)", isHWB: true },
  { color: "hwb(89rad 10% 90% / 83%)", isHWB: true }
]
#+end_src

***** HWB Extractor

The value extractor for HWB is identical to the one for HSL.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/hwb.js" :comments link
/** Extract: HWB values */
export const extract = (hwb) => hwb.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

Finally, the tests for value extraction.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const hwb = await import(`${Deno.cwd()}/src/internals/color/format/hwb.js`);

<<valid-hwb>>

console.log("const colors =", colors.map(({ color }) => ({ color, values: hwb.extract(color) })));
#+END_SRC

#+NAME: extracted-hwb
#+begin_src deno
const colors = [
  { color: "hwb(0 100% 0%)", values: [ "0", "100%", "0%" ] },
  { color: "hwb(0 0% 100%)", values: [ "0", "0%", "100%" ] },
  { color: "hwb(0 100% 100%)", values: [ "0", "100%", "100%" ] },
  { color: "hwb(47 37% 40%)", values: [ "47", "37%", "40%" ] },
  { color: "hwb(180deg 50% 3%)", values: [ "180deg", "50%", "3%" ] },
  { color: "hwb(172rad 25% 15%)", values: [ "172rad", "25%", "15%" ] },
  { color: "hwb(3.1grad 0% 30%)", values: [ "3.1grad", "0%", "30%" ] },
  { color: "hwb(0.28turn 49% 10%)", values: [ "0.28turn", "49%", "10%" ] },
  { color: "hwb(310 78% 0% / 0.5)", values: [ "310", "78%", "0%", "0.5" ] },
  { color: "hwb(89rad 10% 90% / 83%)", values: [ "89rad", "10%", "90%", "83%" ] }
]
#+end_src

**** Functional CIELAB (=src/internals/color/format/lab.js=)

The CSS Color Module Level 4 is currently drafting [[https://www.w3.org/TR/css-color-4/#lab-colors][support for device-independent color
formats]]. Quarks System Core supports both.

First up is the CIELAB (often called Lab for short) color format. The format specification is better
explained on the linked W3C page above, but I'll summarize the components:

+ Lightness (L): a percentage value which, unlike HSL, is /not/ capped at =100%= for this space
+ hues (*a): magenta-red when positive, its complement when negative
+ hues (*b): yellow when positive, its complement when negative

The hue axes are unbound, but in everyday use typically cap at =±160=.

#+NAME: lab-formats
| Format          | Examples                      |
|-----------------+-------------------------------|
| =lab(L% a b)=     | =lab(0% 0 0)=                   |
| =lab(L% a b / A)= | =lab(50% 0 0)=                  |
|                 | =lab(100% 0 0)=                 |
|                 | =lab(49% 160 0)=                |
|                 | =lab(72% 0 160)=                |
|                 | =lab(19% 160 0)=                |
|                 | =lab(64% -160 0)=               |
|                 | =lab(46% 0 -160)=               |
|                 | =lab(34.3391% 49.3819 -4.3942)= |
|                 | =lab(57.38% 38.339 19.331)=     |
|                 | =lab(68.3194% -94 0)=           |
|                 | =lab(24.193% -66 138 / 0.9)=    |
|                 | =lab(88.1199% 78 -33 / 78%)=  |

***** CIELAB Validator

The Lab validator is not complex. It reuses the alpha validation expression and modifies the RGB
channel validation expression slightly.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/lab.js" :comments link
/** Validate: functional CIELAB format */
export function validate(color) {
  // CIELAB regexp

  // prefix: "lab("
  // L: float<0->%
  const L = /(?:(?:\d\.?\d?){1,}%)/;
  // a && b: -?int<0-160>
  let a, b;
  a = b = /(?:-?(?:160|(?:1[0-5][0-9]|(?:\d.?\d?){1,})))/;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s]+)/;
  const alphaSep = /(?:[\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^lab\\(",
      L.source,
      valueSep.source,
      a.source,
      valueSep.source,
      b.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

Now, it's validator testing time.

#+BEGIN_SRC deno :results output code replace :allow read :var labTable=lab-formats
const lab = await import(`${Deno.cwd()}/src/internals/color/format/lab.js`);
const [, ...colors] = labTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isCIELAB: lab.validate(color)})))
#+END_SRC

#+NAME: valid-lab
#+begin_src deno
const colors = [
  { color: "lab(50% 0 0)", isCIELAB: true },
  { color: "lab(100% 0 0)", isCIELAB: true },
  { color: "lab(49% 160 0)", isCIELAB: true },
  { color: "lab(72% 0 160)", isCIELAB: true },
  { color: "lab(19% 160 0)", isCIELAB: true },
  { color: "lab(64% -160 0)", isCIELAB: true },
  { color: "lab(46% 0 -160)", isCIELAB: true },
  { color: "lab(34.3391% 49.3819 -4.3942)", isCIELAB: true },
  { color: "lab(57.38% 38.339 19.331)", isCIELAB: true },
  { color: "lab(68.3194% -94 0)", isCIELAB: true },
  { color: "lab(24.193% -66 138 / 0.9)", isCIELAB: true },
  { color: "lab(88.1199% 78 -33 / 78%)", isCIELAB: true }
]
#+end_src

Good to go.

***** CIELAB Extractor

The CIELAB value extractor is a slight modification from the HSL extractor. The CIELAB extractor
needs to be able to capture negative and positive values as well as percentages.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/lab.js" :comments link
/** Extract: CIELAB values */
export const extract = (lab) => lab.match(/(-?[\d.]%?)+/g);
#+END_SRC

Time to test it.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lab = await import(`${Deno.cwd()}/src/internals/color/format/lab.js`);

<<valid-lab>>

console.log("const colors =", colors.map(({ color }) => ({ color, values: lab.extract(color) })));
#+END_SRC

#+NAME: extracted-lab
#+begin_src deno
const colors = [
  { color: "lab(50% 0 0)", values: [ "50%", "0", "0" ] },
  { color: "lab(100% 0 0)", values: [ "100%", "0", "0" ] },
  { color: "lab(49% 160 0)", values: [ "49%", "160", "0" ] },
  { color: "lab(72% 0 160)", values: [ "72%", "0", "160" ] },
  { color: "lab(19% 160 0)", values: [ "19%", "160", "0" ] },
  { color: "lab(64% -160 0)", values: [ "64%", "-160", "0" ] },
  { color: "lab(46% 0 -160)", values: [ "46%", "0", "-160" ] },
  {
    color: "lab(34.3391% 49.3819 -4.3942)",
    values: [ "34.3391%", "49.3819", "-4.3942" ]
  },
  { color: "lab(57.38% 38.339 19.331)", values: [ "57.38%", "38.339", "19.331" ] },
  { color: "lab(68.3194% -94 0)", values: [ "68.3194%", "-94", "0" ] },
  { color: "lab(24.193% -66 138 / 0.9)", values: [ "24.193%", "-66", "138", "0.9" ] },
  { color: "lab(88.1199% 78 -33 / 78%)", values: [ "88.1199%", "78", "-33", "78%" ] }
]
#+end_src

**** Functional LCH (=src/internals/color/format/lch.js=)

The LCH color space is another device-independent color format with added support in the CSS Color
Module Level 4 spec. It's an offshoot of CIELAB designed to be a little more useful for people. It
consists of:

+ Lightness (L): a percentage value interpreted identically to CIELAB lightness
+ Chroma (C): a value corresponding to the amount of color desired
+ Hue (H): interpreted similar to HSL, but the angles map to the *a/*b axes

The chroma is theoretically boundless, but in everyday use caps at =230=. The hues at =0deg= and =180deg=
map to magenta-red and green-cyan, respectively. The hues at =90deg= and =270deg= map to a mustard
yellow and sky blue, respectively.

#+NAME: lch-formats
| Format          | Examples                              |
|-----------------+---------------------------------------|
| =lch(L% C H)=     | =lch(0% 0 0)=                           |
| =lch(L% C H / A)= | =lch(50% 0 0)=                          |
|                 | =lch(100% 0 0)=                         |
|                 | =lch(50% 230 0)=                        |
|                 | =lch(29.2345% 44.2 27)=                 |
|                 | =lch(52.2345% 72.2 56.2)=               |
|                 | =lch(60.3119% 34.3 139.3)=              |
|                 | =lch(39.119% 58.1 258.9)=               |
|                 | =lch(79.44% 119 320.89 / 0.7)=          |
|                 | =lch(62.1183% 42.5 81.881 / 89%)=       |
|                 | =lch(119.339% 39.9 130deg)=             |
|                 | =lch(93.411% 74.42 200rad)=             |
|                 | =lch(33% 38.4434 3grad)=                |
|                 | =lch(71.831% 204.314 0.184turn / 0.98)= |

***** LCH Validator

As a refinement of CIELAB, the LCH validator is a slightly modified implementation. It reuses the
CIELAB lightness expression but also pulls in the HSL hue expression. They accept the same input
even if they don't function the same way.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/lch.js" :comments link
/** Validate: functional LCH format */
export function validate(color) {
  // LCH regexp

  // prefix: "lch("
  // lightness: float<0->%
  const lightness = /(?:(?:\d\.?\d?){1,}%)/;
  // chroma: int<0-230>
  const chroma = /(?:(?:230|(?:2[0-2][0-9]|1[0-9][0-9])|(?:\d.?\d?){1,}))/;
  // hue: -?float<0->deg? || -?float<0->rad || -?float<0->grad || -?float<0->turn
  const hue = /(?:-?(?:(?:\d\.?\d?)(?:deg|g?rad|turn)?)+)/;
  // transparency: float<0-1> || float<0-100>%
  const alpha = /(?:(?:0|0\.\d+|1)|(?:100|(?:\d\.?\d?){1,}%))/;
  // separators: " " || " /"
  const valueSep = /(?:[\s]+)/;
  const alphaSep = /(?:[\s/]+)/;
  // suffix: ")"

  return new RegExp(
    [
      "(?:^lch\\(",
      lightness.source,
      valueSep.source,
      chroma.source,
      valueSep.source,
      hue.source,
      "(?:",
      alphaSep.source,
      alpha.source,
      ")?\\))$",
    ].join(""),
  ).test(color);
}
#+END_SRC

And it's format validation test time.

#+BEGIN_SRC deno :results output code replace :allow read :var lchTable=lch-formats
const lch = await import(`${Deno.cwd()}/src/internals/color/format/lch.js`);
const colors = lchTable.map(([a, b]) => b.replace(/=/g, ""));

console.log("const colors =", colors.map((color) => ({color, isLCH: lch.validate(color)})))
#+END_SRC

#+NAME: valid-lch
#+begin_src deno
const colors = [
  { color: "lch(0% 0 0)", isLCH: true },
  { color: "lch(50% 0 0)", isLCH: true },
  { color: "lch(100% 0 0)", isLCH: true },
  { color: "lch(50% 230 0)", isLCH: true },
  { color: "lch(29.2345% 44.2 27)", isLCH: true },
  { color: "lch(52.2345% 72.2 56.2)", isLCH: true },
  { color: "lch(60.3119% 34.3 139.3)", isLCH: true },
  { color: "lch(39.119% 58.1 258.9)", isLCH: true },
  { color: "lch(79.44% 119 320.89 / 0.7)", isLCH: true },
  { color: "lch(62.1183% 42.5 81.881 / 89%)", isLCH: true },
  { color: "lch(119.339% 39.9 130deg)", isLCH: true },
  { color: "lch(93.411% 74.42 200rad)", isLCH: true },
  { color: "lch(33% 38.4434 3grad)", isLCH: true },
  { color: "lch(71.831% 204.314 0.184turn / 0.98)", isLCH: true }
]
#+end_src

***** LCH Extractor

The LCH extractor is identical to the HSL extractor.

#+BEGIN_SRC deno :tangle "./src/internals/color/format/lch.js" :comments link
/** Extract: LCH values */
export const extract = (lch) => lch.match(/(-?[\d.](%|deg|g?rad|turn)?)+/g);
#+END_SRC

Now, I'll set up some extraction tests.

#+BEGIN_SRC deno :results output code replace :allow read :noweb yes
const lch = await import(`${Deno.cwd()}/src/internals/color/format/lch.js`);

<<valid-lch>>

console.log("const colors =", colors.map(({ color }) => ({ color, values: lch.extract(color) })));
#+END_SRC

#+NAME: extracted-lch
#+begin_src deno
const colors = [
  { color: "lch(0% 0 0)", values: [ "0%", "0", "0" ] },
  { color: "lch(50% 0 0)", values: [ "50%", "0", "0" ] },
  { color: "lch(100% 0 0)", values: [ "100%", "0", "0" ] },
  { color: "lch(50% 230 0)", values: [ "50%", "230", "0" ] },
  { color: "lch(29.2345% 44.2 27)", values: [ "29.2345%", "44.2", "27" ] },
  { color: "lch(52.2345% 72.2 56.2)", values: [ "52.2345%", "72.2", "56.2" ] },
  { color: "lch(60.3119% 34.3 139.3)", values: [ "60.3119%", "34.3", "139.3" ] },
  { color: "lch(39.119% 58.1 258.9)", values: [ "39.119%", "58.1", "258.9" ] },
  {
    color: "lch(79.44% 119 320.89 / 0.7)",
    values: [ "79.44%", "119", "320.89", "0.7" ]
  },
  {
    color: "lch(62.1183% 42.5 81.881 / 89%)",
    values: [ "62.1183%", "42.5", "81.881", "89%" ]
  },
  { color: "lch(119.339% 39.9 130deg)", values: [ "119.339%", "39.9", "130deg" ] },
  { color: "lch(93.411% 74.42 200rad)", values: [ "93.411%", "74.42", "200rad" ] },
  { color: "lch(33% 38.4434 3grad)", values: [ "33%", "38.4434", "3grad" ] },
  {
    color: "lch(71.831% 204.314 0.184turn / 0.98)",
    values: [ "71.831%", "204.314", "0.184turn", "0.98" ]
  }
]
#+end_src

And that's it. Full support for validating and extracting the values of all current (and future) CSS
color formats. Not very useful  by itself, so I'm going to write functionality to convert between them.

*** Conversion

* Data

This section documents lookup tables and other hardcoded bits of data used by the core modules.

** Color

*** W3C X11 Color Definitions (=src/data/color/w3c-x11.js=)

This is a lookup table for [[http://www.w3.org/TR/css3-color/#svg-color][all named CSS colors]] as of the CSS4 module updates.

#+BEGIN_SRC deno :tangle "./src/data/color/w3c-x11.js" :comments link
/** X11 color names: https://www.w3.org/TR/css3-color/#svg-color */
export const X11Colors = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
#+END_SRC

*** Accesible Web Defaults (=src/data/color/a11y.js=)

This is a lookup table for [[http://clrs.cc][better web defaults]] optimized for accessibility.

#+BEGIN_SRC deno :tangle "./src/data/color/a11y.js" :comments link
/** Better web default colors: http://clrs.cc */
export const A11yColors = {
  navy: "#001f3f",
  blue: "#0074d9",
  aqua: "#7fdbff",
  teal: "#39cccc",
  olive: "#3d9970",
  green: "#2ecc40",
  lime: "#01ff70",
  yellow: "#ffdc00",
  orange: "#ff851b",
  red: "#ff4136",
  maroon: "#85144b",
  fuchsia: "#f012be",
  purple: "#b10dc9",
  black: "#111111",
  gray: "#aaaaaa",
  grey: "#aaaaaa",
  silver: "#dddddd",
  white: "#ffffff",
};
#+END_SRC

** Typography

*** System Font Stacks (=src/data/typography/system.js=)

This is a lookup table for [[https://systemfontstack.com][system font stacks]] for use by themselves or attached to the end of a font
stack to provide better fallbacks than =sans-serif=, =serif=, or =monospace=.

#+BEGIN_SRC deno :tangle "./src/data/typography/system.js" :comments link
/** System font stacks: https://systemfontstack.com */
const SystemFontStacks = {
  "sans-serif":
    "-apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif",
  serif:
    "Iowan Old Style, Apple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol",
  monospace:
    "Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace",
};
#+END_SRC
